#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. J. Pfennig (c) 2023-2024; BSD License"
CEN_TITLE="A very simple documentation browser and HTML generator"

# ------------------------------------------------------------------------------
# Switch symlink between dynamic and packaged version
# ------------------------------------------------------------------------------
___switch_link() {
    local root="$CEN_ROOT"
    if [ -z "$root" ] ; then
        root='/var/centauri'
    elif [ ! -d "$root/library" ] ; then                # ignore non-sense
        root='/var/centauri'
    fi
    local mode self=$(readlink "$BASH_SOURCE")
    mode="${self##*.}" ; mode="${mode::1}"
    [ -x "$CEN_ROOT/tools/_centauri_bash_lib" ] && mode+='y' || mode+='n'
    case "$mode" in
    dy)     mode= ;;                                    # has lib, link current
    py)     mode='dynamic' ;;                           # link to dynamic
    dn)     mode='package' ;;                           # link to package
    pn)     mode= ;;                                    # has no lib, link current
    *)      mode=                                       # don't know
    esac
    if [ -n "$mode" ] ; then                            # update link and re-run
        ln -s -f "${self%.*}.$mode" "$BASH_SOURCE" || exit 1
        CEN_ROOT=                                       # may contain non-sense
        exec "$BASH_SOURCE" "$@"                        # re-run docviewer
     exit
    fi
}
[ -h "$BASH_SOURCE" ] && ___switch_link "$@"

# ------------------------------------------------------------------------------
# This tool can be built as packaged tool
#
#   docviewer.dynamic           # used by centaurisoho, needs centauri-bash-lib
#   docviewer.package           # static version, created automatically
#
# The dynamic version checks it is newer than the static version and may run:
#
#   centauribuilder pack docviewer docviewer.dynamic con iom pro txt utl
#   ln -s docviewer.package docviewer
# ------------------------------------------------------------------------------

# Import the bash library, set name and version, hide '-g' option from centauribuilder
DAT_GUI='-g' ; [ -n "$CEN_PACKAGE" ] && DAT_GUI=
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -r $DAT_GUI 'docviewer' '0.01:2' 0 1 || exit 2

# Data
CEN_OPT_BROWSE=                 # see --brose
CEN_OPT_DUMB=                   # see --dumb
CEN_OPT_FORMAT=                 # see --format
CEN_OPT_HTML=                   # see --html

CEN_OPT_PAGER=yes               # show --pager in help

DAT_BASE=                       # script base folder
DAT_CSS=                        # css file
DAT_JAV=                        # js file
DAT_FILE=                       # current file
DAT_PAGER=                      # save loc for CEN_PAGER
DAT_TEXT=                       # output of dat_parse()
                                # fixed locations ...
DAT_CONTENT='0 Table of Content'
DAT_HELP='0 Help'

DAT_NEXT=                       # navigator ...
DAT_PREV=                       # ...
DAT_CURR=                       # ...

DAT_TOC_DATA=                   # data for content page
DAT_TOC_FILE=                   # file for serialized DAT_TOC
DAT_TOC_LIST=                   # list of input files
DAT_TOC_UPDT=                   # update flag
DAT_TOC_VERS=0                  # toc format version

declare -g -A DAT_TOC_DICT

# ------------------------------------------------------------------------------
# generate content lists:
#           dat_content -       # main content page
#           dat_content         # dot command '.content'
# ------------------------------------------------------------------------------
dat_content() {
    # dot command '.content': <page> <kind> <text>
    ___content_entr() {
        case "$2" in
        1)      DAT_TEXT+=("14$3") ;;
        2)      DAT_TEXT+=("48$3") ;;
        esac
    }
    # autogenerated content: <page> <kind> <text>
    ___content_page() {
        [ "$2" = 1 -o "$2" = 2 ] || return
        case "$3" in
        [0-9].\ *)      ;;          # ignore page header
        [0-9][0-9].\ *) ;;
        *)              DAT_TEXT+=("48$3") ;;
        esac
    }
    if [ "${1:--}" = '-' ] ; then
        DAT_TEXT+=("200. Table of Content")
        toc_enum '-' ___content_entr
    else
        DAT_TEXT+=("14Content")
        toc_enum "$1" ___content_page
    fi
}

# ------------------------------------------------------------------------------
# parser: syntax analysis
# ------------------------------------------------------------------------------
# While parsing the variable 'kind' is used as parser state ...
#
#       0   empty line mode
#       1   has seen single underline "-*-"
#       2   ...      double underline "=-*"
#       3   text line mode
#
# The result is stored in arry DAT_TEXT as
#
#       <kind><idnt><text>
#
# where 'kind' can be:
#       0   empty line ('idnt' must be 0)
#       1   single underline header
#       2   double underline header
#       3   text
#       4   content line, see dat_content()
# and 'idnt' can be
#       0   input was not indented
#       4   indented by 4
#       8   indented by 8
# ------------------------------------------------------------------------------
dat_parse() {
    #debug -c -- "$*"
    local larr last line idnt kind kinl
    local sect=0 page="${1##*/}"

    DAT_TEXT=()                                     # reset output array
    [ "$page" = "$DAT_CONTENT" ] && return 0        # content page has no input
    page="${page%% *}"                              # get page# from file name
    inpdata -f -a larr -- "$1" || return 1          # get text input

    # loop over text input lines
    for line in "${larr[@]}" ; do
        line="${line%"${line##*[![:space:]]}"}"     # trim right

        case "$line" in
        # skip repeated empty lines and comment lines
        '')             [ "$kind" = 0 ] && continue
                        idnt=0 ; kind=0 ;;
        \#*)            continue ;;

        # text and underline states
        '        '-*-)  idnt=8 ; kind=1 ; line="${line:8}" ;;
        '        '=*=)  idnt=8 ; kind=2 ; line="${line:8}" ;;
        '        '*)    idnt=8 ; kind=3 ; line="${line:8}" ;;
        '    '-*-)      idnt=4 ; kind=1 ; line="${line:4}" ;;
        '    '=*=)      idnt=4 ; kind=2 ; line="${line:4}" ;;
        '    '*)        idnt=4 ; kind=3 ; line="${line:4}" ;;
        -*-)            idnt=0 ; kind=1 ;;
        =*=)            idnt=0 ; kind=2 ;;

        # dot commands
        .content)       dat_content "$page" ; continue ;;
        .title)         last="${1##*/}" ; last="${last/ /. }"
                        DAT_TEXT+=('') ; line="${last//?/=}"
                        idnt=0 ; kind=2 ;;

        # capture everything else as text
        *)              idnt=0 ; kind=3
        esac

        # check -/= underlining, handle header autonumber and header TOC
        ___parse_kind() {
            local mark='-' text
            [ "$kind" = 2 ] && mark='='
            [ ${#line} = ${#last} -a -z "${line//$mark/}" ] || return 1
            if [ "${last::2}" = '. ' ] ; then
                if [ "$sect" = 0 ] ; then
                    printf -v last '%s. %s' "$page" "${last:2}"
                else
                    printf -v last '%s.%02d %s' "$page" "$sect" "${last:2}"
                fi
            fi
            DAT_TEXT[-1]="$kind$idnt${text:-$last}"
            case "$last" in
            [0-9].[0-9]*)   toc_item "$page" 2 "$last" ; ((sect += 1)) ; kind=1 ;;
            [0-9].*)        toc_item "$page" 1 "$last" ; ((sect += 1)) ;;
            [1-9][0-9].*)   toc_item "$page" 1 "$last" ; ((sect += 1)) ;;
            esac
            return 0
        }

        case "$kind" in
        0)  ;;
        1)  ___parse_kind && continue
            kind=3 ;;
        2)  ___parse_kind && continue
            kind=3 ;;
        *)
        esac
        if [ "$kind" = 3 -a "$idnt" = 0 ] && [ "$kinl" = 3 ] ; then
            last= ; DAT_TEXT[-1]+=" $line"
        else
            last="$line" ; DAT_TEXT+=("$kind$idnt$line")
        fi
        kinl="$kind"
    done
}

# ------------------------------------------------------------------------------
# prettify header lines: prettify <vnam> <text>
# ------------------------------------------------------------------------------
hdr_pretty() {
    local _text="$2"
    case "$_text" in
    [0-9][0-9].0[0-9]\ *)
        _text=("${_text::3}${_text:4:1} ${_text:5}") ;;
    [0-9].0[0-9]\ *)
        _text=("${_text::2}${_text:3:1} ${_text:4}") ;;
    esac
    printf -v "$1" "%s" "$_text"
}

#-------------------------------------------------------------------------------
# html output formatting
#-------------------------------------------------------------------------------
output_html() {
    #debug -c -- "$*"
    # <tag> <idnt> <url> <text>
    ___link() {
        xml_element "$1" -b
            [ -n "$2"  ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
            [ "$2" = 2 ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
            local _text
            xml_text -v _text -- "$4"
            _text="${_text/  /\&nbsp;\&nbsp;}"
            xml_anchor -l -u "$3" "$_text"
        xml_element "$1" -n -e
    }

    # <tag> <idnt> <mark> <text>
    ___mark() {
        local _text
        xml_text -v _text -- "$4"
        _text="${_text/  /\&nbsp;\&nbsp;}"
        [ -n "$2"  ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
        [ "$2" = 2 ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
        xml_element "$1#$3" -- "$_text"
    }

    if [ "$1" = "$DAT_HELP" ] ; then
        :
    elif [ "$1" = "$DAT_CONTENT" ] ; then
        dat_content -
        toc_enum -
    else
        toc_enum "$1"
    fi

    local line text file mark mpre htag idnt page="${1%% *}"
    for line in "${DAT_TEXT[@]}" ; do
        text="${line:2}"
        idnt=

        # h1: page title  h2: chapter  h3: content header  h4: content item

        # 2x  -> h1     page header
        # 1x  -> h3     content header
        # 3x            text
        # 4x  -> h4     content item
        # 42. -> h2     chapter

        case "${line::3}" in
        0*)     htag='br'     ;;
        10?)    htag='h3'     ;;
        14?)    htag='h3'     ; idnt=1 ;;
        18?)    htag='p.bold' ; idnt=1 ;;
        2*)     htag='h1'     ;;
        30?)    htag='p'      ;;
        38?)    htag='pre'    ; idnt=1 ;;
        42?)    htag='h3'     ;;
        48?)    htag='h4'     ; idnt=2 ;;
        *)      htag='pre'    ; idnt=  ;;
        esac

        if [ "$htag" = 'h1' -o "$htag" = 'h2' ] ; then
            mark="${text%% *}"
            hdr_pretty text "$text"
            ___mark "$htag" "$idnt" "$mark" "$text"
            continue
        elif [ "$htag" = 'h3' ] ; then
            toc_file "$text" - file
            hdr_pretty text "$text"
            ___link "$htag" "$idnt" "$file" "$text"
            continue
        elif [ "$htag" = 'h4' ] ; then
            local mark="${text%% *}"
            hdr_pretty text "$text"
            if [ "${DAT_TOC_DICT["$mark"]}" = 2 ] ; then
                ___link "$htag" "$idnt" "$file#${mark}" "$text"
            else
                ___link "$htag" "$idnt" "#$mark" "$text"
            fi
            continue
        elif [ "$htag" = 'pre' ] ; then
            if [ -z "$mpre" ] ; then
                xml_element 'pre' -b
                mpre="x$CEN_XML_INDENT" ; CEN_XML_INDENT=
            fi
            [ -n "$idnt" ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'

            if [ -n "$text" ] && [ -n "${DAT_TOC_DICT["$text"]}"  ] ; then
                xml_anchor -m "${text%% *}" -n -- "$text"
            else
                xml_text -o -- "$text"
            fi
            continue
        elif [ -n "$mpre" ] ; then
            xml_element 'pre' -e -n ;
            CEN_XML_INDENT="${mpre:1}" ; mpre=
        fi
        [ -n "$idnt" ] && { text="    $text" ; text="${text// /\&nbsp;}" ; }
        xml_element "$htag" -n -- "$text"
    done
    [ -n "$mpre" ] && xml_element 'pre' -e -n
}

# ------------------------------------------------------------------------------
# Text output of parsed data
# ------------------------------------------------------------------------------
#   loop over DAT_TEXT (output of dat_parse())
#       use prefix bytes for output mode
#       use output()
#   padding to prevent pager from quitting
# ------------------------------------------------------------------------------
output_line() {
    output -l "$@" ; ((cout += 1))
}

output_text() {
    local line text cout=2 deco='two'

    [ "${#DAT_TEXT[@]}" = 0 ] && dat_content -      # empty array generates page 0
    for line in "${DAT_TEXT[@]}" ; do
        text="${line:2}"
        case "${line::2}" in
        14)     output_line ; output '    ' ;;
        [1-4]4) output '    ' ;;
        [1-4]8) output '        '
        esac

        case "$line" in
        #2?...)  output_line
        #        output_line -d bold -- "Content" ;;
        0*)     output_line ;;
        1?*)
        hdr_pretty text "$text"
            output_line -d bold -- "$text" ;;
        20*)    output_line -d "$deco" -x $CEN_COLS .
        hdr_pretty text "$text"
                output_line -d bold -- "$text"
                output_line -d "$deco" -x $CEN_COLS .
                #output_line ;
                deco='one' ;;
        2?*)    output_line -d ital -- "$text" ;;
        30*)    last="$text"
                while txtfold -m $((CEN_COLS - 4)) -s line last ; do
                    output_line -- "    $line"
                done ;;
        3?[0-9]*)
                output_line -- "$text" ;;
        4*)     hdr_pretty text "$text"
                output_line -- "$text" ;;
        *)      output_line -- "$text"

        esac
    done

    if [ "${DAT_TEXT[-1]::1}" != 0 ] ; then     # add empty line
        output_line
    fi
    output -l -d two -x "$CEN_COLS" .

    # padding with empty lines, pager must not quit for short file
    [ -z "$DAT_PAGER" ] && return
    while [ "$cout" -lt "$CEN_ROWS" ] ; do
        echo ; ((cout += 1))
    done
}

# ------------------------------------------------------------------------------
# The one and only action
# ------------------------------------------------------------------------------
run() {
    # display format help (console only), no return
    [ -n "$CEN_OPT_FORMAT" ] && embed -m _centauri_bash_use -h

    resolve -f -x -p -s DAT_BASE
    folder -f -c -- "$DAT_BASE"
    set -- "${1##*/}"

    # running as dynamic version
    if [ -z "$CEN_PACKAGE" ] ; then
        # update docviewer.packaged
        if [ -z "$CEN_OPT_ZOMBIE" ] && [ "$CEN_NAME.dynamic" -nt "$CEN_NAME.package" ] ; then
            embed centauribuilder --yes pack "$CEN_NAME" "$CEN_NAME.dynamic" con iom pro txt utl
            symlink -n -- "${DAT_BASE##*/}/$CEN_NAME.package" "../$CEN_NAME"
        fi
    elif [ "$CEN_OPT_BROWSE" = 1 ] ; then
        quit -e "Option '--browse=1' needs 'centauri-bash-lib' being installed"
    elif [ -n "$CEN_OPT_HTML" ] ; then
        quit -e "Option '--html=...' needs 'centauri-bash-lib' being installed"
    else
        CEN_OPT_BROWSE=0
    fi

    # imply --browse if not running as console app
    case "$CEN_OPT_BROWSE" in
    0)  ;;
    1)  [ "${CEN_DISPLAY:-tty}" = 'tty' ] && CEN_OPT_BROWSE=0 ;;
    *)  context -q && CEN_OPT_BROWSE=0 || CEN_OPT_BROWSE=1
    esac

    # just browse html, no toc updates needed
    if [ "$CEN_OPT_BROWSE" = 1 ] ; then
        toc_load || quit "No valid index, run '$CEN_NAME --html=<dest>' first"
        run_browse "$1"
        return
    fi

    # all other modes depend on a valid toc
    if [ -z "$CEN_OPT_FORCE" ] && toc_load ; then
        local file
        for file in "${DAT_TOC_LIST[@]}" ; do           # check for updates...
            toc_drop "$file" && continue
            trace -a -c "Update page" "$1"
            dat_parse "$file"
        done
        toc_save
    else
        progress "Updating toc "
        [ -z "$DAT_TOC_FILE" ] && toc_load
        matchpath -e -f -a DAT_TOC_LIST -- [1-9]\ * [1-9][0-9]\ *
        local file coun=0 totl="${#DAT_TOC_LIST[@]}"
        for file in "${DAT_TOC_LIST[@]}" ; do
            if [ "${file%% *}" = 0 ] ; then
                ((totl -= 1)) ; continue
            fi
            dat_parse "$file" || quit -e "Failed to parse input:" "$file"
            ((coun += 1))
            progress -s $coun:$totl -c .
        done
        toc_save ; progress
    fi

    if [ -n "$CEN_OPT_HTML" ] ; then
        run_html
    else
        run_menu "$1"
    fi
}

# ------------------------------------------------------------------------------
# Run a browser: [<key>]
# ------------------------------------------------------------------------------
run_browse() {
    folder -c -f -n -- "${CEN_OPT_HTML:-html}"
    local secs=("$DAT_CONTENT" "${DAT_TOC_LIST[@]}")
    local file html
    [ "${1:--}" = '-' ] || listsearch -m file -g -i secs -- "*$1*"
    toc_file "${file:-$secs}" - html
    embed -v centaurilauncher view "$PWD/$html"
}

# ------------------------------------------------------------------------------
# generate html
# ------------------------------------------------------------------------------
# The 'Table of Content' page is autogenerated from the DAT_TOC_DATA list,
# which is persistently cached in DAT_TOC_FILE. If the cache is invalid
# all pages must be regenerated.
# ------------------------------------------------------------------------------
run_html() {
    local file html
    message -a -p "Processing %s files" "${#DAT_TOC_LIST[@]}"
    folder -c -f -n -- "$CEN_OPT_HTML"

    # generate css and javascript
    run_html_css ; run_html_java
    DAT_NEXT= ; DAT_PREV= ; DAT_CURR=

    html="$DAT_HELP.html" ; html="${html// /_}"
    if [ "$DAT_BASE/$DAT_HELP" -nt "$html" -o -n "$CEN_OPT_FORCE" ] ; then
        run_html_create "$DAT_HELP" "$html"
    fi

    # page 0 is auto-generated from TOC
    local secs=("$DAT_CONTENT" "${DAT_TOC_LIST[@]}")
    for file in "${secs[@]}" '' ; do
        DAT_PREV="$DAT_CURR" ; DAT_CURR="$DAT_NEXT" ; DAT_NEXT="$file"
        [ -z "$DAT_CURR" ] && continue

        if [ "$DAT_CURR" = "$DAT_HELP" ] ; then
            html="$DAT_HELP.html" ; html="${html// /_}"
            run_html_create "$DAT_HELP" "$html"
            continue
        elif [ "$DAT_CURR" = "$DAT_CONTENT" ] ; then
            toc_file "$DAT_CURR" - html
        else
            toc_file "$DAT_BASE/$DAT_CURR" + html && continue
        fi
        run_html_create "$DAT_CURR" "$html"
    done
    message "Done."
}

# unused: internal links
#run_html_link() {
#    local -n ___link_txt="$1"
#
#    local subs="$___link_txt" xkey xtag tail html
#    while [[ "$subs" =~ (.*)\[\[([a-zA-Z]*)(#[a-zA-Z]*)?\]\](.*) ]] ; do
#        subs="${BASH_REMATCH[1]}"           # not yet parsed
#        xkey="${BASH_REMATCH[2]}"           # key
#        xtag="${BASH_REMATCH[3]:1}"         # tag
#        if listsearch -m html -g -i DAT_FLIST -- "*$xkey*" ; then
#            ___html html "$html"
#            if [ -z "$xtag" ] ; then
#                xml_anchor -u "$html" -v xkey "$xkey"
#            else
#                xml_anchor -u "$html#$xtag" -v xkey "$xtag"
#            fi
#        else
#            warning -a "Unresolved link:" "$xkey"
#            xkey="<b>[[$xkey]]</b>"
#        fi
#        tail="$xkey${BASH_REMATCH[4]}$tail" # already parsed
#    done
#    [ -z "$xkey" ] || ___link_txt="$subs$tail"
#}

# parse input and create html: <text> <html>
run_html_create() {
    local text="$DAT_BASE/$1" html="$2"
    message -a -c "Generate html" "$html"
    dat_parse "$text" || quit -e "Failed to parse input:" "$1"
    # create -t -v DAT_TEXT -- "$html.txt"

    xml_document -5 -b -c "$DAT_CSS" -s "$DAT_JAV" -i 1 -o "$html" -- "onload='initialize()'"
    xml_element 'article#top' -b -n
    run_html_navig "/var/www/html/index.html"       # upper navigator line
    output_html "$1"
    run_html_navig                                  # lower navigator line
    xml_element article -e
    xml_document -e
}

# generate link: <clas> ...
run_html_anchor() {
    local clas="$1" ; shift
    xml_element "div" -c "$clas" -b
    [ -n "$2" ] && xml_anchor "$@"
    xml_element "div" -e -n
}

# generate navigator line: <home>
run_html_navig() {
    local curr home="$1" npre nnxt cont
    [ -n "$DAT_NEXT" ] && toc_file "$DAT_NEXT" - nnxt
    [ -n "$DAT_PREV" ] && toc_file "$DAT_PREV" - npre
    xml_element 'nav' -b ; xml_element "div" -c 'nav-row' -b -n -i
        run_html_anchor 'nav-left'  -u "$npre" "[<< previous]"
        if [ -z "$home" ] ; then
            run_html_anchor 'nav-mid' -m 'top' "[Top of Page]"
        else
            run_html_anchor 'nav-mid' -u "$home#top" "[Local Web]"
        fi
        if [ "$DAT_CURR" != "$DAT_CONTENT" ] ; then
            toc_file "$DAT_CONTENT" - curr
            run_html_anchor 'nav-mid' -u "$curr#top" "[Content]"
        fi
        run_html_anchor 'nav-right' -u "$nnxt" "[next >>]"
    xml_element "div" -e -n ; xml_element 'nav' -e -n -u
}

# generate a css file
run_html_css() {
    DAT_CSS="doc.css"
    [ "$DAT_CSS" -nt "$DAT_BASE/$CEN_NAME" -a -z "$CEN_OPT_FORCE" ] && return
    message -a "Creating CSS file"
    create -c -t -- "$DAT_CSS" <<!EOF
/* autogenerated by $CEN_NAME - do not edit */

/* --- tag selectors --- */

a {
    font-family: monospace;
    text-decoration: none;
    color: brown;
}

body {
    font-family: monospace;
    font-size: 6pt;
    background-color: #eff6f8;
    margin: 0;
    margin-left: 2em;
    margin-right: 1em;
}

p {
    font-size: 10pt;
    margin: inherit;
    text-align: justify;
}

p.bold {
    font-size: 10pt;
    font-weight: bold;
    margin: inherit;
    text-align: justify;
}

pre, div {
    font-size: 10pt;
    background-color: ivory;
    margin: inherit;
}

/* --- headers h1: page title  h2: chapter  h3: content header  h4: content item --- */

h1 {
    font-size: 14pt;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

h2 {
    font-size: 12pt;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

h3 {
    font-size: 12pt;
    margin-top: 10pt;
    margin-bottom: 3pt;
}

h4 {
    font-size: 11pt;
    margin-top: 0pt;
    margin-bottom: 0pt;
}

/* ---- navigator (table layout) ---- */

nav {
    font-size: $fsml;
    display: table;
    width: 100%;
    background-color: cadetblue;
    color: white;
    font-weight: bold;
    border-style: solid;
    border-width: thin;
    border-color: black;
    box-sizing: border-box;
}

div.nav-row {
    display: table-row;
}

div.nav-left {
    display: table-cell;
    width: 30%;
    text-align: left;
}

div.nav-right {
    display: table-cell;
    width: 30%;
    text-align: right;
}

div.nav-mid {
    display: table-cell;
    width: 20%;
    text-align: center;
}

!EOF
}

# generate a script file
run_html_java() {
    DAT_JAV="doc.js"
    [ "$DAT_JAV" -nt "$DAT_BASE/$CEN_NAME" -a -z "$CEN_OPT_FORCE" ] && return
    message -a "Creating JScript file"
    create -c -t -- "$DAT_JAV" <<!EOF
/* autogenerated by $CEN_NAME - do not edit */

function initialize(dummy) {                    // called from body onload
    var obj = document.firstElementChild;
    obj.setAttribute('onkeydown', 'keydown(event)');
}

function keydown(event) {
    switch(event.key) {
        case 'Backspace':
            history.back(); break;
        case 'q':
        case 'Escape':
            console.log("QUIT"); break;         // handled in qml code
        case 'c':
            window.location='${DAT_CONTENT// /_}.html'; break;
        case 'h':
            window.location='${DAT_HELP// /_}.html'; break;
        case 'n':
        case 'ArrowRight':
            navigate('right'); break;
        case 'p':
        case 'ArrowLeft':
            navigate('left'); break;
        case 't':
            window.location='#top'; break;
        case 'w':
            window.location='http://localhost'; break;
        default:
            console.log("Key: ", event.key)
    }
}

function navigate(dest) {
    var elts = document.getElementsByClassName('nav-' + dest);
    if (elts.length < 1) return;
    var child=elts[0].firstChild; if (child == null) return;
    dest=child.getAttribute('href'); if (dest != null) window.location=dest;
}
!EOF
}

# ------------------------------------------------------------------------------
# text menu mode
# ------------------------------------------------------------------------------
#   get file list
#       show menu
#       selection of a file
#           dat_parse()
#           output_text()
# ------------------------------------------------------------------------------
run_find() {
    local indx=0 offs=0 list item
    while : ; do
        list=("${DAT_TOC_DATA[@]:offs}")
        [ -z "$list" ] && break
        listsearch -n indx -g -i list -- "$1" || break
        ((offs += indx))
        [ -z "$item" ] && message -m "Found in section content:" ''
        item="${DAT_TOC_DATA[offs]#? ? }"
        message -a "$item"
        ((offs+=1))
    done
    [ -n "$item" ] && message -i
}
run_menu() {
    local skey cpag page="${1%% *}"
    if [ -n "$CEN_OPT_DUMB" ] ; then
        console -m 0 ; DAT_PAGER=
    elif ! console -c 0 -r 0 ; then
        DAT_PAGER=
    fi
    : ${CEN_COLS:=90} ; [ "$CEN_COLS" -gt 96 ] && CEN_COLS=96

    if [ -z "$DAT_PAGER" ] ; then
        cpag='message -i'
    else
        system -c clear && cpag='clear'
    fi

    # page 0 is auto-generated from TOC
    local secs=("$DAT_CONTENT" "$DAT_HELP" "${DAT_TOC_LIST[@]}")

    # display a single page
    if [ -n "$1" ] ; then
        if listsearch -m DAT_FILE -g -i secs -- "*$1*" ; then
            :
        elif run_find "*$1*" ; then
            quit
        else
            quit "No matching topic:" "$1"
        fi
        dat_parse "$DAT_FILE" || quit -e "Failed to parse input:" "$DAT_FILE"
        $cpag
        $DAT_PAGER output_text
        return
    fi

    # enter menu mode loop
    CEN_HISTORY='-'
    while : ; do
        $cpag
        output -l -d two -x $CEN_COLS .
        output -l -d bold -- "Documentation Viewer: List of Documentation Sections"
        output -l -d two -x $CEN_COLS .
        output -l

        for skey in "${secs[@]}" ; do
            [ "$skey" = "$DAT_HELP" ] && continue
            output -l "        ${skey/ /. }"
        done
        output -l
        output -l "        Type 'help' to get information about viewing the documentation as HTML"
        output -l "             'quit' to close the documentation viewer."
        output -l ; output -l -d 'two' -x $CEN_COLS . ; output -l

        confirm -p - -s skey "Please select a section number or a keyword"
        case "$skey" in
        ''|q*)  $cpag ; return ;;
        h)      skey="$DAT_HELP" ;;
        [0-9])  skey+=' ?' ;;
        esac

        if listsearch -m DAT_FILE -g -i secs -- "*$skey*" ; then
            dat_parse "$DAT_FILE" || quit -e "Failed to parse input:" "$DAT_FILE"
            $cpag
            $DAT_PAGER output_text
        else
            message -a -d error "No matching topic:" "$skey" ; sleep 2
        fi
    done
}

# ------------------------------------------------------------------------------
# remove a page from TOC list: <file>
# ------------------------------------------------------------------------------
toc_drop() {
    local page="${1%% *}"
    trace -a -c "cache page" "$1"
[ "$page" = "$1" ] && fatal -t xxx
    if [ "${DAT_TOC_UPDT:-1}" = 1 ] ; then
        [ "$DAT_TOC_FILE" -nt "$1" ] && return 0    # toc for file is current
    elif [ "$DAT_TOC_UPDT" = 2 ] ; then
        DAT_TOC_DATA+=("$page 0") ; return 1
    fi

    local item list=("${DAT_TOC_DATA[@]}") ; DAT_TOC_DATA=()
    for item in "${list[@]}" ; do
        [ "${item%% *}" = "$page" ] || DAT_TOC_DATA+=("$item")
    done
    DAT_TOC_DATA+=("$page 0")
    [ -z "$DAT_TOC_UPDT" ] && DAT_TOC_UPDT=1
    return 1
}

# ------------------------------------------------------------------------------
# make html name, check if file was updated: <file> <fref>|-|+ [<vnam>]
#
#   toc_file    <file> <fref>       # check if <fref> is newer then <file>
#   toc_file    <file> + <vname>    # check if html file is newer then <file>
#   toc_file    <file> - <vname>    # only generate html file name from <file>
# ------------------------------------------------------------------------------
toc_file() {
    local _file="$1" _fref="${2:--}" _vnam="$3"
    if [ "$_fref" = '-' -o "$_fref" = '+' ] ; then
        _fref="${_file##*/}"
        _fref="${_fref//[ .,:]/_}"
        _fref="${_fref//__/_}.html"
        [ -n "$_vnam" ] && printf -v "$_vnam" '%s' "$_fref"
        [ "${2:--}" = '-' ] && return 0             # no time check
    fi

    [ -n "$CEN_OPT_FORCE" ] && return 1             # option --force
    [ "$_fref" -nt "$_file" ]                       # return status
}

# ------------------------------------------------------------------------------
# enumerate items of a TOC page: <page> [<call>]
# ------------------------------------------------------------------------------
toc_enum() {
    [ -z "$2" ] && DAT_TOC_DICT=()
    local item valu
    for item in "${DAT_TOC_DATA[@]}" ; do
        [ "$1" != '-' ] && [ "${item%% *}" != "$1" ] && continue
        valu="${item#* }"                           # remove <page>
        if [ -z "$2" ] ; then
            item="${valu#* }"
            DAT_TOC_DICT["${item%% *}"]="${valu%% *}"
        else
            isfunction -c -e -- "$2" "${item%% *}" "${valu%% *}" "${valu#* }"
        fi
    done
}

# ------------------------------------------------------------------------------
# add an item to TOC list: <page> <kind> <item>
# ------------------------------------------------------------------------------
toc_item() {
    [ -z "$DAT_TOC_UPDT" ] && return
    DAT_TOC_DATA+=("$1 $2 $3")
    DAT_TOC_UPDT=1
}

# ------------------------------------------------------------------------------
# load TOC list from cache: -no arg-
# ------------------------------------------------------------------------------
toc_load() {
    local file self vers="$DAT_TOC_VERS"
    folder -s file -g -b 'persistent' "soho_$CEN_NAME"
    resolve -f -x -p -s self -- "$BASH_SOURCE"

    DAT_TOC_FILE="$file" ; DAT_TOC_DATA=() ; DAT_TOC_UPDT=

    if [ "$self" -nt "$file" ] ; then
        trace -a -c "content cache" "Script has been updated"
    elif ! serialize -n "$file" -q -r -- DAT_TOC_VERS DAT_TOC_LIST DAT_TOC_DATA ; then
        trace -a -c "content cache" "No valid data"
    elif [ "$vers" != "$DAT_TOC_VERS" ] ; then
        trace -a -c "content cache" "Version mismatch"
    else
        return 0
    fi

    DAT_TOC_VERS="$vers" ; DAT_TOC_DATA=() ; DAT_TOC_UPDT=2
    return 1
}

# ------------------------------------------------------------------------------
# save TOC list to cache: -no arg-
# ------------------------------------------------------------------------------
toc_save() {
    [ -z "$CEN_OPT_FORCE" -a -z "$DAT_TOC_UPDT" ] && return 0
    [ "$DAT_TOC_UPDT" = 1 ] && txtsort -i DAT_TOC_DATA -a DAT_TOC_DATA
    DAT_TOC_UPDT=
    serialize -m 664 -n "$DAT_TOC_FILE" -w -- DAT_TOC_VERS DAT_TOC_LIST DAT_TOC_DATA
}

# ------------------------------------------------------------------------------
# option parsing: <option> <argument>
# ------------------------------------------------------------------------------
options() {

    case "$1" in
    '') DAT_PAGER="$CEN_PAGER" ; CEN_PAGER= ;;

    -B|--bro*)
        optarg 'browse' -              -o  ;;   # ternary flag
    -D|--dum|--dumb)
        optarg 'dumb'   -                  ;;   # simple flag
    -F|--for*)
        CEN_OPT_PAGER=                          # enable centaurihelp
        optarg 'format' -                  ;;   # simple flag
    -H|--htm|--html)
        [ "$2" = '-' ] && CEN_ARGOPT[0]="$CEN_ROOT/html"
        optarg 'html'   -              -t  ;;   # folder

    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    [ -n "$CEN_OPT_FORMAT" ] && usage_format || usage_help
}

usage_format() {
    usagecat << !EOF
Format: The README documentation files use an intentionally simple format. The main
    purpose of this format is to allow the automated creation of linked HTML pages.

Parser: Documentation files are processed in two steps: (1) parser (2) output text/html.
    The parser creates an array of text lines with a two digit code-prefix. Comment
    lines (starting with '#') are ignored, multiple empty lines are stored as single
    empty line. The 1st code digit is the line-kind, the 2nd digit can be 0, 4 or 8
    depending on the number of leading spaces (which are removed). Examples:

Examples: input                                  output
    ─────────────────────────────────────  ─────────────────────────────────────
    # comments are ignored
    °                                      00
    chapter header
    ==============                         20Chapter Header
    header
    ------                                 10Header
    text block,
    can span multiple lines                30text block, can span multiple lines
    °                                      00
    °   literal text                       34literal text
    °       literal indented               38literal indented
    °   literal bold text
    °   -----------------                  14literal bold text
    ─────────────────────────────────────  ─────────────────────────────────────

Commands:   Input lines can be dot commands ...
    .title              # generates a page title from the file name
    .content            # generates a 'Table Of Content' from a dictionary

Output: In the output step the parser result is formatted either as text or html. Hyper-
    links are generated using a dictionary for code 10 (destination) and code 34, 38
    (link). Only lines starting with a digit are added to the dictionary.
!EOF
    return 0
}

usage_help() {
    usagecat << !EOF
$CEN_USE_HEADER

       This tool can

           (1) display a menu and documentation content in text mode
           (2) create HTML files from documentation text
           (3) browse HTML documentation (needs a GUI obviously)

$CEN_USE_OPTIONS

       -B --browse  <mode>  [*] browse HTML formatted text (default: --browse=2)
       -D --dumb            no ANSII escapes, no pager
       -F --format          show help about the doc source text format
       -H --html    <html>  [*] HTML folder

       [*] centauri-bash-lib must be installed to use these options

arguments:
       <html>               an existing folder for html output
       <mode>               0|off:=text mode  1|on:=html mode  2|auto:=auto

examples:
       # text menu and documentation content
       $CEN_NAME           # show menu
       $CEN_NAME   netw    # show text file that matches 'netw'

       # creating HTML documentation
       $CEN_NAME --html=-  # create in $CEN_ROOT/html
       $CEN_NAME --html=/tmp/test
                           # create HTML in /tmp/test

       # brose HTML documentation
       $CEN_NAME --browse  # start with /var/www/html/index.html
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
