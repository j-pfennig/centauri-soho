#!/usr/bin/bash
# ================ centauri-bash-package of: docviewer.dynamic =================

# get installation folder and command name
CEN_NAME="$BASH_SOURCE"
[ -h "$CEN_NAME" ] && CEN_NAME=$(readlink -f -- "$CEN_NAME")
CEN_ROOT="${CEN_NAME%.*}"
CEN_NAME="${CEN_ROOT##*/}"
[ "${CEN_ROOT::1}" = '/' ] || CEN_ROOT="$PWD/${CEN_ROOT#./}"
CEN_ROOT="${CEN_ROOT%/*}"

# arguments passed to _cen_bash_load_lib
_CEN_BASH_ARGS=(-a -d -f -r $DAT_GUI 'docviewer' '0.01:2' 0 1)

# === the 'static' script code before the 'main' call goes into this wrapper ===
_cen_bash_init() {

#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. J. Pfennig (c) 2023-2024; BSD License"
CEN_TITLE="A very simple documentation browser and HTML generator"

# ------------------------------------------------------------------------------
# Switch symlink between dynamic and packaged version
# ------------------------------------------------------------------------------
___switch_link() {
    local root="$CEN_ROOT"
    if [ -z "$root" ] ; then
        root='/var/centauri'
    elif [ ! -d "$root/library" ] ; then                # ignore non-sense
        root='/var/centauri'
    fi
    local mode self=$(readlink "$BASH_SOURCE")
    mode="${self##*.}" ; mode="${mode::1}"
    [ -x "$CEN_ROOT/tools/_centauri_bash_lib" ] && mode+='y' || mode+='n'
    case "$mode" in
    dy)     mode= ;;                                    # has lib, link current
    py)     mode='dynamic' ;;                           # link to dynamic
    dn)     mode='package' ;;                           # link to package
    pn)     mode= ;;                                    # has no lib, link current
    *)      mode=                                       # don't know
    esac
    if [ -n "$mode" ] ; then                            # update link and re-run
        ln -s -f "${self%.*}.$mode" "$BASH_SOURCE" || exit 1
        CEN_ROOT=                                       # may contain non-sense
        exec "$BASH_SOURCE" "$@"                        # re-run docviewer
     exit
    fi
}
[ -h "$BASH_SOURCE" ] && ___switch_link "$@"

# ------------------------------------------------------------------------------
# This tool can be built as packaged tool
#
#   docviewer.dynamic           # used by centaurisoho, needs centauri-bash-lib
#   docviewer.package           # static version, created automatically
#
# The dynamic version checks it is newer than the static version and may run:
#
#   centauribuilder pack docviewer docviewer.dynamic con iom pro txt utl
#   ln -s docviewer.package docviewer
# ------------------------------------------------------------------------------

# Import the bash library, set name and version, hide '-g' option from centauribuilder
DAT_GUI='-g' ; [ -n "$CEN_PACKAGE" ] && DAT_GUI=
# PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -r $DAT_GUI 'docviewer' '0.01:2' 0 1 || exit 2

# Data
CEN_OPT_BROWSE=                 # see --brose
CEN_OPT_DUMB=                   # see --dumb
CEN_OPT_FORMAT=                 # see --format
CEN_OPT_HTML=                   # see --html

CEN_OPT_PAGER=yes               # show --pager in help

DAT_BASE=                       # script base folder
DAT_CSS=                        # css file
DAT_JAV=                        # js file
DAT_FILE=                       # current file
DAT_PAGER=                      # save loc for CEN_PAGER
DAT_TEXT=                       # output of dat_parse()
                                # fixed locations ...
DAT_CONTENT='0 Table of Content'
DAT_HELP='0 Help'

DAT_NEXT=                       # navigator ...
DAT_PREV=                       # ...
DAT_CURR=                       # ...

DAT_TOC_DATA=                   # data for content page
DAT_TOC_FILE=                   # file for serialized DAT_TOC
DAT_TOC_LIST=                   # list of input files
DAT_TOC_UPDT=                   # update flag
DAT_TOC_VERS=0                  # toc format version

declare -g -A DAT_TOC_DICT

# ------------------------------------------------------------------------------
# generate content lists:
#           dat_content -       # main content page
#           dat_content         # dot command '.content'
# ------------------------------------------------------------------------------
}

# ====== main part of script (subroutines only) needs not to be modified =======
dat_content() {
    # dot command '.content': <page> <kind> <text>
    ___content_entr() {
        case "$2" in
        1)      DAT_TEXT+=("14$3") ;;
        2)      DAT_TEXT+=("48$3") ;;
        esac
    }
    # autogenerated content: <page> <kind> <text>
    ___content_page() {
        [ "$2" = 1 -o "$2" = 2 ] || return
        case "$3" in
        [0-9].\ *)      ;;          # ignore page header
        [0-9][0-9].\ *) ;;
        *)              DAT_TEXT+=("48$3") ;;
        esac
    }
    if [ "${1:--}" = '-' ] ; then
        DAT_TEXT+=("200. Table of Content")
        toc_enum '-' ___content_entr
    else
        DAT_TEXT+=("14Content")
        toc_enum "$1" ___content_page
    fi
}

# ------------------------------------------------------------------------------
# parser: syntax analysis
# ------------------------------------------------------------------------------
# While parsing the variable 'kind' is used as parser state ...
#
#       0   empty line mode
#       1   has seen single underline "-*-"
#       2   ...      double underline "=-*"
#       3   text line mode
#
# The result is stored in arry DAT_TEXT as
#
#       <kind><idnt><text>
#
# where 'kind' can be:
#       0   empty line ('idnt' must be 0)
#       1   single underline header
#       2   double underline header
#       3   text
#       4   content line, see dat_content()
# and 'idnt' can be
#       0   input was not indented
#       4   indented by 4
#       8   indented by 8
# ------------------------------------------------------------------------------
dat_parse() {
    #debug -c -- "$*"
    local larr last line idnt kind kinl
    local sect=0 page="${1##*/}"

    DAT_TEXT=()                                     # reset output array
    [ "$page" = "$DAT_CONTENT" ] && return 0        # content page has no input
    page="${page%% *}"                              # get page# from file name
    inpdata -f -a larr -- "$1" || return 1          # get text input

    # loop over text input lines
    for line in "${larr[@]}" ; do
        line="${line%"${line##*[![:space:]]}"}"     # trim right

        case "$line" in
        # skip repeated empty lines and comment lines
        '')             [ "$kind" = 0 ] && continue
                        idnt=0 ; kind=0 ;;
        \#*)            continue ;;

        # text and underline states
        '        '-*-)  idnt=8 ; kind=1 ; line="${line:8}" ;;
        '        '=*=)  idnt=8 ; kind=2 ; line="${line:8}" ;;
        '        '*)    idnt=8 ; kind=3 ; line="${line:8}" ;;
        '    '-*-)      idnt=4 ; kind=1 ; line="${line:4}" ;;
        '    '=*=)      idnt=4 ; kind=2 ; line="${line:4}" ;;
        '    '*)        idnt=4 ; kind=3 ; line="${line:4}" ;;
        -*-)            idnt=0 ; kind=1 ;;
        =*=)            idnt=0 ; kind=2 ;;

        # dot commands
        .content)       dat_content "$page" ; continue ;;
        .title)         last="${1##*/}" ; last="${last/ /. }"
                        DAT_TEXT+=('') ; line="${last//?/=}"
                        idnt=0 ; kind=2 ;;

        # capture everything else as text
        *)              idnt=0 ; kind=3
        esac

        # check -/= underlining, handle header autonumber and header TOC
        ___parse_kind() {
            local mark='-' text
            [ "$kind" = 2 ] && mark='='
            [ ${#line} = ${#last} -a -z "${line//$mark/}" ] || return 1
            if [ "${last::2}" = '. ' ] ; then
                if [ "$sect" = 0 ] ; then
                    printf -v last '%s. %s' "$page" "${last:2}"
                else
                    printf -v last '%s.%02d %s' "$page" "$sect" "${last:2}"
                fi
            fi
            DAT_TEXT[-1]="$kind$idnt${text:-$last}"
            case "$last" in
            [0-9].[0-9]*)   toc_item "$page" 2 "$last" ; ((sect += 1)) ; kind=1 ;;
            [0-9].*)        toc_item "$page" 1 "$last" ; ((sect += 1)) ;;
            [1-9][0-9].*)   toc_item "$page" 1 "$last" ; ((sect += 1)) ;;
            esac
            return 0
        }

        case "$kind" in
        0)  ;;
        1)  ___parse_kind && continue
            kind=3 ;;
        2)  ___parse_kind && continue
            kind=3 ;;
        *)
        esac
        if [ "$kind" = 3 -a "$idnt" = 0 ] && [ "$kinl" = 3 ] ; then
            last= ; DAT_TEXT[-1]+=" $line"
        else
            last="$line" ; DAT_TEXT+=("$kind$idnt$line")
        fi
        kinl="$kind"
    done
}

# ------------------------------------------------------------------------------
# prettify header lines: prettify <vnam> <text>
# ------------------------------------------------------------------------------
hdr_pretty() {
    local _text="$2"
    case "$_text" in
    [0-9][0-9].0[0-9]\ *)
        _text=("${_text::3}${_text:4:1} ${_text:5}") ;;
    [0-9].0[0-9]\ *)
        _text=("${_text::2}${_text:3:1} ${_text:4}") ;;
    esac
    printf -v "$1" "%s" "$_text"
}

#-------------------------------------------------------------------------------
# html output formatting
#-------------------------------------------------------------------------------
output_html() {
    #debug -c -- "$*"
    # <tag> <idnt> <url> <text>
    ___link() {
        xml_element "$1" -b
            [ -n "$2"  ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
            [ "$2" = 2 ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
            local _text
            xml_text -v _text -- "$4"
            _text="${_text/  /\&nbsp;\&nbsp;}"
            xml_anchor -l -u "$3" "$_text"
        xml_element "$1" -n -e
    }

    # <tag> <idnt> <mark> <text>
    ___mark() {
        local _text
        xml_text -v _text -- "$4"
        _text="${_text/  /\&nbsp;\&nbsp;}"
        [ -n "$2"  ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
        [ "$2" = 2 ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'
        xml_element "$1#$3" -- "$_text"
    }

    if [ "$1" = "$DAT_HELP" ] ; then
        :
    elif [ "$1" = "$DAT_CONTENT" ] ; then
        dat_content -
        toc_enum -
    else
        toc_enum "$1"
    fi

    local line text file mark mpre htag idnt page="${1%% *}"
    for line in "${DAT_TEXT[@]}" ; do
        text="${line:2}"
        idnt=

        # h1: page title  h2: chapter  h3: content header  h4: content item

        # 2x  -> h1     page header
        # 1x  -> h3     content header
        # 3x            text
        # 4x  -> h4     content item
        # 42. -> h2     chapter

        case "${line::3}" in
        0*)     htag='br'     ;;
        10?)    htag='h3'     ;;
        14?)    htag='h3'     ; idnt=1 ;;
        18?)    htag='p.bold' ; idnt=1 ;;
        2*)     htag='h1'     ;;
        30?)    htag='p'      ;;
        38?)    htag='pre'    ; idnt=1 ;;
        42?)    htag='h3'     ;;
        48?)    htag='h4'     ; idnt=2 ;;
        *)      htag='pre'    ; idnt=  ;;
        esac

        if [ "$htag" = 'h1' -o "$htag" = 'h2' ] ; then
            mark="${text%% *}"
            hdr_pretty text "$text"
            ___mark "$htag" "$idnt" "$mark" "$text"
            continue
        elif [ "$htag" = 'h3' ] ; then
            toc_file "$text" - file
            hdr_pretty text "$text"
            ___link "$htag" "$idnt" "$file" "$text"
            continue
        elif [ "$htag" = 'h4' ] ; then
            local mark="${text%% *}"
            hdr_pretty text "$text"
            if [ "${DAT_TOC_DICT["$mark"]}" = 2 ] ; then
                ___link "$htag" "$idnt" "$file#${mark}" "$text"
            else
                ___link "$htag" "$idnt" "#$mark" "$text"
            fi
            continue
        elif [ "$htag" = 'pre' ] ; then
            if [ -z "$mpre" ] ; then
                xml_element 'pre' -b
                mpre="x$CEN_XML_INDENT" ; CEN_XML_INDENT=
            fi
            [ -n "$idnt" ] && xml_text -l '&nbsp;&nbsp;&nbsp;&nbsp;'

            if [ -n "$text" ] && [ -n "${DAT_TOC_DICT["$text"]}"  ] ; then
                xml_anchor -m "${text%% *}" -n -- "$text"
            else
                xml_text -o -- "$text"
            fi
            continue
        elif [ -n "$mpre" ] ; then
            xml_element 'pre' -e -n ;
            CEN_XML_INDENT="${mpre:1}" ; mpre=
        fi
        [ -n "$idnt" ] && { text="    $text" ; text="${text// /\&nbsp;}" ; }
        xml_element "$htag" -n -- "$text"
    done
    [ -n "$mpre" ] && xml_element 'pre' -e -n
}

# ------------------------------------------------------------------------------
# Text output of parsed data
# ------------------------------------------------------------------------------
#   loop over DAT_TEXT (output of dat_parse())
#       use prefix bytes for output mode
#       use output()
#   padding to prevent pager from quitting
# ------------------------------------------------------------------------------
output_line() {
    output -l "$@" ; ((cout += 1))
}

output_text() {
    local line text cout=2 deco='two'

    [ "${#DAT_TEXT[@]}" = 0 ] && dat_content -      # empty array generates page 0
    for line in "${DAT_TEXT[@]}" ; do
        text="${line:2}"
        case "${line::2}" in
        14)     output_line ; output '    ' ;;
        [1-4]4) output '    ' ;;
        [1-4]8) output '        '
        esac

        case "$line" in
        #2?...)  output_line
        #        output_line -d bold -- "Content" ;;
        0*)     output_line ;;
        1?*)
        hdr_pretty text "$text"
            output_line -d bold -- "$text" ;;
        20*)    output_line -d "$deco" -x $CEN_COLS .
        hdr_pretty text "$text"
                output_line -d bold -- "$text"
                output_line -d "$deco" -x $CEN_COLS .
                #output_line ;
                deco='one' ;;
        2?*)    output_line -d ital -- "$text" ;;
        30*)    last="$text"
                while txtfold -m $((CEN_COLS - 4)) -s line last ; do
                    output_line -- "    $line"
                done ;;
        3?[0-9]*)
                output_line -- "$text" ;;
        4*)     hdr_pretty text "$text"
                output_line -- "$text" ;;
        *)      output_line -- "$text"

        esac
    done

    if [ "${DAT_TEXT[-1]::1}" != 0 ] ; then     # add empty line
        output_line
    fi
    output -l -d two -x "$CEN_COLS" .

    # padding with empty lines, pager must not quit for short file
    [ -z "$DAT_PAGER" ] && return
    while [ "$cout" -lt "$CEN_ROWS" ] ; do
        echo ; ((cout += 1))
    done
}

# ------------------------------------------------------------------------------
# The one and only action
# ------------------------------------------------------------------------------
run() {
    # display format help (console only), no return
    [ -n "$CEN_OPT_FORMAT" ] && embed -m _centauri_bash_use -h

    resolve -f -x -p -s DAT_BASE
    folder -f -c -- "$DAT_BASE"
    set -- "${1##*/}"

    # running as dynamic version
    if [ -z "$CEN_PACKAGE" ] ; then
        # update docviewer.packaged
        if [ -z "$CEN_OPT_ZOMBIE" ] && [ "$CEN_NAME.dynamic" -nt "$CEN_NAME.package" ] ; then
            embed centauribuilder --yes pack "$CEN_NAME" "$CEN_NAME.dynamic" con iom pro txt utl
            symlink -n -- "${DAT_BASE##*/}/$CEN_NAME.package" "../$CEN_NAME"
        fi
    elif [ "$CEN_OPT_BROWSE" = 1 ] ; then
        quit -e "Option '--browse=1' needs 'centauri-bash-lib' being installed"
    elif [ -n "$CEN_OPT_HTML" ] ; then
        quit -e "Option '--html=...' needs 'centauri-bash-lib' being installed"
    else
        CEN_OPT_BROWSE=0
    fi

    # imply --browse if not running as console app
    case "$CEN_OPT_BROWSE" in
    0)  ;;
    1)  [ "${CEN_DISPLAY:-tty}" = 'tty' ] && CEN_OPT_BROWSE=0 ;;
    *)  context -q && CEN_OPT_BROWSE=0 || CEN_OPT_BROWSE=1
    esac

    # just browse html, no toc updates needed
    if [ "$CEN_OPT_BROWSE" = 1 ] ; then
        toc_load || quit "No valid index, run '$CEN_NAME --html=<dest>' first"
        run_browse "$1"
        return
    fi

    # all other modes depend on a valid toc
    if [ -z "$CEN_OPT_FORCE" ] && toc_load ; then
        local file
        for file in "${DAT_TOC_LIST[@]}" ; do           # check for updates...
            toc_drop "$file" && continue
            trace -a -c "Update page" "$1"
            dat_parse "$file"
        done
        toc_save
    else
        progress "Updating toc "
        [ -z "$DAT_TOC_FILE" ] && toc_load
        matchpath -e -f -a DAT_TOC_LIST -- [1-9]\ * [1-9][0-9]\ *
        local file coun=0 totl="${#DAT_TOC_LIST[@]}"
        for file in "${DAT_TOC_LIST[@]}" ; do
            if [ "${file%% *}" = 0 ] ; then
                ((totl -= 1)) ; continue
            fi
            dat_parse "$file" || quit -e "Failed to parse input:" "$file"
            ((coun += 1))
            progress -s $coun:$totl -c .
        done
        toc_save ; progress
    fi

    if [ -n "$CEN_OPT_HTML" ] ; then
        run_html
    else
        run_menu "$1"
    fi
}

# ------------------------------------------------------------------------------
# Run a browser: [<key>]
# ------------------------------------------------------------------------------
run_browse() {
    folder -c -f -n -- "${CEN_OPT_HTML:-html}"
    local secs=("$DAT_CONTENT" "${DAT_TOC_LIST[@]}")
    local file html
    [ "${1:--}" = '-' ] || listsearch -m file -g -i secs -- "*$1*"
    toc_file "${file:-$secs}" - html
    embed -v centaurilauncher view "$PWD/$html"
}

# ------------------------------------------------------------------------------
# generate html
# ------------------------------------------------------------------------------
# The 'Table of Content' page is autogenerated from the DAT_TOC_DATA list,
# which is persistently cached in DAT_TOC_FILE. If the cache is invalid
# all pages must be regenerated.
# ------------------------------------------------------------------------------
run_html() {
    local file html
    message -a -p "Processing %s files" "${#DAT_TOC_LIST[@]}"
    folder -c -f -n -- "$CEN_OPT_HTML"

    # generate css and javascript
    run_html_css ; run_html_java
    DAT_NEXT= ; DAT_PREV= ; DAT_CURR=

    html="$DAT_HELP.html" ; html="${html// /_}"
    if [ "$DAT_BASE/$DAT_HELP" -nt "$html" -o -n "$CEN_OPT_FORCE" ] ; then
        run_html_create "$DAT_HELP" "$html"
    fi

    # page 0 is auto-generated from TOC
    local secs=("$DAT_CONTENT" "${DAT_TOC_LIST[@]}")
    for file in "${secs[@]}" '' ; do
        DAT_PREV="$DAT_CURR" ; DAT_CURR="$DAT_NEXT" ; DAT_NEXT="$file"
        [ -z "$DAT_CURR" ] && continue

        if [ "$DAT_CURR" = "$DAT_HELP" ] ; then
            html="$DAT_HELP.html" ; html="${html// /_}"
            run_html_create "$DAT_HELP" "$html"
            continue
        elif [ "$DAT_CURR" = "$DAT_CONTENT" ] ; then
            toc_file "$DAT_CURR" - html
        else
            toc_file "$DAT_BASE/$DAT_CURR" + html && continue
        fi
        run_html_create "$DAT_CURR" "$html"
    done
    message "Done."
}

# unused: internal links
#run_html_link() {
#    local -n ___link_txt="$1"
#
#    local subs="$___link_txt" xkey xtag tail html
#    while [[ "$subs" =~ (.*)\[\[([a-zA-Z]*)(#[a-zA-Z]*)?\]\](.*) ]] ; do
#        subs="${BASH_REMATCH[1]}"           # not yet parsed
#        xkey="${BASH_REMATCH[2]}"           # key
#        xtag="${BASH_REMATCH[3]:1}"         # tag
#        if listsearch -m html -g -i DAT_FLIST -- "*$xkey*" ; then
#            ___html html "$html"
#            if [ -z "$xtag" ] ; then
#                xml_anchor -u "$html" -v xkey "$xkey"
#            else
#                xml_anchor -u "$html#$xtag" -v xkey "$xtag"
#            fi
#        else
#            warning -a "Unresolved link:" "$xkey"
#            xkey="<b>[[$xkey]]</b>"
#        fi
#        tail="$xkey${BASH_REMATCH[4]}$tail" # already parsed
#    done
#    [ -z "$xkey" ] || ___link_txt="$subs$tail"
#}

# parse input and create html: <text> <html>
run_html_create() {
    local text="$DAT_BASE/$1" html="$2"
    message -a -c "Generate html" "$html"
    dat_parse "$text" || quit -e "Failed to parse input:" "$1"
    # create -t -v DAT_TEXT -- "$html.txt"

    xml_document -5 -b -c "$DAT_CSS" -s "$DAT_JAV" -i 1 -o "$html" -- "onload='initialize()'"
    xml_element 'article#top' -b -n
    run_html_navig "/var/www/html/index.html"       # upper navigator line
    output_html "$1"
    run_html_navig                                  # lower navigator line
    xml_element article -e
    xml_document -e
}

# generate link: <clas> ...
run_html_anchor() {
    local clas="$1" ; shift
    xml_element "div" -c "$clas" -b
    [ -n "$2" ] && xml_anchor "$@"
    xml_element "div" -e -n
}

# generate navigator line: <home>
run_html_navig() {
    local curr home="$1" npre nnxt cont
    [ -n "$DAT_NEXT" ] && toc_file "$DAT_NEXT" - nnxt
    [ -n "$DAT_PREV" ] && toc_file "$DAT_PREV" - npre
    xml_element 'nav' -b ; xml_element "div" -c 'nav-row' -b -n -i
        run_html_anchor 'nav-left'  -u "$npre" "[<< previous]"
        if [ -z "$home" ] ; then
            run_html_anchor 'nav-mid' -m 'top' "[Top of Page]"
        else
            run_html_anchor 'nav-mid' -u "$home#top" "[Local Web]"
        fi
        if [ "$DAT_CURR" != "$DAT_CONTENT" ] ; then
            toc_file "$DAT_CONTENT" - curr
            run_html_anchor 'nav-mid' -u "$curr#top" "[Content]"
        fi
        run_html_anchor 'nav-right' -u "$nnxt" "[next >>]"
    xml_element "div" -e -n ; xml_element 'nav' -e -n -u
}

# generate a css file
run_html_css() {
    DAT_CSS="doc.css"
    [ "$DAT_CSS" -nt "$DAT_BASE/$CEN_NAME" -a -z "$CEN_OPT_FORCE" ] && return
    message -a "Creating CSS file"
    create -c -t -- "$DAT_CSS" <<!EOF
/* autogenerated by $CEN_NAME - do not edit */

/* --- tag selectors --- */

a {
    font-family: monospace;
    text-decoration: none;
    color: brown;
}

body {
    font-family: monospace;
    font-size: 6pt;
    background-color: #eff6f8;
    margin: 0;
    margin-left: 2em;
    margin-right: 1em;
}

p {
    font-size: 10pt;
    margin: inherit;
    text-align: justify;
}

p.bold {
    font-size: 10pt;
    font-weight: bold;
    margin: inherit;
    text-align: justify;
}

pre, div {
    font-size: 10pt;
    background-color: ivory;
    margin: inherit;
}

/* --- headers h1: page title  h2: chapter  h3: content header  h4: content item --- */

h1 {
    font-size: 14pt;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

h2 {
    font-size: 12pt;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

h3 {
    font-size: 12pt;
    margin-top: 10pt;
    margin-bottom: 3pt;
}

h4 {
    font-size: 11pt;
    margin-top: 0pt;
    margin-bottom: 0pt;
}

/* ---- navigator (table layout) ---- */

nav {
    font-size: $fsml;
    display: table;
    width: 100%;
    background-color: cadetblue;
    color: white;
    font-weight: bold;
    border-style: solid;
    border-width: thin;
    border-color: black;
    box-sizing: border-box;
}

div.nav-row {
    display: table-row;
}

div.nav-left {
    display: table-cell;
    width: 30%;
    text-align: left;
}

div.nav-right {
    display: table-cell;
    width: 30%;
    text-align: right;
}

div.nav-mid {
    display: table-cell;
    width: 20%;
    text-align: center;
}

!EOF
}

# generate a script file
run_html_java() {
    DAT_JAV="doc.js"
    [ "$DAT_JAV" -nt "$DAT_BASE/$CEN_NAME" -a -z "$CEN_OPT_FORCE" ] && return
    message -a "Creating JScript file"
    create -c -t -- "$DAT_JAV" <<!EOF
/* autogenerated by $CEN_NAME - do not edit */

function initialize(dummy) {                    // called from body onload
    var obj = document.firstElementChild;
    obj.setAttribute('onkeydown', 'keydown(event)');
}

function keydown(event) {
    switch(event.key) {
        case 'Backspace':
            history.back(); break;
        case 'q':
        case 'Escape':
            console.log("QUIT"); break;         // handled in qml code
        case 'c':
            window.location='${DAT_CONTENT// /_}.html'; break;
        case 'h':
            window.location='${DAT_HELP// /_}.html'; break;
        case 'n':
        case 'ArrowRight':
            navigate('right'); break;
        case 'p':
        case 'ArrowLeft':
            navigate('left'); break;
        case 't':
            window.location='#top'; break;
        case 'w':
            window.location='http://localhost'; break;
        default:
            console.log("Key: ", event.key)
    }
}

function navigate(dest) {
    var elts = document.getElementsByClassName('nav-' + dest);
    if (elts.length < 1) return;
    var child=elts[0].firstChild; if (child == null) return;
    dest=child.getAttribute('href'); if (dest != null) window.location=dest;
}
!EOF
}

# ------------------------------------------------------------------------------
# text menu mode
# ------------------------------------------------------------------------------
#   get file list
#       show menu
#       selection of a file
#           dat_parse()
#           output_text()
# ------------------------------------------------------------------------------
run_find() {
    local indx=0 offs=0 list item
    while : ; do
        list=("${DAT_TOC_DATA[@]:offs}")
        [ -z "$list" ] && break
        listsearch -n indx -g -i list -- "$1" || break
        ((offs += indx))
        [ -z "$item" ] && message -m "Found in section content:" ''
        item="${DAT_TOC_DATA[offs]#? ? }"
        message -a "$item"
        ((offs+=1))
    done
    [ -n "$item" ] && message -i
}
run_menu() {
    local skey cpag page="${1%% *}"
    if [ -n "$CEN_OPT_DUMB" ] ; then
        console -m 0 ; DAT_PAGER=
    elif ! console -c 0 -r 0 ; then
        DAT_PAGER=
    fi
    : ${CEN_COLS:=90} ; [ "$CEN_COLS" -gt 96 ] && CEN_COLS=96

    if [ -z "$DAT_PAGER" ] ; then
        cpag='message -i'
    else
        system -c clear && cpag='clear'
    fi

    # page 0 is auto-generated from TOC
    local secs=("$DAT_CONTENT" "$DAT_HELP" "${DAT_TOC_LIST[@]}")

    # display a single page
    if [ -n "$1" ] ; then
        if listsearch -m DAT_FILE -g -i secs -- "*$1*" ; then
            :
        elif run_find "*$1*" ; then
            quit
        else
            quit "No matching topic:" "$1"
        fi
        dat_parse "$DAT_FILE" || quit -e "Failed to parse input:" "$DAT_FILE"
        $cpag
        $DAT_PAGER output_text
        return
    fi

    # enter menu mode loop
    CEN_HISTORY='-'
    while : ; do
        $cpag
        output -l -d two -x $CEN_COLS .
        output -l -d bold -- "Documentation Viewer: List of Documentation Sections"
        output -l -d two -x $CEN_COLS .
        output -l

        for skey in "${secs[@]}" ; do
            [ "$skey" = "$DAT_HELP" ] && continue
            output -l "        ${skey/ /. }"
        done
        output -l
        output -l "        Type 'help' to get information about viewing the documentation as HTML"
        output -l "             'quit' to close the documentation viewer."
        output -l ; output -l -d 'two' -x $CEN_COLS . ; output -l

        confirm -p - -s skey "Please select a section number or a keyword"
        case "$skey" in
        ''|q*)  $cpag ; return ;;
        h)      skey="$DAT_HELP" ;;
        [0-9])  skey+=' ?' ;;
        esac

        if listsearch -m DAT_FILE -g -i secs -- "*$skey*" ; then
            dat_parse "$DAT_FILE" || quit -e "Failed to parse input:" "$DAT_FILE"
            $cpag
            $DAT_PAGER output_text
        else
            message -a -d error "No matching topic:" "$skey" ; sleep 2
        fi
    done
}

# ------------------------------------------------------------------------------
# remove a page from TOC list: <file>
# ------------------------------------------------------------------------------
toc_drop() {
    local page="${1%% *}"
    trace -a -c "cache page" "$1"
[ "$page" = "$1" ] && fatal -t xxx
    if [ "${DAT_TOC_UPDT:-1}" = 1 ] ; then
        [ "$DAT_TOC_FILE" -nt "$1" ] && return 0    # toc for file is current
    elif [ "$DAT_TOC_UPDT" = 2 ] ; then
        DAT_TOC_DATA+=("$page 0") ; return 1
    fi

    local item list=("${DAT_TOC_DATA[@]}") ; DAT_TOC_DATA=()
    for item in "${list[@]}" ; do
        [ "${item%% *}" = "$page" ] || DAT_TOC_DATA+=("$item")
    done
    DAT_TOC_DATA+=("$page 0")
    [ -z "$DAT_TOC_UPDT" ] && DAT_TOC_UPDT=1
    return 1
}

# ------------------------------------------------------------------------------
# make html name, check if file was updated: <file> <fref>|-|+ [<vnam>]
#
#   toc_file    <file> <fref>       # check if <fref> is newer then <file>
#   toc_file    <file> + <vname>    # check if html file is newer then <file>
#   toc_file    <file> - <vname>    # only generate html file name from <file>
# ------------------------------------------------------------------------------
toc_file() {
    local _file="$1" _fref="${2:--}" _vnam="$3"
    if [ "$_fref" = '-' -o "$_fref" = '+' ] ; then
        _fref="${_file##*/}"
        _fref="${_fref//[ .,:]/_}"
        _fref="${_fref//__/_}.html"
        [ -n "$_vnam" ] && printf -v "$_vnam" '%s' "$_fref"
        [ "${2:--}" = '-' ] && return 0             # no time check
    fi

    [ -n "$CEN_OPT_FORCE" ] && return 1             # option --force
    [ "$_fref" -nt "$_file" ]                       # return status
}

# ------------------------------------------------------------------------------
# enumerate items of a TOC page: <page> [<call>]
# ------------------------------------------------------------------------------
toc_enum() {
    [ -z "$2" ] && DAT_TOC_DICT=()
    local item valu
    for item in "${DAT_TOC_DATA[@]}" ; do
        [ "$1" != '-' ] && [ "${item%% *}" != "$1" ] && continue
        valu="${item#* }"                           # remove <page>
        if [ -z "$2" ] ; then
            item="${valu#* }"
            DAT_TOC_DICT["${item%% *}"]="${valu%% *}"
        else
            isfunction -c -e -- "$2" "${item%% *}" "${valu%% *}" "${valu#* }"
        fi
    done
}

# ------------------------------------------------------------------------------
# add an item to TOC list: <page> <kind> <item>
# ------------------------------------------------------------------------------
toc_item() {
    [ -z "$DAT_TOC_UPDT" ] && return
    DAT_TOC_DATA+=("$1 $2 $3")
    DAT_TOC_UPDT=1
}

# ------------------------------------------------------------------------------
# load TOC list from cache: -no arg-
# ------------------------------------------------------------------------------
toc_load() {
    local file self vers="$DAT_TOC_VERS"
    folder -s file -g -b 'persistent' "soho_$CEN_NAME"
    resolve -f -x -p -s self -- "$BASH_SOURCE"

    DAT_TOC_FILE="$file" ; DAT_TOC_DATA=() ; DAT_TOC_UPDT=

    if [ "$self" -nt "$file" ] ; then
        trace -a -c "content cache" "Script has been updated"
    elif ! serialize -n "$file" -q -r -- DAT_TOC_VERS DAT_TOC_LIST DAT_TOC_DATA ; then
        trace -a -c "content cache" "No valid data"
    elif [ "$vers" != "$DAT_TOC_VERS" ] ; then
        trace -a -c "content cache" "Version mismatch"
    else
        return 0
    fi

    DAT_TOC_VERS="$vers" ; DAT_TOC_DATA=() ; DAT_TOC_UPDT=2
    return 1
}

# ------------------------------------------------------------------------------
# save TOC list to cache: -no arg-
# ------------------------------------------------------------------------------
toc_save() {
    [ -z "$CEN_OPT_FORCE" -a -z "$DAT_TOC_UPDT" ] && return 0
    [ "$DAT_TOC_UPDT" = 1 ] && txtsort -i DAT_TOC_DATA -a DAT_TOC_DATA
    DAT_TOC_UPDT=
    serialize -m 664 -n "$DAT_TOC_FILE" -w -- DAT_TOC_VERS DAT_TOC_LIST DAT_TOC_DATA
}

# ------------------------------------------------------------------------------
# option parsing: <option> <argument>
# ------------------------------------------------------------------------------
options() {

    case "$1" in
    '') DAT_PAGER="$CEN_PAGER" ; CEN_PAGER= ;;

    -B|--bro*)
        optarg 'browse' -              -o  ;;   # ternary flag
    -D|--dum|--dumb)
        optarg 'dumb'   -                  ;;   # simple flag
    -F|--for*)
        CEN_OPT_PAGER=                          # enable centaurihelp
        optarg 'format' -                  ;;   # simple flag
    -H|--htm|--html)
        [ "$2" = '-' ] && CEN_ARGOPT[0]="$CEN_ROOT/html"
        optarg 'html'   -              -t  ;;   # folder

    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    [ -n "$CEN_OPT_FORMAT" ] && usage_format || usage_help
}

usage_format() {
    usagecat << !EOF
Format: The README documentation files use an intentionally simple format. The main
    purpose of this format is to allow the automated creation of linked HTML pages.

Parser: Documentation files are processed in two steps: (1) parser (2) output text/html.
    The parser creates an array of text lines with a two digit code-prefix. Comment
    lines (starting with '#') are ignored, multiple empty lines are stored as single
    empty line. The 1st code digit is the line-kind, the 2nd digit can be 0, 4 or 8
    depending on the number of leading spaces (which are removed). Examples:

Examples: input                                  output
    ─────────────────────────────────────  ─────────────────────────────────────
    # comments are ignored
    °                                      00
    chapter header
    ==============                         20Chapter Header
    header
    ------                                 10Header
    text block,
    can span multiple lines                30text block, can span multiple lines
    °                                      00
    °   literal text                       34literal text
    °       literal indented               38literal indented
    °   literal bold text
    °   -----------------                  14literal bold text
    ─────────────────────────────────────  ─────────────────────────────────────

Commands:   Input lines can be dot commands ...
    .title              # generates a page title from the file name
    .content            # generates a 'Table Of Content' from a dictionary

Output: In the output step the parser result is formatted either as text or html. Hyper-
    links are generated using a dictionary for code 10 (destination) and code 34, 38
    (link). Only lines starting with a digit are added to the dictionary.
!EOF
    return 0
}

usage_help() {
    usagecat << !EOF
$CEN_USE_HEADER

       This tool can

           (1) display a menu and documentation content in text mode
           (2) create HTML files from documentation text
           (3) browse HTML documentation (needs a GUI obviously)

$CEN_USE_OPTIONS

       -B --browse  <mode>  [*] browse HTML formatted text (default: --browse=2)
       -D --dumb            no ANSII escapes, no pager
       -F --format          show help about the doc source text format
       -H --html    <html>  [*] HTML folder

       [*] centauri-bash-lib must be installed to use these options

arguments:
       <html>               an existing folder for html output
       <mode>               0|off:=text mode  1|on:=html mode  2|auto:=auto

examples:
       # text menu and documentation content
       $CEN_NAME           # show menu
       $CEN_NAME   netw    # show text file that matches 'netw'

       # creating HTML documentation
       $CEN_NAME --html=-  # create in $CEN_ROOT/html
       $CEN_NAME --html=/tmp/test
                           # create HTML in /tmp/test

       # brose HTML documentation
       $CEN_NAME --browse  # start with /var/www/html/index.html
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------

# ======= execute the script, this replaces the original 'main ... quit' =======
_cen_bash_main() {
    main "$@" ; quit
}

# ============== the packed code of library modules follows below ==============

_cen_bash_load_lib(){
declare -g -A CEN_MODULES['_centauri_bash_lib']='1.30:3:1'
CEN_ACTARR=
CEN_ACTION=
CEN_ARGOPT=
CEN_ARGS=
CEN_AUTOIND=
CEN_CMDARGS=
CEN_CMDCURR=0
CEN_CMDINDX=0
CEN_CMDOPTS=
CEN_CONFIRM=
CEN_DEFAULTS=
CEN_DISPLAY=
CEN_DEBUG=:
CEN_DONE=1
CEN_EMBED=
CEN_EXIT=0
CEN_FOLDER=
CEN_HISTORY=
CEN_NOTRACE=:
CEN_PAGER=
CEN_QUIT_SANE=
CEN_QUIT_TRAP=49
CEN_QUIT_WSUB=
CEN_QUIT_WAIT=
CEN_RUNDRY=1
CEN_STAGE='loading'
CEN_STDERR=
CEN_STDOUT=
CEN_TRACE=:
CEN_TRACE2=:
CEN_TRAPLVL=
CEN_TRAPSIG=
CEN_VERB=1
CEN_YESNO=
CEN_OPT_DRYRUN=
CEN_OPT_FORCE=
CEN_OPT_GUI=
CEN_OPT_INCLEXCL=()
CEN_OPT_PAGER=
CEN_OPT_SILENT=
CEN_OPT_TRACE=
CEN_OPT_ZOMBIE=
CEN_RUN_MIN_ARGS=
CEN_RUN_MAX_ARGS=
declare -g -A CEN_COMMANDS
CEN_FEATURE_A=
CEN_FEATURE_D=
CEN_FEATURE_E=
CEN_FEATURE_F=
CEN_FEATURE_G=
CEN_FEATURE_I=
CEN_FEATURE_O=
CEN_FEATURE_R=
CEN_FEATURE_S=
CEN_FEATURE_T=
CEN_FEATURE_V=
CEN_FEATURE_W=
CEN_FEATURE_Y=
CEN_HOOK_ACTIONS='actions'
CEN_HOOK_OPTIONS='options'
CEN_HOOK_GETLINE='_cen_getline'
CEN_HOOK_MAIN=:
CEN_HOOK_MESSAGE='_cen_message'
CEN_HOOK_QUIT='_cen_quit'
while [ "${1::1}" = - ];do
case "$1" in
-) break;;
--) shift;break;;
-a) CEN_FEATURE_A=1;;
-d) CEN_FEATURE_D=1;CEN_RUNDRY=;;
-e) CEN_FEATURE_E=1;;
-f) CEN_FEATURE_F=1;;
-g) CEN_FEATURE_G=1;;
-i) CEN_FEATURE_I=1;;
-m) shift;CEN_MODULES["_centauri_bash_$1"]=;;
-o) CEN_FEATURE_O=1;;
-r) CEN_FEATURE_R=1;CEN_RUN_MIN_ARGS=+;;
-s) CEN_FEATURE_S=1;;
-t) CEN_FEATURE_T=1;;
-v) CEN_FEATURE_V=1;CEN_MODULES['_centauri_bash_svc']=;CEN_RUN_MIN_ARGS=1;;
-w) CEN_FEATURE_W=1;;
-y) CEN_FEATURE_Y=1;;
*);;
esac;shift
done
[ "${1:--}" = - ]&&CEN_NAME="${BASH_SOURCE[2]:-$BASH_SOURCE}"||CEN_NAME="$1"
CEN_NAME="${CEN_NAME##*/}"
if [ -n "$CEN_FEATURE_T" -a -z "$TEXTDOMAIN" ];then
TEXTDOMAIN='_centauri_bash_lib';TEXTDOMAINDIR="$CEN_ROOT/locale"
fi
CEN_SHORTFMT=$" %-16s:"
CEN_VERSION=("$2")
[ -n "$3" ]&&CEN_RUN_MIN_ARGS="$3"
[ -n "$4" ]&&CEN_RUN_MAX_ARGS="$4"
[ -z "$CEN_NOBREAK" -a "${COLUMNS:-0}" -lt 40 ]&&CEN_NOBREAK=1
CEN_DISPLAY="$XDG_SESSION_TYPE"
if [ -z "$DISPLAY" ];then
[ "$CEN_DISPLAY" != 'wayland' ]&&CEN_DISPLAY=
else
[ "${CEN_DISPLAY:-tty}" = 'tty' ]&&CEN_DISPLAY='x11'
fi
trace() { $CEN_NOTRACE return 0;[ "$CEN_VERB" -lt 2 ]&&return 0
$CEN_HOOK_MESSAGE -t "$@";}
message() { $CEN_NOTRACE return 0;$CEN_HOOK_MESSAGE "$@"||:;}
warning() { $CEN_NOTRACE return 0;$CEN_HOOK_MESSAGE -w "$@"||:;}
error() {
local _zero _isok _fopt _fqui _popt=()
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-a|-i|-n|-m|-p|-r)
_popt+=("$1");;
-c) CEN_EXIT=0;[ "$CEN_DONE" = 2 ]&&CEN_DONE=1;return 0;;
-f) _fopt=1;;
-s) CEN_EXIT="$2";_isok=1;shift;;
-t) [ "$CEN_DONE" != 2 ];return;;
-q) [ "$CEN_DONE" != 2 ]&&return;_fqui=1;;
-x) CEN_DONE=0;return $CEN_EXIT;;
-z) _zero=0;;
*) _cen_abort - "$1"
esac;shift
done
[ -n "$_fopt" ]&&fatal ${_popt[@]} -- "$@"
[ -n "$_fqui" ]&&quit ${_popt[@]} ${1:+-e} -- "$@"
[ -n "$CEN_NOTRACE" ]&&[ -z "$_isok" -a -n "$*" ]&&message -e ${_popt[@]} -- "$@"
[ "$CEN_DONE" = 1 ]&&CEN_DONE=2
[ "${CEN_EXIT:-0}" -le 1 ]&&CEN_EXIT=2
return ${_zero:-$CEN_EXIT}
}
fatal() {
[ "$1" = '-t' ]&&{ shift;_cen_abort -2 "$@";}
if [ "$CEN_VERB" -gt 2 ];then
local _text _ffmt
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-p) _ffmt=1;;
esac;shift
done
[ -z "$_ffmt" ]&&_text="$*"||printf -v _text "$@"
_cen_abort -2 $"fatal:" "$_text"
fi
CEN_AUTOIND=
[ -n "$CEN_NOTRACE" ]&&message -f -r "$@"
CEN_EXIT=3;CEN_ACTION=;quit
}
quit() {
[ -n "$CEN_IS_SOURCED" -a -z "$CEN_STAGE" ]&&return 0
exec 1>&$CEN_STDOUT 2>&$CEN_STDERR
local _flgt _opts=()
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-e) _opts+=("$1");[ "$CEN_EXIT" = 0 ]&&CEN_EXIT=1
_flgt=$"Terminated after error";;
-h) $CEN_HOOK_QUIT -h;CEN_HOOK_QUIT=_cen_quit;return 0;;
-n|-m|-p|-r)
_opts+=("$1");;
-s) CEN_EXIT="${2:-0}";shift;;
-t) CEN_EXIT=4;_flgt=$"Terminated";;
-u) CEN_EXIT=4;_flgt=$"Terminated by user";;
-y) CEN_QUIT_SANE=1;;
-) break;;
*) _opts+=("$1")
esac;shift
done
if [ "$$" != "$BASHPID" ];then
_cen_abort -n -2 $"quit from subshell" "PID=$BASHPID"
elif [ -n "$_flgt" ];then
[ "${1:--}" = - ]&&set -- "$_flgt""${2:+:}" "${@:2}"
fi||:
$CEN_HOOK_QUIT "${_opts[@]}" ${1:+--} "$@";exit 2
}
_cen_quit() {
$CEN_NOTRACE set +x
local _modu
for _modu in "${!CEN_MODULES[@]}";do
case "${_modu#_centauri_bash_}" in
lib|dyn) continue;;
con|win) continue;;
pro|ext) continue;;
*_usr) _modu="${_modu%_usr}";;
*) _modu="_cen${_modu#_centauri_bash}"
esac
isfunction -c "${_modu}_quit"
done||:
$CEN_NOTRACE set -x
if [ -n "$CEN_QUIT_WSUB" ];then
$CEN_TRACE -a -c ' ' $"Waiting for children"
wait
fi
CEN_HOOK_QUIT=_cen_exit
if [ $# = 1 -a "$1" = '-h' ];then
_cen_exit -
else
[ "$#" -gt 0 ]&&message "$@";_cen_exit
fi||:
}
_cen_exit() {
$CEN_NOTRACE set +x
[ "${1:--}" != - ]&&CEN_EXIT="$1"
isfunction -c '_cen_pro_quit'||:
isfunction -c '_cen_ext_quit'||:
[ "$1" = - ]&&return 0
$CEN_TRACE2 -r -c $"Exit status" -- "${CEN_EXIT:-0}"
[ -n "$CEN_QUIT_SANE" ]&&system -r -q -- stty sane
if [ "$CEN_QUIT_WAIT" = 3 ];then
system -b -r sleep 2
elif [ "$CEN_QUIT_WAIT" = 2 ];then
trap "exit ${CEN_EXIT:-0}" 1 2 3 15
read -n1 -p $"Press any key to close the window..." 1>&2
elif [ -n "$CEN_QUIT_WAIT" ];then
trap "exit ${CEN_EXIT:-0}" 1 2 3 15
read -n1 -p $"Press any key to continue..." 1>&2
echo 1>&2
fi
exit "${CEN_EXIT:-0}"
}
_cen_trap() {
trap - 1 2 3 15;CEN_TRAPLVL=
$CEN_TRACE2 'Got trap:' "${FUNCNAME[1]}" "$1"
CEN_TRAPSIG="${1:--}"
[ -n "$CEN_CONS_MSGLEN" ]&&((CEN_CONS_MSGLEN += 2))
[ -n "$CEN_QUIT_WAIT" ]&&CEN_QUIT_WAIT=3
if [ "$1" = 2 ];then
echo >&2;quit -u
fi
quit -t - $"caught signal" "$1"
}
_cen_abort() {
set +xeE;IFS=$' \n\t';exec 1>&$CEN_STDOUT 2>&$CEN_STDERR
local _fnot _indx=1 _idnt='| ' _mesg _temp
while [ "${1::1}" = - -o "${#1}" = 1 ];do
case "$1" in
--) shift;break;;
@) shift;_mesg=$"Too many arguments";break;;
+) shift;_mesg=$"Missing argument";break;;
=) shift;_mesg=$"Missing option";break;;
?) shift;_mesg=$"Invalid argument";break;;
-n) [ "$CEN_VERB" -le 2 ]&&_fnot=1;;
-[0-9]) _indx=${1:1};
esac;shift
done
if [ -z "$_mesg" ];then
_mesg="$*"
elif [ $# -gt 0 ];then
_mesg+=" '$*'"
fi
CEN_AUTOIND=
if [ -n "$_fnot" ];then
_idnt="${BASH_SOURCE[_indx]##*/}.${FUNCNAME[_indx]}"
case "${_idnt##_centauri_bash_lib*.}" in
invoke|options)
printf -v _mesg $"%s: %s() returned non-zero status" "$_mesg" "$CEN_ACTION";;
*)
printf -v _mesg $"%s: Line #%s in %s()" "$_mesg" "${BASH_LINENO[_indx-1]}" "$_idnt"
esac
_cen_message -l -r $"***ABORT***" "$_mesg";_cen_exit 4
fi
_mesg+='. '$"Function call stack..."$'\n'
while [ -n "${FUNCNAME[_indx]}" ];do
_mesg+="$_idnt${BASH_SOURCE[_indx]}.${FUNCNAME[_indx]}() ${BASH_LINENO[_indx-1]}"$'\n'
((_indx += 1));_idnt+='   '
done
_temp="$CEN_NAME ${CEN_CMDOPTS[*]} ${CEN_CMDARGS[*]}";_temp="${_temp% }"
_cen_compactify _temp;_mesg+="$_temp"
_cen_message -l -n -r $"***ABORT***" "$_mesg";_cen_exit 4
}
_cen_message() {
local _scal _sfmt _smul _serr _sind _snam="${CEN_EMBED:-$CEN_NAME}:" _verb="$CEN_VERB" _stat=0
local _bopt _deco _norm _oesc
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _sind="$CEN_AUTOIND";;
-b) shift;_bopt="${1%%,*}"
[ "$CEN_NOBREAK" = 1 ]&&_bopt=;;
-c) _scal=1;;
-d) shift;;
-e) _verb=1;_stat="$CEN_EXIT";_deco="$CEN_DECO_EROR";_serr=$" ***ERROR***";;
-f) _verb=1;_stat="$CEN_EXIT";_deco="$CEN_DECO_EROR";_serr=$" ***FATAL ERROR***";;
-i) _sind=1;;
-l) _verb=1;;
-m) _smul=1;_sfmt=2;;
-n) _smul=1;;
-p) _sfmt=1;;
-r) [ -n "$CEN_EMBED" ]&&_snam="$CEN_EMBED[$CEN_NAME]:";;
-s) _oesc='-en';;
-t) _deco="$CEN_DECO_TRCE";;
-w) _deco="$CEN_DECO_WARN";_serr=$" ***WARNING***";;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$CEN_CONS_MSGLEN" ];then
echo 1>&2;CEN_CONS_MSGLEN=
fi
[ "$_verb" -gt 0 ]||return $_stat
[ "$CEN_AUTOIND" = 2 ]&&_sind=1;CEN_AUTOIND=1
[ -n "$_sind" ]&&_snam="${_snam//?/ }"
if [ -n "$_scal" ];then  # option '-c'
_cen_shortfmt _scal - "$1";_serr+="$_scal";shift
[ "$1" = '--' ]&&shift
fi
[ -n "$_deco" ]&&_norm="$CEN_DECO_NORM"
if [ -n "$_bopt" ];then
_sfmt="$_snam$_serr $*"
echo "$_deco${_sfmt::$COLUMNS}$_norm";_sfmt="${_sfmt:$COLUMNS}"
while [ -n "$_sfmt" ];do
printf -v _sfmt "${_snam//?/ }%${_bopt}s %s" '' "$_sfmt"
echo "$_deco${_sfmt::$COLUMNS}$_norm";_sfmt="${_sfmt:$COLUMNS}"
done
elif [ -z "$_smul$_sfmt" ];then
echo $_oesc "$_deco$_snam$_serr" "$@""$_norm"
else
if [ "$_sfmt" != 2 ];then
if [ -n "$_sfmt" ];then
if [ "$_sfmt" = 1 ];then
_sfmt="$1";shift
else
_sfmt='%s\n'
fi
printf -v _sfmt -- "$_sfmt" "$@"
else
_sfmt="$*" ; _sfmt="${_sfmt// \\n /$'\n'}" ; _sfmt="${_sfmt//\\n/$'\n'}"
fi
local _sifs="${IFS:-$' \t\n'}" ; IFS=$'\n'
set -f;set -- $_sfmt;set +f;IFS="$_sifs"
fi
while [ "$#" != 0 ];do
echo "$_deco$_snam$_serr" "$1$_norm"
shift;_snam="${_snam//?/ }";_serr=
done
fi 1>&2
return $_stat
}
_cen_shortfmt() {
local _temp="$2" _asci _ugly
[ "$3" = - ]&&set -- "$1" "$2" ' '
[ "${3::1}" = ' ' ]||_temp=
[ "${3::2}" = '()' ]&&_temp=-
[ "$_temp" = - ] &&
for _temp in "${FUNCNAME[@]}";do
case "$_temp" in
_cen_*) continue;;
___cen_*) continue;;
trace|isfunction|message|warning|error)
continue;;
*) break
esac
done
_temp+="$3"
if [ -z "${_temp//[[:ascii:]]/}" ];then
printf -v "$1" "$CEN_SHORTFMT" "$_temp"
else
_asci="${_temp//[[:alpha:]]/.}"
printf -v _ugly "$CEN_SHORTFMT" "$_asci"
printf -v "$1" '%s' "${_ugly/$_asci/$_temp}"
fi
}
apicheck() {
local _fchk _fmod _vnam _scal="$CEN_NAME"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) _fchk=:;;
-e) _fchk=error;;
-f) _fchk=fatal;;
-m) _fmod=1;;
-v) shift;_vnam="$1";local -n _vvar="$_vnam";;
*) _cen_abort - "$1"
esac;shift
done
local _vers="$1" _varr
if [ -z "${CEN_VERSION[1]}" ];then
local _varg="${CEN_MODULES["_centauri_bash_lib"]}"
_varg="${_varg//[^.:0-9]/}";_varr=( ${_varg//:/ } )
CEN_VERSION=("$CEN_VERSION" "${_varr[@]}");_varr=()
fi
if [ -n "$_fmod" ];then
_scal="$_vers" ; _vers="${CEN_MODULES["$_vers"]}"
elif [ -z "$_vers" ];then
_vers="${CEN_MODULES["_centauri_bash_lib"]}"
fi
_vers="${_vers//[^.:0-9]/}";_varr=( ${_vers//:/ } )
[ -n "$_vnam" ]&&_vvar=("${_varr[@]}")
[ -z "$_fchk" ]&&return 0
[ -z "${_varr[1]}" ]&&return 0
if [ "${_varr[1]}" \> "${CEN_VERSION[2]}" ];then
local _swho=$"Script";[ -n "$_fmod" ]&&_swho=$"Module"
$_fchk -p $"%s '%s' API version to high (got %s max %s)" \
                  "$_swho" "$_scal" "${_varr[1]}" "${CEN_VERSION[2]}" ; return 1
elif [ "${_varr[1]}" \< "${CEN_VERSION[3]}" ];then
local _swho=$"Script";[ -n "$_fmod" ]&&_swho=$"Module"
$_fchk -p $"%s '%s' API version to low (got %s min %s)" \
                  "$_swho" "$_scal" "${_varr[1]}" "${CEN_VERSION[3]}" ; return 1
fi
return 0
}
arguments() {
local _acnt _vsav
if [ "$1" = '-I' ];then
_vsav="$2";_acnt="$3";shift 3
else
_acnt=$(($# - 2));CEN_ARGS="$_acnt"
[ "$CEN_DONE" = 2 -a -z "$CEN_OPT_ZOMBIE" ]&&return 1
fi
local _amin="${1:--}" _amax="${2:--}" _aarg _mesg
_aarg="$_amin$_amax"
[ "$_aarg" = '--' -o "$_aarg" = '-+' ]&&return 0
[ "$_amin" = - ]&&_amin=0
if [ "$_amax" = - ];then
[ "$_acnt" = "$_amin" ]&&return 0
_mesg=$"takes $_amin arguments, got $_acnt"
[ "$_amin" = 0 ]&&_mesg=$"no arguments permitted, got $_acnt"
[ "$_amin" = 1 ]&&_mesg=$"takes one argument, got $_acnt"
elif [ "$_acnt" -lt "$_amin" ];then
_mesg=$"not enough arguments, (minimum $_amin) got $_acnt"
[ "$_aarg" = '1-' -o "$_aarg" = '11' ] &&
_mesg=$"takes one argument, got none"
elif [ "$_amax" = + ];then
return 0
elif [ "$_acnt" -gt "$_amax" ];then
_mesg=$"too many arguments, (maximum $_amax) got $_acnt"
else
return 0
fi
if [ -n "$_vsav" ];then
local -n _vref="$_vsav";_vref="$_mesg"
return 1
fi
[ -z "$CEN_FEATURE_R" ] && _mesg=$"Action"" '$CEN_ACTION': $_mesg"
error -r -z "${_mesg^}";return 1
}
confirm() {
local _imod=0 _ifmt _ipro _idef _iqui _ival=$"yes no"
local _sind=2 _snam _smul _uppc _yeno _cncl _dflt _prom _vala _vali _warn _fset='CEN_CONFIRM'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _sind=1;[ -z "$CEN_AUTOIND" ]&&_sind=2;;
-b) [ -n "$CEN_YESNO" ]&&return 1;;
-d) shift;_dflt="$1";;
-f) _ifmt=1;;
-i) _sind=1;;
-l) _sind=;;
-m) _smul=1;;
-p) shift;_prom="$1";;
-s) shift;_fset="$1";;
-u) _uppc=1;;
-v) shift;_vali="$1";;
-w) _warn=w;;
-c) ((_imod |=4));shift;_cncl="$1";;
-n) ((_imod |=2));;
-q) ((_imod |=4));_cncl='quit -t';;
-y) ((_imod |=1));;
*) _cen_abort - "$1"
esac;shift
done
local -n _varg="$_fset";_varg=
[ "$_vali$_dflt$_prom$_imod" = 0 ]&&_imod=2
if [ "$_imod" != 0 ];then
if [ -n "$CEN_YESNO" ];then
if [ "$CEN_YESNO" = y ];then
_varg="${_ival%% *}"
$CEN_TRACE -a -c " $_varg" "$@";return 0
else
_varg="${_ival#* }"
$CEN_TRACE -a -c " $_varg" "$@";return 1
fi
fi
_yeno=2;_idef=0
case "$_imod" in
1) _ipro=$" [Y/n]? ";_yeno=1;;# -y => -d y
2) _ipro=$" [y/N]? ";_idef=1;;# -n => -d n
3) _ipro=$" [y/N]? ";_idef=1;;# compatibility: -n -y => -d n
4) _ipro=$" [y/n/C]? "
_iqui=$" [y/n/Q]? ";_idef=2;;# -q => -d c
6) _ipro=$" [y/N/c]? "
_iqui=$" [y/N/q]? ";_idef=1;;# -n -q => -d n
*) _ipro=$" [Y/n/c]? "
_iqui=$" [Y/n/q]? " ;;# -y -q => -d y
esac
if [ "$_imod" -lt 4 ];then
:
elif [ "${_cncl%% *}" = 'quit' ];then
_ival=$"yes no quit";_yeno=3;_ipro="$_iqui"
elif [ -n "$_cncl" ];then
_ival=$"yes no cancel";_yeno=3
fi
[ -z "$_prom" ]&&_prom="$_ipro"
[ -z "$_vali" ]&&_vali="$_ival"
fi
set -f;_vala=($_vali);set +f
if [ -n "$_idef" -a -z "$_dflt" ];then
[ "$_idef" -ge ${#_vala[@]} ]&&_dflt="$_vala"||_dflt="${_vala[_idef]}"
fi
if [ -z "$_smul" ];then
local _mesg
[ -z "$_ifmt" ]&&_mesg="$*"||printf -v _mesg "$@"
local _sifs="${IFS:-$' \t\n'}" ; IFS=$'\n'
if [ -n "$_smul" ];then
_mesg="${_mesg//\\n/$'\n'}"
_mesg="${_mesg//\\t/$'\t'}"
fi
set -f;set -- $_mesg;set +f;IFS="$_sifs"
fi
CEN_AUTOIND=1
if [ -n "$CEN_HISTORY" -a "$CEN_HISTORY" != + ];then
if [ "$CEN_HISTORY" = - ];then
history -c;splitjoin -x 'history -s' -d ' ' -i _vali
elif [ -r "$CEN_HISTORY" -a -f "$CEN_HISTORY" ];then
$CEN_TRACE 'Reading history:' "$CEN_HISTORY"
history -r "$CEN_HISTORY"
CEN_HISTORY=+
else
$CEN_TRACE 'Bad history file:' "$CEN_HISTORY"
CEN_HISTORY=+
fi
fi
while :;do
if [ -n "$_sind" ];then
_snam="${CEN_EMBED:-$CEN_NAME}: "
[ "$_sind" = 1 ]&&_snam="${_snam//?/ }"
fi
_varg="$_dflt"
if ! $CEN_HOOK_GETLINE "$_fset" "$_warn$_yeno" "$_vali" "$_prom" "$_snam" "$@";then
[ -z "$_varg" ]&&_varg="$_dflt"
[ "${_cncl:--}" != - ]&&eval "$_cncl"
return 2
fi
[ -z "$_varg" ]&&_varg="$_dflt"
[ -z "$_uppc" ]&&_varg="${_varg,,}"
if [ -z "$_vali" ];then
[ -n "$_varg" ]&&return 0;return 1
fi
local _rchk _rval=0 _slen="${#_varg}" _nval=$((${#_vala[@]} - 1))
for _rchk in "${_vala[@]}";do
if [ "${_varg}" = "${_rchk::$_slen}" ];then
_varg="$_rchk"
[ "$_rval" = "$_nval" ]&&[ "${_cncl:--}" != - ]&&eval "$_cncl"
return $_rval
fi
((_rval += 1))
done
message -a $"***INVALID INPUT***" $"Please try one of:" "$_vali"
done
}
_cen_getline() {
[ -n "$CEN_CONS_MSGLEN" ]&&progress
[ /dev/fd/0 -ef /dev/null ]&&return 1
local _ssil _vnam="$1" _warn="${2::1}" _prom="$4" _snam="$5";shift 5
[ "$_prom" = + ]&&_ssil='-s'
[ "$_prom" = - -o "$_prom" = + ]&&_prom=': '
local _text="$1";shift
[ "$_warn" = w ]&&_warn=$" ***WARNING***"' '
while [ "$#" -gt 0 ];do
if [ -n "$_text" ];then
[ -n "$_smul" ]&&_text="${_text//\\t/    }"
printf '%s\n' "$_snam$_text" 1>&2;_snam="${_snam//?/ }"
fi
_text="$1";shift
done
[ -n "$_smul" ]&&_text="${_text//\\t/    }"
_text="$_snam${_warn:1}$_text$_prom";CEN_CONS_MSGLEN="${#_text}"
context -t +;CEN_QUIT_SANE="$_ssil"
if [ ! -t 0 ]&&[ ! -t 2 ];then
echo -n "$_text" 1>&2;_text=
fi
read $_ssil ${CEN_HISTORY:+-e} -p "$_text" "$_vnam" 1>&2
context -t -;CEN_QUIT_SANE=
CEN_QUIT_SANE=;CEN_CONS_MSGLEN=
[ -n "$_ssil" ]&&echo 1>&2;return 0
}
context() {
local _aerr _cons _hooc _hoov _hoof _mgui _root _sudo _text _trap _verb _wait='--wait --wait'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) _cons=1;;
-e) shift;_aerr="${1:-0}";;
-g) shift;_mgui="${1:--}";;
-h) shift;_hooc="$1";shift;_hoov="$1";shift;_hoof="$1";;
-n) _wait=;;
-q) _cons=0;;
-r) _root=1;;
-s) _sudo='sudo';;
-t) shift;_trap="${1:-+}";;
-v) shift;_verb="$1";;
-x) _cons=2;;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_aerr" ];then
_aerr="${_aerr//[!0-9]/}" _aerr="${_aerr:-0}"
if [ $((_aerr & 1)) = 0 ];then
set +eE;trap ERR
else
local _mesg=$"error trap"
set -eE;trap "set +eE ; _cen_abort -n '$_mesg'" ERR
fi
if [ $((_aerr & 2)) = 0 ];then
unset -f 'command_not_found_handle'
[ "${CEN_QUIT_TRAP:-0}" != 0 ]&&trap "$CEN_QUIT_TRAP"
elif ! isfunction 'command_not_found_handle';then
if [ "${CEN_QUIT_TRAP:-0}" != 0 ];then
command_not_found_handle() {
[ "${CEN_QUIT_TRAP:-0}" = 0 ]&&return
set +xeE;kill -$CEN_QUIT_TRAP $$
local _smsg;printf -v _smsg $"command '%s' not found" "$1"
_cen_abort -n -2 "$_smsg"
}
trap "trap $CEN_QUIT_TRAP; quit -s 4" $CEN_QUIT_TRAP
fi
fi
fi
if [ -n "$_verb" ];then
[ "$_verb" = + ]&&_verb=$((CEN_VERB+1))
[ "$_verb" = - ]&&_verb=$((CEN_VERB-1))
[ "$_verb" -lt 0 ]&&_verb=0
[ "$_verb" -gt 3 ]&&_verb=3
CEN_VERB="$_verb"
[ "$_verb" -ge 2 ]&&CEN_TRACE='trace'||CEN_TRACE=:
[ "$_verb" -gt 2 ]&&CEN_TRACE2='trace'||CEN_TRACE2=:
fi
[ -n "$_trap" ]&&case "$_trap" in
+) ((CEN_TRAPLVL += 1))
[ "$CEN_TRAPLVL" = 1 ] &&
for _trap in 1 2 3 15;do
trap "_cen_trap $_trap" $_trap
done
;;
-) ((CEN_TRAPLVL -= 1))
if [ "$CEN_TRAPLVL" -le 0 ];then
trap - 1 2 3 15;CEN_TRAPLVL=
fi
;;
.) trap - 1 2 3 15;CEN_TRAPLVL=
;;
*) trap "$_trap" 1 2 3 15;CEN_TRAPLVL=1
esac
if [ -n "$_mgui" -a -z "$CEN_CONSOLE" -a -z "$CEN_WINDOWS" ];then
case "$_mgui" in
1) [ -z "$CEN_DISPLAY" ]&&_mgui=2;;
-) if [ -z "$CEN_DISPLAY" ];then
_mgui=2
else
embed -r -q '_centauri_bash_run'&&terminal -c
if [ "${CEN_IS_DESKTOP:0}" = 0 ];then
_mgui=2
elif embed -r -m '_centauri_bash_win'&&windows -i 2;then
_mgui=0
else
_mgui=0;_cons=1
fi
fi;;
esac
case "$_mgui" in
1) embed -r -m '_centauri_bash_win'&&windows -i 1;;
2) embed -r -m '_centauri_bash_con' -i;_cons=1;;
esac
CEN_OPT_GUI=0
[ "$CEN_WINDOWS" = 1 ]&&CEN_OPT_GUI=1
[ "$CEN_CONSOLE" = 1 ]&&CEN_OPT_GUI=2
isfunction -z windows;isfunction -z console;isfunction -y progress
fi||:
if [ -n "$_hooc" ];then
[ -n "$_hoof" ]||_cen_abort + '-h'
local -n _vchn="$_hooc" _vvar="$_hoov"
if [ -z "$_vvar" ];then
isfunction -f -- "$_hoof"
_vvar="$_vchn";_vchn="$_hoof"
fi
fi
if [ -n "$_root" -a -z "$_sudo" ];then
[ "$EUID" != 0 ]&&fatal $"You must be root to run this program"
fi
[ "$CEN_QUIT_WAIT" = 2 ]&&_cons=
if [ -n "$_cons" ];then
[ -n "$CEN_QUIT_WAIT" ]&&CEN_IS_DESKTOP=0
if [ -z "$CEN_IS_DESKTOP" -a "$_cons" != 2 ];then
if [ -n "$CEN_DISPLAY" ];then
embed -r -q '_centauri_bash_run'&&terminal -c
fi||:
[ -z "$CEN_IS_DESKTOP" ]&&CEN_IS_DESKTOP=0
fi
[ "$_cons" = 0 ]&&return $CEN_IS_DESKTOP
fi
[ "$_cons" = 1 -a "$CEN_IS_DESKTOP" = 0 ]&&_cons=
[ -n "$_sudo" -a "$EUID" = 0 ]&&_sudo=
[ -z "$_cons" -a -z "$_sudo" ]&&return 0
[ -z "$_cons" -a "${CEN_QUIT_WAIT:-0}" = 0 ]&&_wait=
[ $# = 0 ]&&set -- "$0" $_wait "${CEN_CMDOPTS[@]}" "${CEN_CMDARGS[@]:CEN_CMDCURR}"
$CEN_TRACE -a "Rerun${_cons:+ console}${_sudo:+ sudo}: $*"
[ -z "$_cons" ]&&exec $_sudo "$@"
if [ -n "$CEN_DISPLAY" ]&&[ "${CEN_IS_DESKTOP:-0}" != 0 -o "$_cons" = 2 ];then
if embed -r -q '_centauri_bash_run';then
if [ "$_cons" = 2 ];then
terminal -f -o 1 -t "$_text" -r -- $_sudo "$@"
else
terminal -f -m 1 -t "$_text" -r -- $_sudo "$@"
fi
fi
else
system -r -f -- $_sudo "$@"||return 1
fi||:
return 0
}
create() {
local _fapp _ftru _fhdr _fcpy _fout _frun _fvar _mdir
local _otra="$CEN_TRACE" _oftl='error -z' _mtxt=$"file"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _fapp=1;;
-c) _fcpy=1;;
-f) _oftl='fatal';;
-d) _mdir=1;_mtxt=$"folder";;
-h) shift;_fhdr="$1";_fcpy=1
[ "${_fhdr:--}" = - ]&&_fhdr="$CEN_NAME";;
-o) _fout=-;;
-q) _oftl=:;;
-r) _frun='-r';;
-s) _otra=:;;
-t) _ftru=1;;
-v) shift;_fvar="$1";;
-w) _oftl='warning';;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fout" ]&&_fout="${1:--}"
if [ "$_fout" = - ];then
_fout='/dev/stdout';_ftru=
set -- "<stdout> ${1##*/}"
elif [ "${1::5}" = '/dev/' ];then
set -- "$1";_ftru=
elif [ -z "$_fapp" -a -z "$_ftru" ];then
[ -e "$_fout" ]&&return 0
fi
dryrun $_frun -s $"Create"" $_mtxt:" "$1"&&return 0
$_otra -a -c " $_mtxt" -- "$1"
local _temp _stat=0 _unew
if [ -n "$_mdir" ];then
[ "${2:--}" != - ]&&_unew="-m $2"
system $_frun -b -q -- mkdir $_unew -p -- "${_fout%/}"||_stat=$?
else
if [ -z "$_ftru" ];then
:
elif [ "$#" = 1 ]&&[ -f "$_fout" -a -w "$_fout" ];then
>"$_fout"||_stat=$?
elif [ -e "$1" ];then
system $_frun -b -e -p -- rm -f -- "$_fout"
fi
_cen_umask -s "$2"
{ [ -n "$_fhdr" ] && echo -e "# ${1##*/} - created by '$_fhdr' - do not edit!\n"
[ -n "$_fvar" ]&&{ splitjoin -d '\n' -j - -l -i "$_fvar";_fcpy=;}
[ -n "$_fcpy" ]&&while IFS= read -r _temp;do printf '%s\n' "$_temp";done
[ -n "$_fhdr" ]&&echo -e '\n# end';true
} 2>/dev/null >>"$_fout"||_stat=$?
[ "$((0${2:-0} & 07111))" = 0 ]||system $_frun -e -q -- chmod 0$2 "$_fout"
_cen_umask -r "$2"
fi
if [ "$_stat" != 0 ];then
$_oftl -p $"Cannot create %s: %s" "$_mtxt" "$_fout";return 1
elif [ "${3:--}" != - ];then
system $_frun -q -- chown -- "$3" "$_fout"&&return 0
$_oftl $"Cannot change owner:" "$_fout ($3)";return 1
fi
return 0
}
CEN_UMASK=
_cen_umask() {
[ "${2:--}" = - ]&&return 0
if [ "$1" = '-r' ];then
umask "${CEN_UMASK:-027}";return 0
fi
local _ukey _uval
if [ -z "$CEN_UMASK" ];then
while read _ukey _uval;do
[ "$_ukey" = 'Umask:' ]||continue
CEN_UMASK="$_uval";break
done 2>/dev/null < /proc/$$/status
[ -z "$CEN_UMASK" ]&&CEN_UMASK='027'
fi
printf -v _uval '0%o' $(((0$2 ^ 0777) & 0777))
umask "$_uval";return 0
}
dryrun() {
local _fsil _rsta=0 _tmsg=$"dryrun"
if [ -z "$CEN_OPT_DRYRUN" -o -n "$CEN_RUNDRY" ];then
$CEN_NOTRACE return 1
[ "$CEN_VERB" -lt 3 ]&&return 1;_rsta=1
fi
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-r) _rsta=1;;
-s) _fsil=1;;
*) _cen_abort - "$1"
esac;shift
done
[ $# = 0 ]&&return $_rsta
if [ "$_rsta" = 1 ];then
[ "$CEN_VERB" -lt 2 -o -n "$_fsil" ]&&return 1
_tmsg=$"Running"
fi
$CEN_NOTRACE return $_rsta
_cen_shortfmt _tmsg - "$_tmsg"
local _lbrk="${#_tmsg}";_tmsg="${_tmsg:1} $*"
if [ "$CEN_NOBREAK" = 1 ];then
$CEN_HOOK_MESSAGE -t -a "$_tmsg"
else
[ "$CEN_NOBREAK" = 2 ]&&_cen_compactify _tmsg
$CEN_HOOK_MESSAGE -t -a -b $_lbrk "$_tmsg"
fi
return $_rsta
}
_cen_compactify() {
[ "${CEN_NOBREAK:-2}" = 2 ]||return 0
local -n _vcmp="$1"
if [ "${2:--}" = - ];then
local _cols="${COLUMNS:-100}" _snam="${CEN_EMBED:-$CEN_NAME}"
[ -z "${_cols//[0-9]/}" ]||_cols=0
local _leng=$(("${#_vcmp}" + ${#_snam} + 2))
elif [ "${2:--}" = + ];then
local _cols="${COLUMNS:-100}" _leng="${#_vcmp}"
else
local _cols="$2" _leng="${#_vcmp}"
fi
[ "$_leng" -le $_cols ]&&return
local _lmax=$((_cols - 6))
[ "$_lmax" -lt 2 ]&&_lmax=2
local _lofs=$((_leng - ((_lmax+1)/2)))
_vcmp="${_vcmp::_lmax/2} <..> ${_vcmp:_lofs}"
return 0
}
embed() {
local _modu _terr _verb _vval _vset _vdel _xexc _rdry _odry _oind _xcmd=()
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vset="$1";local -n _vsar="$1";_vsar=();;
-c) _modu=3;;
-d) shift;[ "$1" = '--' ]&&_vdel=(-n)||_vdel=('-d' "$1");;
-g) if windows;then _verb+=' --gui=1'
elif console;then _verb+=' --gui=2'
else _verb+=' --gui=0'
fi;;
-i) [ -n "$CEN_AUTOIND" ]&&_oind=':a';CEN_AUTOIND=1;;
-m) _modu=1;_rdry='-r';;
-n) _terr=1;;
-q) _modu=2;_rdry='-r';;
-r) _rdry='-r';;
-s) shift;local -n _vval="$1";_vval=;_vset=-;;
-t) [ "$CEN_DONE" = 2 ]&&return 1;;
-u) shift;_cen_sudo _xcmd "$1";;
-v) [ "$CEN_VERB" -gt 1 ]&&_verb+=' --verbose'
[ "$CEN_VERB" -gt 2 ]&&_verb+=' --verbose'
[ "$CEN_VERB" -lt 1 ]&&_verb+=' --quiet';;
-x) _xexc=1;;
-y) [ "$CEN_YESNO" = y ]&&_verb+=' --yes'
[ "$CEN_YESNO" = n ]&&_verb+=' --no';;
-z) _rdry='-r';[ -n "$CEN_OPT_DRYRUN" ]&&_odry='--dryrun';;
*) _cen_abort - "$1"
esac;shift
done
local _sexi=0 _enam="${CEN_EMBED:-$CEN_NAME}" _snam="${1##*/}" _srun="$1";shift
if ! [ "${_srun::1}" = / -o "${_srun::2}" = './' ];then
[ -n "$_modu" ]&&_srun="$CEN_LIBRARY/$_srun"||_srun="$CEN_TOOLS/$_srun"
fi
if [ -n "$_modu" ];then
[ "${_snam:--}" = - ]&&return 1
[ -n "${CEN_MODULES["$_snam"]}" ] && return 0
if [ -n "$CEN_PACKAGE" ];then
if isfunction "_cen_bash_load_${_snam##*_}";then
[ "$_modu" = 3 ]&&return 0
_cen_bash_load_${_snam##*_} "$@"||_sexi="$?"
else
_sexi=1
fi
elif [ -x "$_srun" -o -e "$_srun.p" ];then
[ -n "$CEN_FEATURE_A" -a "$_modu" = 3 ]&&return 0
$CEN_TRACE2 -a -c $" module" "$_snam" "$@"
[ -n "$TEXTDOMAIN" ]&&TEXTDOMAIN="$_snam"
if [ "$_srun.p" -nt "$_srun" ];then
. "$_srun.p" "$@"||_sexi=$?
else
. "$_srun" "$@"&&apicheck -f -m -- "$_snam"||_sexi=$?
fi
else
_sexi=1
fi
[ -n "$TEXTDOMAIN" ]&&TEXTDOMAIN="$CEN_NAME"
[ "$_sexi" = 0 -o "$_modu" -ge 2 ]&&return $_sexi
_cen_abort $"Failed to load module:" "$_snam"
elif ! [ -x "$_srun" -a ! -d "$_srun" ];then
fatal $"Failed to execute script:" "$_srun"
fi
_xcmd+=("$_srun" --embed="$_enam$_oind" $_verb $_odry "$@")
dryrun $_rdry -- "${_xcmd[@]}"&&return 1
if [ -n "$_vset" ];then
_vval=$("${_xcmd[@]}")||_sexi="$?"
[ "${_vset:--}" != - ]&&splitjoin -s "$_vset" "${_vdel[@]}" -- "$_vval"
elif [ -n "$_xexc" ];then
exec "${_xcmd[@]}"||_sexi="$?"
else
"${_xcmd[@]}"||_sexi="$?"
fi
[ "$_sexi" = 0 ]&&return 0
[ -n "$_terr" ]&&return $_sexi
if [ "$_sexi" = 3 -o "$_sexi" = 4 ];then
CEN_EXIT="$_sexi";quit
fi
[ "$CEN_DONE" = 1 ]&&CEN_DONE=2
[ "$CEN_EXIT" -le 1 ]&&CEN_EXIT=2
return $_sexi
}
filter() {
local _iinc=0 _excl=0 _oinv _vall _valu _rval
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-f) _rval=1;;
-i) _oinv=1;;
-s) _rval=0;;
*) _cen_abort - "$1"
esac;shift
done
[ "${#CEN_OPT_INCLEXCL[@]}" = 0 ]&&return ${_rval:-0}
_vall="$1";[ -n "$_oinv" ]&&_vall="${1,,}"
for _valu in "${CEN_OPT_INCLEXCL[@]}";do
if [ -n "$_valu" ];then
[ "$_excl" = 0 ]&&_iinc=1
[ -n "$_oinv" ]&&_valu="${_valu,,}"
[[ "$_vall" == $_valu ]]&&return $_excl
fi
[ "$_excl" = 0 ]&&_excl=1||_excl=0
done
[ -n "$_rval" ]&&return $_rval
[ "$_iinc" = 0 ]
}
folder() {
local _oftl='error -z' _ocwd=: _ogen _onor _omak _oopt _tdir _tsuf _rdry _adir _vnam='CEN_FOLDER'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) shift;_tsuf=/
case "$1" in
prefix) _tdir="${CEN_PATHS[0]}";shift;continue;;
corebin) _tdir="${CEN_PATHS[1]}";shift;continue;;
etc) _tdir="${CEN_PATHS[2]}";shift;continue;;
var) _tdir="${CEN_PATHS[3]}";shift;continue;;
esac
_adir=("$CEN_ROOT/$1")
case "$1" in
default) _tdir="${CEN_PATHS[6]}";;
persistent) _tdir="${CEN_PATHS[3]}/tmp";;
transient) _tdir="${CEN_PATHS[4]}";;
*) _tdir="$_adir"
esac
[ "$_adir" -ef "$_tdir" ]&&_adir=()||_adir+=("$_tdir");;
-c) _ocwd='cd';;
-f) _oftl='fatal';_oopt='-f';;
-g) _ogen=1;;
-m) _omak=1;;
-n) _onor=1;;
-p) _ocwd='cd -P';;
-q) _oftl=:;;
-r) _rdry='-r';;
-s) shift;_vnam="$1";;
-t) local _name="${LOGNAME:-$USER}";[ "$EUID" = 0 ]&&_name='root'
[ -n "$XDG_RUNTIME_DIR" ] && _tdir="$XDG_RUNTIME_DIR/" \
                || _tdir="${CEN_PATHS[4]}/centauri-${_name:-$EUID}/"
if [ ! -d "$_tdir" ];then
create -d $_oopt $_rdry -- "$_tdir" 700||return 1
fi
_tsuf="$CEN_NAME";;
-u) shift;_tsuf=/
case "$1" in
cache) _adir=("${CEN_XTR_RUNTIME:-$XDG_CACHE_DIR}")
[ -z "$_adir" ]&&unset _adir[0]
_adir+=(~/.cache ~/.local ~/.config '');;
config) _adir=(~/.config ~/.local '');;
local) _adir=(~/.local ~/.config '');;
*) _cen_abort - "$1"
esac;;
-v) local _name="${LOGNAME:-$USER}"
[ "$EUID" = 0 ]&&_name='root';_name="${_name:-uid-$EUID}"
_tdir="${CEN_PATHS[3]}/tmp"
[ -d "$_tdir" ]||_tdir="${CEN_PATHS[4]}"
_tdir+="/$CEN_NAME-$_name";;
-w) _oftl='warning';;
*) _cen_abort - "$1"
esac;shift
done
local -n _vval="$_vnam"
[ -n "$_adir" ]&&for _tdir in "${_adir[@]}";do
if [ -z "$_tdir" ];then
_tsuf='/.';_tdir="$HOME";break
fi
[ -d "$_tdir" ]&&break
done
_vval="$_tdir$_tsuf$1"
[ "$_vval" = / ]||_vval="${_vval%/}"
[ -z "$_ogen" ]&&while [ ! -d "$_vval" ];do
if [ -n "$_omak" ];then
create -d $_oopt $_rdry -- "$_vval" "$2" "$3"&&break
elif [ -n "$_tdir" -a "$_ocwd" = : ];then
return 1
else
$_oftl $"Not a folder:" "$_vval"
fi
_vval=;return 1
done
if [ -n "$_onor" ];then
[ "${_vval::1}" = / ]||_vval="$PWD/$_vval"
_vval="${_vval//\/\//\/}";_vval="${_vval//\/.\//\/}"
[ "$_vval" -ef "$PWD" ]&&_vval="$PWD"
fi
[ "$_ocwd" = : ]&&return 0
if ! $_ocwd "$_vval" >/dev/null 2>&1;then
$_oftl $"Cannot use folder:" "$_vval"
_vval=;return 1
fi
[ -n "$_onor" ]&&_vval="$PWD"
$CEN_TRACE -a -c $" current" "$_vval"
return 0
}
invoke() {
local _copt
while [ "${1::1}" = - ];do
case "$1" in
-) break;;
--) shift;break;;
-c|-r|-s)
_copt+=("$1");;
-e|-w)
local _pmsg=$"Action '%s': " _eflg='error -z'
[ "$1" = '-w' ]&&_eflg='warning'
shift;_pmsg+="$1";[ "${1/\%s/}" = "$1" ]&&_pmsg+=' %s';shift
$_eflg -p "$_pmsg" "$CEN_ACTION" "$@";CEN_ARGS=X;return 0;;
-t) CEN_CMDARGS=("${CEN_CMDARGS[@]:CEN_CMDCURR}")
((CEN_CMDINDX -= CEN_CMDCURR));CEN_CMDCURR=0
[ $# -le 1 ]&&return 0;;
*) _cen_abort - "$1"
esac;shift
done
[ $# -lt 2 ]&&fatal "Missing args: invoke $*"
[ "${1:--}" != - ]&&CEN_ACTION="$1"
local nact="${2:--}" _amin="$3" _amax="$4"
if [ $# -gt 4 ];then
shift 4;CEN_ACTARR=("$@")
fi
arguments "$_amin" "$_amax" "${CEN_ACTARR[@]}"||return 0
[ -n "$_copt" ]&&context "${_copt[@]}"
[ "$nact" = - ]&&nact="action${CEN_ACTION^}"
if ! isfunction "$nact";then
error -z $"Not yet implemented:" "$CEN_ACTION"
elif [ -n "$CEN_OPT_TRACE" ];then
$CEN_TRACE2 -r -c " '$CEN_ACTION'" "$nact"
CEN_NOTRACE=;set -x;$nact "${CEN_ACTARR[@]}";set +x;CEN_NOTRACE=:
else
$CEN_TRACE2 -r -c " '$CEN_ACTION'" "$nact"
$nact "${CEN_ACTARR[@]}"
fi
CEN_ACTARR=()
return 0
}
isfunction() {
local _sta_=0 _dmy_ _exe_ _nam_ _run_ _msg_=:
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _msg_='_cen_abort';;
-c) _run_=1;;
-e) _msg_='error -z';;
-f) _msg_='fatal';;
-t) _msg_="$CEN_TRACE";;
-w) _msg_='warning';;
-x) _exe_=1;;
-y) _dmy_=0;;
-z) _dmy_=1;;
*) _cen_abort - "$1"
esac;shift
done
_nam_="$1";shift
if [ -n "$_exe_" ];then
type -t -- "$_nam_"||_sta_=1
elif [ "${_nam_/\//}" != "$_nam_" ];then
_sta_=1
else
PATH= type -t -- "$_nam_"||_sta_=1
fi >/dev/null
if [ $_sta_ != 0 ];then
$_msg_ $"Undefined function:" "$_nam_"
[ -z "$_dmy_" ]&&return 1
eval "$_nam_() { return $_dmy_ ; }"
fi
[ -z "$_run_" ]&&return 0
$_nam_ "$@"
}
optarg() {
[ $# -lt 2 ]&&_cen_abort +
local _acnt=2 _emsg _vnam _varr _expr="${3:--}"
if [ -z "$CEN_ARGOPT" ];then
[ $# -gt 3 ]&&CEN_ACTARR="$4"
else
_acnt=1;CEN_ACTARR="$CEN_ARGOPT"
fi
case "$2" in
\[\]) _vnam="CEN_OPT_${1^^}";_varr=1;;
-) _vnam="CEN_OPT_${1^^}";;
*\[\]) _vnam="${2%[]}";_varr=1;;
*) _vnam="$2"
esac
if [ -n "$_varr" ];then
local -n _vvar="$_vnam";_vnam="$_vnam[${#_vvar[@]}]"
fi
case "$_expr" in
-a|-d|-r|-s|-w)
embed -r -m '_centauri_bash_iom';_cen_optarg_iom "$_expr" "$1" "$_vnam";;
-e) CEN_ACTARR="$2";CEN_ARGOPT=0;_emsg="$4";;
-f|-)
CEN_CMDOPTS+=("--$1");printf -v "$_vnam" '%s' "${4:-1}";CEN_ARGS=1
[ -z "$CEN_ARGOPT" ]&&return 0;_emsg=$"no argument allowed";;
-i|-x)
local _temp="$CEN_ACTARR";_vnam=
case "$_temp" in
*\**);;
^*\$) _temp="${_temp:1}";_temp="${_temp%\$}";;
^*) _temp="${_temp:1}*";;
*\$) _temp="*${_temp%\$}";;
*) _temp="*$_temp*"
esac
[ "$_expr" = '-i' ]&&CEN_OPT_INCLEXCL+=("$_temp" '')||CEN_OPT_INCLEXCL+=('' "$_temp");;
-m)
[ "${1:-1}" = 1 ]&&return 0;shift 3
error -r $"mutually exclusive options:" "$@";CEN_ARGS=1;return 1;;
-n)
_expr="${CEN_ACTARR//[0-9]/}"
[ -n "$_expr" -a "$_expr" != - ]&&_emsg=$"must have a numeric value";;
-o)
case "$CEN_ACTARR" in
off|0) CEN_ACTARR=0;;
on|1) CEN_ACTARR=1;;
auto|2|-) CEN_ACTARR="$4";;
*) _emsg=$"value must be 'off|on|auto' or '0|1|2'"
esac;;
-t);;
*)
[[ $CEN_ACTARR =~ ^($_expr)$ ]]||_emsg=$"has an invalid value";;
esac
if [ -n "$CEN_ARGOPT" ];then
CEN_ARGOPT=
elif [ "$_expr" != '-o' ];then
case "$CEN_ACTARR" in
--*|-[a-zA-Z]*|"")
_emsg=$"must have a value";_acnt=1;CEN_ACTARR=;;
esac
fi
if [ -n "$_emsg" ];then
error -r "Option '--$1=$CEN_ACTARR' $_emsg" ; CEN_ARGS="$_acnt" ; return 1
fi||:
[ -n "$_vnam" ]&&printf -v "$_vnam" '%s' "$CEN_ACTARR";
CEN_CMDOPTS+=("--$1=${CEN_ACTARR:--}");CEN_ARGS="$_acnt";return 0
}
splitjoin() {
local _buf_ _nam_=- _exe_ _lin_ _del_ _spl_ _arr_ _new_
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-d) shift;printf -v _del_ -- "$1";;
-i) shift;_arr_="${1:-}";;
-j) shift;_nam_="${1:-}";_spl_=0;;
-l) _lin_=$'\n';;
-n) _new_=1;;
-s) shift;_nam_="${1:-}";_spl_=1;;
-x) shift;_exe_="$1";_spl_=2;;
*) _cen_abort - "$1"
esac;shift
done
if [ "$_nam_" != - ];then
local -n _buf_="$_nam_"
elif [ -z "$_spl_" ];then
_spl_=1;[ -z "$_del_" ]&&_new_=1;_lin_=$'\n'
elif [ "$_spl_" = 0 -a -n "$_lin_" ];then
[ -z "$_del_" ]&&_spl_=1
fi
if [ "$_arr_" = - ];then
local _lst_ _tmp_
if [ -z "$_new_" ];then
if [ -z "$_del_" ];then
IFS=$'\n' read -r -d '' -a _lst_
else
IFS="$_del_" read -r -d '' -a _lst_
fi
elif [ "$_spl_" != 2 -a "$_nam_" = - ];then
while IFS= read -r _tmp_;do printf '%s\n' "$_tmp_";done
return 0
else
while IFS= read -r _tmp_;do _lst_+=("$_tmp_");done
fi
if [ "$_spl_" = 1 -a "$_nam_" != - ];then
_buf_=("${_lst_[@]}");return 0
fi
set -- "${_lst_[@]}";unset _lst_
elif [ -n "$_arr_" ];then
local -n _ref_="$_arr_";set -- "${_ref_[@]}"
fi||:
if [ -n "$_exe_" -a -z "$_del_" ];then
for _spl_ in "$@";do $_exe_ "$_spl_"||break;done
elif [ "$_spl_" = 0 ];then
[ -n "$_new_" ]&&_del_=$'\n'
[ -z "$_del_" ]&&_del_=$' '
_buf_="$1";shift
for _spl_ in "$@";do _buf_+="$_del_$_spl_";done
[ "$_nam_" = - -a -n "$_buf_" ]&&printf '%s' "$_buf_$_lin_"
else
local _ifs_="$IFS";set -f
if [ -n "$_new_" ];then
IFS=$'\x1e';_buf_=(${*//$'\n'/$'\x1e'})
else
[ -z "$_del_" ]&&IFS=$'\t\n'||IFS="$_del_"
_buf_=($*)
fi
IFS="$_ifs_";set +f
if [ -n "$_exe_" ];then
for _spl_ in "${_buf_[@]}";do $_exe_ "$_spl_"||break;done
elif [ "$_nam_" = - -a "${#_buf_[*]}" != 0 ];then
IFS=$'\n';[ -z "$_lin_" ]&&IFS=' '
printf '%s\n' "${_buf_[*]}";IFS="$_ifs_"
fi
fi||:
}
sysfind() {
local _ferr="$CEN_TRACE" _fblt _fcch _fdrp _fign _fone _fset _psys _stat=0
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) _fblt=1;;
-c) _fcch=1;;
-d) _fdrp=1;;
-e) _ferr='error -z';;
-f) _ferr='fatal';;
-i) _fign=1;;
-o) _fone=1;;
-p) shift;_psys="$1";;
-q) _ferr=:;;
-s) shift;local -n _vset="$1";_fset=-;;
-w) _ferr='warning';;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_psys" ]&&_psys="$PATH:${CEN_PATHS[1]}"
_cen_sysfind() {
[ -n "$_fset" ]&&_fset+=$'\n'"$1"
[ -z "$_fone" ]&&return 1
_fone=2;return 0
}
local _snam _sdir _scmd _parr _sifs _srun
for _snam in "$@";do
if [ -n "${CEN_COMMANDS["${_snam:-/}"]}" ] ; then
if [ -n "$_fdrp" ];then
unset CEN_COMMANDS["$_snam"]
[ -n "$_fcch" ]||continue
elif [ -z "$_fign" ];then
_scmd="${CEN_COMMANDS["$_snam"]}"
[ "$_scmd" = - ]&&_scmd="$_snam"||_scmd+="/$_snam"
_cen_sysfind "${_scmd/\/\//\/}"&&break
continue
fi
fi
_scmd=
case "$_snam" in
/*/*) _parr="${_snam%/*}";_snam="${_snam##*/}";;
/*) _parr=/;_snam="${_snam:1}";;
*/*) _parr="$PWD/${_snam%/*}";_snam="${_snam##*/}";;
*) if [ -n "$_fblt" ];then
if BASH_LOADABLES_PATH= enable -a "$_snam" &>/dev/null;then
_scmd="$_snam"
elif PATH= type -t -- "$_snam" >/dev/null;then
[ -n "$CEN_FEATURE_A" ] &&
_cen_dyn_builtin "$_snam" >/dev/null&&_scmd="$_snam"
fi
if [ -n "$_scmd" ];then
[ -n "$_fcch" ]&&CEN_COMMANDS["$_snam"]=-
_cen_sysfind "$_scmd"&&break
continue
fi
fi
_sifs="$IFS";IFS=:;set -f;_parr=($_psys);set +f;IFS="$_sifs"
esac
for _sdir in "${_parr[@]}";do
[ "$_sdir" = '.' ]&&_sdir="$PWD"
[ "$_sdir" = / ]||_sdir="${_sdir%/}"
_srun="$_sdir/$_snam"
[ -x "$_srun" ]||continue
[ -d "$_srun" ]&&continue
_srun="${_srun//\/\//\/}"
_scmd="${_srun//\/.\//\/}";break
done
if [ -n "$_scmd" ];then
[ -n "$_fcch" ]&&CEN_COMMANDS["$_snam"]="$_sdir"
_cen_sysfind "$_scmd"&&break
elif [ -z "$_fone" ];then
$_ferr -p $"command '%s' not found" "$_snam" ; _stat=1
fi
done
[ -n "$_fset" ]&&_vset="${_fset:2}"
if [ "$_fone" = 1 ];then
$_ferr $"found no applicable command:" "$@"
return 2
fi
return $_stat
}
_cen_sudo() {
local _sexe _user="$2";[ "$_user" = - ]&&_user='root'
[ -z "$_user" -o "${USER:-$LOGNAME}" = "$_user" ]&&return 0
sysfind -c -e -s _sexe -- sudo||return 1
local -n _vsdo="$1";_vsdo=("$_sexe" -u "$_user" -H);return 0
}
system() {
$CEN_NOTRACE set +x
local _ferr _mind _nout _val_ _vset _vdel _xcmd _sudo _cpro _rdry _bflg _xflg _zflg _temp
local _good=0 _stat=0 _ecmd="$CEN_TRACE" _earg
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vset="$1";local -n _vaa_="$1";_vaa_=();unset _vaa_;;
-b) _bflg='-b';;
-c) _cpro=1;;
-d) shift;[ "$1" = '--' ]&&_vdel=(-n)||_vdel=('-d' "$1");;
-e) _ferr='-e';_ecmd=error;;
-f) _ferr='-f';_ecmd=fatal;;
-g) shift;_good="$1";;
-i) _mind='-i';;
-m) _nout=3;;
-n) _cpro=0;;
-p) _nout=2;;
-q) _nout=1;;
-r) _rdry='-r';;
-s) shift;local -n _val_="$1";_val_=;_vset=-;;
-t) if [ "$CEN_DONE" = 2 ];then
$CEN_NOTRACE set -x;return 1
fi;;
-u) shift;_cen_sudo _sudo "$1";;
-v) _earg=1;;
-w) _ferr='-w';_ecmd=warning;;
-x) _xflg=1;;
-z) _zflg=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ "$_cpro" = 1 ];then
sysfind -c $_bflg $_ferr -- "$@"||_stat=127
$CEN_NOTRACE set -x;return $_stat
elif [ "$1" = 'eval' ];then
[ -n "$_sudo" ]&&_xcmd=("${CEN_PATHS[1]}/bash" -c "${*:1}")
elif [ -z "$_cpro" ];then
_temp="${CEN_COMMANDS["${1:-/}"]}"
case "$_temp" in
'');;
-) [ -z "$_bflg" ]&&_temp=;;
*) [ -n "$_bflg" ]&&_temp=;;
esac
if [ -z "$_temp" ];then
[ "$_nout" = 1 ]&&_temp=||_temp="${_ferr:--e}"
[ -n "$_xflg" ]&&_bflg=
if ! sysfind -c -d $_bflg $_temp -- "$1";then
$CEN_NOTRACE set -x;return 127
fi
_temp="${CEN_COMMANDS["${1:-/}"]}"
fi
if [ "$_temp" = - ];then
_xcmd=(builtin "$@")
else
_temp+="/$1";_temp="${_temp/\/\//\/}"
_xcmd=("$_temp" "${@:2}")
fi
fi
[ -z "$_xcmd" ]&&_xcmd=("$@")
[ -n "$_sudo" ]&&_xcmd=("${_sudo[@]}" "${_xcmd[@]}")
[ -n "$_xflg" ]&&_xcmd=(exec "${_xcmd[@]}")
if dryrun $_rdry -- "${_xcmd[@]}";then
$CEN_NOTRACE set -x;return 1
fi
if [ -n "$_vset" -o "$_nout" = 2 ];then
if [ "$_nout" = 1 ];then
{ _val_=$("${_xcmd[@]}")||_stat=$?;} 2>/dev/null
elif [ -n "$_nout" ];then
if [ -n "$_zflg" ];then
exec 3>&1;_val_=$("${_xcmd[@]}" 2>&1 1>&3)||_stat=$?;exec 3>&1
else
_val_=$("${_xcmd[@]}" 2>&1)||_stat=$?
fi
else
_val_=$("${_xcmd[@]}")||_stat=$?
fi
[ "${_vset:--}" != - ]&&splitjoin -s "$_vset" "${_vdel[@]}" -- "$_val_"
elif [ "$_nout" = 3 ];then
_val_=$("${_xcmd[@]}" 2>&1)||_stat=$?
message $_mind -n "$_val_";_val_=
elif [ -n "$_nout" ];then
if [ -n "$_zflg" ];then
"${_xcmd[@]}" 2>/dev/null||_stat=$?
else
"${_xcmd[@]}" >/dev/null 2>&1||_stat=$?
fi
else
"${_xcmd[@]}"||_stat=$?
fi
if [ "$_stat" -le "$_good" ];then
$CEN_NOTRACE set -x;return $_stat
fi
[ -z "$_earg" ]&&_earg="$1"||_earg="$*"
if [ "$_nout" = 2 -a -n "$_val_" ];then
if [ -z "$_ferr" ];then
message $_mind -n -- "$_val_"
else
_temp="${_val_#$CEN_LIBRARY*$1: }"
[ "${_temp}" != "$_val_" ]&&_val_="$1: $_temp"
$_ecmd -n -p -- $"Running '%s' failed (status %s)""\n%s" "$_earg" "$_stat" "$_val_"
fi
elif [ -n "$_ferr" ];then
$_ecmd -p -- $"Running '%s' failed (status %s)" "$_earg" "$_stat"
fi
[ -n "$_ferr" ]&&CEN_AUTOIND=
$CEN_NOTRACE set -x;return $_stat
}
_cen_handle() {
local _ihan
for ((_ihan=10;_ihan < 100;_ihan++));do
[ "$#" = 0 ]&&return
[ -e "/dev/fd/$_ihan" ]&&continue
printf -v "$1" "$_ihan";shift
done
_cen_abort $"No free file handle"
}
main() {
[ -n "$CEN_IS_SOURCED" ]&&return 0
CEN_STAGE='main'
CEN_CMDINDX=0;CEN_CMDARGS=();CEN_CMDOPTS=();CEN_ACTION=;CEN_ARGOPT=
$CEN_HOOK_MAIN "$@"
if [ "$CEN_DONE" = 2 ];then
CEN_STAGE=;return 0
fi
apicheck -f -- "$CEN_VERSION"
isfunction -y 'options'
local _cont=2 _isok _help _oinf
[ -n "$CEN_CMDARGS" ]&&{ set -- "${CEN_CMDARGS[@]}";CEN_CMDARGS=();}
if [ "$CEN_RUN_MIN_ARGS" != - ];then
[ "$CEN_RUN_MAX_ARGS" = 0 ]&&CEN_RUN_MIN_ARGS=0
[ -z "$CEN_RUN_MAX_ARGS" ]&&CEN_RUN_MAX_ARGS=+
if [ -z "$CEN_RUN_MIN_ARGS" ];then
isfunction 'actions'&&CEN_RUN_MIN_ARGS=1||CEN_RUN_MIN_ARGS=+
fi
[ "$#" = 0 -a "$CEN_RUN_MIN_ARGS" = + ]&&_help='-u'
fi
while [ "$#" -gt 0 ];do
if [ "$CEN_ACTION" != '---' ];then
CEN_ACTION="$1";CEN_ARGOPT=
case "$1" in
--*=*) CEN_ARGOPT="${1#*=}";CEN_ACTION="${1%%=*}";;
-[^-]*) CEN_ARGOPT="${1:2}";CEN_ACTION="${1::2}";;
esac
fi
_isok=x;CEN_ARGS=0;CEN_ACTARR="$2"
if [ "${CEN_ACTION::1}" = - ]&&[ "$CEN_ACTION" != '---' ];then
$CEN_HOOK_OPTIONS "$CEN_ACTION" "${CEN_ARGOPT:-$2}"
if [ "$CEN_ARGS" != 0 ];then
[ "$CEN_ARGS" -gt "$#" ]&&CEN_ARGS="$#";shift "$CEN_ARGS"
continue
fi
fi
CEN_ARGS=1
case "$CEN_ACTION" in
-|---)
CEN_CMDARGS+=("$1");;
--|"")
[ -n "$CEN_CMDARGS" ]&&CEN_CMDARGS+=("$1");;
-d|--dry*)
_isok="$CEN_FEATURE_D";optarg 'dryrun' -;;
-f|--force)
_isok="$CEN_FEATURE_F";optarg 'force' -;;
-g|--gui)
_isok="$CEN_FEATURE_G";[ -n "$_isok" ]&&optarg 'gui' - -o;;
-h|--help)
_help='-h';;
-q|--quie*)
[ "$CEN_VERB" = 1 ]&&optarg 'quiet' CEN_VERB -f 0;;
-s|--sil*)
_isok="$CEN_FEATURE_S";optarg 'silent' -;;
-v|--verb*)
context -v +||:
optarg 'verbose' CEN_VERB -f "$CEN_VERB";;
-n|--no)
_isok="$CEN_FEATURE_Y";[ -n "$_isok" ]&&optarg 'no' CEN_YESNO -f n;;
-y|--yes)
_isok="$CEN_FEATURE_Y";[ -n "$_isok" ]&&optarg 'yes' CEN_YESNO -f y;;
-i|--incl*)
_isok="$CEN_FEATURE_I";[ -n "$_isok" ]&&optarg 'include' - -i;;
-x|--excl*)
_isok="$CEN_FEATURE_I";[ -n "$_isok" ]&&optarg 'exclude' - -x;;
-z|--zomb*)
_cont=3;optarg 'zombie' -;;
--embed)
optarg 'embed' CEN_EMBED -t;CEN_FEATURE_D=1;CEN_FEATURE_Y=1
[ "${CEN_EMBED/*:/:}" = ':a' ]&&CEN_AUTOIND=2
CEN_EMBED="${CEN_EMBED%:*}"
[ "$CEN_EMBED" = "$CEN_NAME" ]&&CEN_EMBED=;;
--info)
_oinf=1;CEN_FEATURE_D=1;CEN_FEATURE_Y=1;;
--pager)
optarg 'pager' - -t;;
--trace)
CEN_OPT_TRACE=1;;
--wait)
[ -n "$CEN_QUIT_WAIT" ]&&CEN_QUIT_WAIT=2||CEN_QUIT_WAIT=1;;
-*)
_isok=;;
*)
CEN_CMDARGS+=("$1");;
esac
[ "$CEN_ARGS" -gt "$#" ]&&CEN_ARGS="$#";shift "$CEN_ARGS"
[ -n "$_isok" ]&&continue;_help=
error -p -r -z $"Unknown option '%s', try '%q --help'" "$CEN_ACTION" "$CEN_NAME"
done
CEN_ACTION=
if [ -n "$_help" ];then
embed -m '_centauri_bash_use' "$_help"
elif [ -n "$_oinf" ];then
[ -n "$CEN_PACKAGE" ]&&_cen_bash_info
embed -m '_centauri_bash_sys'&&sysinfo "${CEN_CMDARGS[@]}"
elif [ "$CEN_EXIT" != 0 ];then
CEN_EXIT=1;quit
fi
if [ "$CEN_RUN_MIN_ARGS" != - ];then
[ "$CEN_RUN_MIN_ARGS" = + ]&&CEN_RUN_MIN_ARGS=0
if [ "${#CEN_CMDARGS[@]}" = 0 -a "$CEN_RUN_MIN_ARGS" != 0 ];then
embed -m '_centauri_bash_use' '-u'
fi
fi
[ "${CEN_OPT_PAGER:--}" != - ] &&
embed -r -q '_centauri_bash_pip'&&syspager -y -d -c ''
[ -n "$CEN_FEATURE_G" ]&&context -g "$CEN_OPT_GUI"
$CEN_HOOK_OPTIONS
if [ -n "$CEN_DEFAULTS" ]&&[ -r "$CEN_DEFAULTS" ];then
trace -a -c 'Sourcing' "$CEN_DEFAULTS"
. "$CEN_DEFAULTS"
fi
if [ "$CEN_DONE" = 2 ];then
CEN_STAGE=;return 0
fi
_cen_actions() {
isfunction "$CEN_HOOK_ACTIONS"||CEN_FEATURE_R=1
local _curr _olit
if [ -n "$CEN_FEATURE_R" ];then
CEN_STAGE='run'
local _rarg=();CEN_ACTARR=()
for _curr in "${CEN_CMDARGS[@]}";do
if [ "$_curr" = '---' ]&&[ -z "$_olit" ];then
_olit=1;continue
fi
_rarg+=("$_curr")
done
invoke 'run' run "$CEN_RUN_MIN_ARGS" "$CEN_RUN_MAX_ARGS" "${_rarg[@]}"
return 0
fi
CEN_STAGE='actions'
CEN_ACTION=;[ "$CEN_DONE" -lt "$_cont" ]&&$CEN_HOOK_ACTIONS "" "${CEN_CMDARGS[@]}"
local _curr _imax="${#CEN_CMDARGS[@]}"
[ $_imax = 0 -a -z "$CEN_ACTION" ] &&
error -r -p -z $"Don't know what to do, try '%q --help'" "$CEN_NAME"
while [ $CEN_CMDINDX -lt $_imax -a "$CEN_DONE" -lt "$_cont" ];do
CEN_ACTION="${CEN_CMDARGS[CEN_CMDINDX++]}"
[ "${CEN_ACTION:---}" = '--' ]&&continue
[ "$CEN_ACTION" = '---' ]&&{ _olit=1;continue;}
_imax="${#CEN_CMDARGS[@]}"
CEN_ACTARR=();CEN_CMDCURR=$((CEN_CMDINDX - 1))
while [ $CEN_CMDINDX -lt $_imax ];do
_curr="${CEN_CMDARGS[CEN_CMDINDX++]}"
if [ -z "$_olit" ];then
[ "$_curr" = '--' ]&&break
[ "$_curr" = '---' ]&&{ _olit=1;continue;}
fi
CEN_ACTARR+=("$_curr")
done
CEN_ARGS=;$CEN_HOOK_ACTIONS "$CEN_ACTION" "${CEN_ACTARR[@]}"
[ "$CEN_AUTOIND" = 1 ]&&CEN_AUTOIND=
[ "$CEN_DONE" = 2 -a "$_cont" = 3 ]&&CEN_DONE=1
if [ -z "$CEN_ARGS" ];then
case "${CEN_ACTION:--}" in
--|---);;
*) error -r -p -z $"Unknown action '%s', try '%q --help'" "${CEN_ACTION:--}" "$CEN_NAME" ;;
esac
fi
[ $CEN_CMDINDX -lt $_imax -a "$CEN_DONE" = 2 ] &&
error -i -z $"Previous error: Not all actions were run"
done;return 0
}
$CEN_PAGER _cen_actions;CEN_STAGE=;return 0
}
if [ ! -x "${CEN_PATHS[1]}/bash" ];then
CEN_PATHS[1]="${BASH%/bash}";[ -d "${CEN_PATHS[1]}" ]||CEN_PATHS[1]='/usr/bin'
CEN_PATHS[0]="${CEN_PATHS[1]%/usr/bin}"
CEN_PATHS[0]="${CEN_PATHS%/bin}"
CEN_PATHS[2]="$CEN_PATHS/etc";[ -d "${CEN_PATHS[2]}" ]||CEN_PATHS[2]="$CEN_PATHS/usr/etc"
CEN_PATHS[3]="$CEN_PATHS/var";[ -d "${CEN_PATHS[3]}" ]||CEN_PATHS[3]="$CEN_PATHS/usr/var"
CEN_PATHS[4]="$CEN_PATHS/tmp";[ -d "${CEN_PATHS[4]}" ]||CEN_PATHS[4]="$CEN_PATHS/usr/tmp"
fi
if [ -z "${CEN_PATHS[5]}" ];then
CEN_PATHS[5]="$CEN_PATHS/usr/lib";[ -d "${CEN_PATHS[5]}" ]||CEN_PATHS[5]="$CEN_PATHS/lib"
fi
if [ -z "${CEN_PATHS[6]}" ];then
CEN_PATHS[6]="$CEN_ROOT/default"
if [ -n "$CEN_PACKAGE" ];then
CEN_PATHS[6]="${CEN_PATHS[2]}/default"
elif [ "${CEN_PATHS[6]}" -ef "${CEN_PATHS[2]}/default" ];then
CEN_PATHS[6]="${CEN_PATHS[2]}/default"
fi
fi
_cen_handle CEN_STDOUT CEN_STDERR;eval exec "$CEN_STDOUT>&1" "$CEN_STDERR>&2"
[ -z "$CEN_ROOT" -o -z "$CEN_LIBRARY" ]&&fatal 'Environment not set (missing proxy?)'
[ -n "$CEN_FEATURE_E" ]&&context -e 3||context -e 2
if [ -n "$CEN_FEATURE_O" ];then
CEN_DEFAULTS="$HOME/.config/${CEN_NAME%.*}"
[ ! -e "$CEN_DEFAULTS" ]&&CEN_DEFAULTS="${CEN_PATHS[6]}/${CEN_NAME%.*}"
fi
[ -n "$CEN_FEATURE_A" ]&&embed -r -m '_centauri_bash_dyn' -f
[ -n "$CEN_FEATURE_W" ]&&embed -r -m '_centauri_bash_web' -w
for CEN_ACTION in "${!CEN_MODULES[@]}";do
[ -z "${CEN_MODULES[$CEN_ACTION]}" ]&&embed -m "$CEN_ACTION"
done
CEN_STAGE=
:
}
_cen_bash_load_con(){
CEN_MODULES['_centauri_bash_con']='0.23:2'
CEN_ROWS=
CEN_COLS=
CEN_DECO_MARK=
CEN_DECO_BOLD=
CEN_DECO_ITAL=
CEN_DECO_NORM=
CEN_DECO_ULIN=
CEN_DECO_EROR=
CEN_DECO_WARN=
CEN_DECO_TRCE=
CEN_CONS_UTF8='─═•'
CEN_CONS_HIGH=
CEN_CONS_MSGLEN=
CEN_CONS_MSGTXT=
CEN_CONS_PROGLN=
CEN_CONSOLE=
CEN_CONS_HOOK_MESSAGE=
console() {
local _fmod _frow _fcol _high=2
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) shift;_fcol="$1";;
-h) shift;_high="$1";;
-m) shift;_fmod="$1";;
-r) shift;_frow="$1";;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$CEN_CONSOLE" -o -n "$_fmod" ];then
if [ -z "$CEN_CONS_HOOK_MESSAGE" ];then
CEN_CONS_HOOK_MESSAGE=$CEN_HOOK_MESSAGE;CEN_HOOK_MESSAGE='_cen_con_mesg'
fi
if [ -z "$_fmod" ];then
if [ -n "$CEN_PAGER" ];then
_fmod=1
elif [ "${TERM:-dumb}" = 'dumb' ];then
_fmod=0
elif ! [ -t 2 ];then
_fmod=0
elif [ "${TERM::5}" = 'xterm' -o "$TERM" = 'linux' ];then
_fmod=1
else
_fmod=2
fi
elif [ "$_fmod" -gt 2 ];then
if [ -n "$CEN_OPT_FORCE" -o -t 1 ];then
_fmod=1
else
_fmod=0;_frow=;_fcol=
fi
fi
fi
case "${LANG,,}" in
*.utf8);;
*.utf-8);;
*) CEN_CONS_UTF8='-=°'
esac
if [ -n "$_fmod" ];then
CEN_CONSOLE="$_fmod"
CEN_CONS_MSGLEN=
CEN_COLS=;CEN_ROWS=
fi
if [ "$_fmod" = 1 ];then
export CEN_DECO_BOLD=$'\033[1m'
export CEN_DECO_ITAL=$'\033[3m'
export CEN_DECO_MARK=$'\033[7m'
export CEN_DECO_NORM=$'\033[0m'
export CEN_DECO_ULIN=$'\033[4m'
if [ -n "$_high" ];then
export CEN_DECO_EROR=$'\033[01;31m'
export CEN_DECO_WARN=$'\033[01;35m'
export CEN_DECO_TRCE=$'\033[01;32m'
fi
elif [ -n "$_fmod" ];then
CEN_DECO_BOLD=
CEN_DECO_ITAL=
CEN_DECO_MARK=
CEN_DECO_NORM=
CEN_DECO_ULIN=
CEN_DECO_EROR=
CEN_DECO_WARN=
CEN_DECO_TRCE=
CEN_CONS_HIGH=
_fcol=;_frow=
[ "$_high" = 2 ]&&_high=
fi
[ "$_high" = 2 ]&&_high=1
CEN_CONS_HIGH="$_high"
if [ -n "$_frow" ];then
[ "$_frow" = 0 ]||LINES="$_frow"
[ -z "$LINES" -a -n "$TERM" ]&&sysrun -q -r -s LINES tput lines
CEN_ROWS="$LINES"
fi
if [ -n "$_fcol" ];then
[ "$_fcol" = 0 ]||COLUMNS="$_fcol"
[ -z "$COLUMNS" -a -n "$TERM" ]&&sysrun -q -r -s COLUMNS tput cols
CEN_COLS="$COLUMNS"
[ "$CEN_NOBREAK" = 1 ]&&CEN_NOBREAK=
fi
[ "$CEN_CONSOLE" -gt 0 ]
}
CEN_DECORATE=
decorate() {
local _fclr=1 _ffix _flin _fmul _deco=- _npad=0 _stxt _fset='CEN_DECORATE'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_fset="$1";_fclr=;;
-d) shift;_deco="${1:--}";;
-f) shift;_ffix="$1";;
-l) _flin=1;;
-m) _fmul=1;;
-s) shift;_fset="$1";;
*) _cen_abort - "$1"
esac;shift
done
local -n _varg="$_fset";[ -n "$_fclr" ]&&_varg=
_stxt="$*"
if [ -n "$_ffix" ];then
_stxt="${_stxt::_ffix}"
_npad=$((_ffix - ${#_stxt}))
[ -z "$_stxt" ]&&_deco=-
elif [ -z "$_stxt" ];then
[ "$_deco" != 0 -a "${_deco::3}" != 'nor' ]&&return 0
fi
if [ -n "$_fmul" -a "$_deco" != - -a "$_deco" != 0 ];then
splitjoin -x "decorate -l -d $_deco -a $_fset --" -d '\n' -- "$_stxt"
[ -z "$_flin" ]&&_varg="${_varg::${#_varg}-2}"
return 0
fi
case "$_deco" in
-) _varg+="$_stxt";;
1|bol*) _varg+="$CEN_DECO_BOLD$_stxt$CEN_DECO_NORM";;
2|mar*) _varg+="$CEN_DECO_MARK$_stxt$CEN_DECO_NORM";;
3|ita*) _varg+="$CEN_DECO_ITAL$_stxt$CEN_DECO_NORM";;
4|uli*|und*)
_varg+="$CEN_DECO_ULIN$_stxt$CEN_DECO_NORM";;
9|rem*) _deco=$'\033'"\\[[0-9]m"
_varg+="${_stxt//$_deco/}";;
10|tra*) _varg+="$CEN_DECO_TRCE$_stxt$CEN_DECO_NORM";;
11|war*) _varg+="$CEN_DECO_WARN$_stxt$CEN_DECO_NORM";;
12|err*) _varg+="$CEN_DECO_EROR$_stxt$CEN_DECO_NORM";;
*) _varg+="$CEN_DECO_NORM$_stxt"
esac
if [ "$_npad" -gt 0 ];then
printf -v _stxt "%${_npad}s" '';_varg+="$_stxt"
fi
[ -n "$_flin" ]&&_varg+='\n';return 0
}
output() {
$CEN_NOTRACE return 0
local _aopt _balg=0 _cexp _deco _fbrk _ffmt _find _fjoi _flin _fmul _fsav
local _sind _fexp _nexp _marr _mesg _cols="${CEN_COLS:-0}"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _aopt=1;_sind="$CEN_AUTOIND";;
-b) shift;_fbrk="$1";;
-d) shift;_deco="$1";;
-i) shift;_find="$1";;
-j) _fjoi=1;;
-l) _flin=$'\n';;
-m) _flin=$'\n';_fmul=1;;
-n) _aopt=1;;
-p) _ffmt=1;;
-v) shift;_fsav=1;local -n _svar="$1";;
-w) shift;_cols="${1:-0}";[ "$_cols" = - ]&&_cols=0;;
-x) shift;_fexp="$1"
if [ "${2::1}" != - ];then
_cexp="$2";shift
fi;;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_aopt" ];then
_aopt="${CEN_EMBED:-$CEN_NAME}: "
[ "$CEN_AUTOIND" = 2 ]&&_sind=1;CEN_AUTOIND=1
[ -n "$_sind" ]&&_aopt="${_snam//?/ }"
fi
if [ $# = 0 ];then
_marr=("")
elif [ -n "$_ffmt" ];then
printf -v _marr "$@"
elif [ -n "$_fjoi" ];then
_marr="$*"
else
_marr=("$@")
fi
[ -n "$_fmul" ]&&splitjoin -d '\n' -s _marr "${_marr[@]}"
[ -n "$_find" -a "$_cols" != 0 ]&&((_cols -= _find))
[ -n "$_aopt" -a "$_cols" != 0 ]&&((_cols -= ${#_aopt}))
for _mesg in "${_marr[@]}";do
if [ -n "$_fexp" ];then
[ "$_fexp" = - ]&&_fexp="$_cols"
_nexp=$((_fexp - ${#_mesg}))
if [ "$_nexp" -gt 0 ];then
printf -v _nexp "%${_nexp}s" ""
[ -n "$_cexp" ]&&_nexp="${_nexp// /$_cexp}"
_mesg+="$_nexp"
fi
fi
case "$_deco" in
-|one) _mesg="${_mesg//[! ]/${CEN_CONS_UTF8::1}}";_deco=;;
=|two) _mesg="${_mesg//[! ]/${CEN_CONS_UTF8:1:1}}";_deco=;;
esac
while _cen_con_break "$_cols" "$_fbrk" "$_mesg" "$_flin";do
[ -n "$_deco" ] &&
decorate -d "$_deco" -s CEN_CON_BREAK_RES "$CEN_CON_BREAK_RES"
[ -n "$_find" ] &&
printf -v CEN_CON_BREAK_RES "%${_find}s%s" "" "$CEN_CON_BREAK_RES"
if [ -n "$_fsav" ];then
_svar+="$CEN_CON_BREAK_RES"
else
[ -n "$_aopt" ]&&{ echo -n "$_aopt";_aopt="${_aopt//?/ }";}
echo -n -e "$CEN_CON_BREAK_RES"
fi
done
done
return 0
}
tabulator() {
local amod=() atxt=() ncol=0 _slen _smod stxt stmp fmod frow fcol
local _balg=6 _idnt=0 _cols=-
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _cen_abort 'Not implemented' "$1";;
-b) shift;_balg="${1:--}";;
-i) shift;_idnt="${1:--}";;
-n) _cen_abort 'Not implemented' "$1";;
-w) shift;_cols="${1:--}";_cen_abort 'Not implemented' "-w $1";;
*) _cen_abort - "$1"
esac;shift
done
while [ "$#" -gt 0 ];do
_smod="$1";shift;stxt="$1";shift
_slen="${_smod%:*}";[ "$_slen" = "$_smod" ]&&_smod=||_smod="${_smod#*:}"
[ "${_slen:--}" = - ]&&_slen="${#stxt}"
[ "$_slen" = 0 ]&&continue
amod[ncol]="$_slen:${_smod:--}";atxt[ncol]="$stxt";ncol=$((ncol + 1))
done
local _llen=0 _nidx=0 _nlen;_slen=0;stxt=
for _smod in "${amod[@]}";do
_nlen="${_smod%:*}";_slen=$((_slen + _llen))
if [ "${_nlen::1}" = - ];then
_nlen="${_nlen:1}";_llen=$((_nlen + 1))
else
_llen=$((_nlen + 1));_nlen="-$_nlen"
fi
printf -v stmp "%${_nlen}s" "${atxt[_nidx]}"
[ -n "$stxt" ]&&stxt+=' ';stxt+="$stmp";_nidx=$((_nidx + 1))
[ "${_smod#*:}" = - ]&&ncol=$((ncol - 1))
done
if [ "$ncol" = 0 ];then
output -l -i "$_idnt" -b $_slen:$_balg -- "$stxt";return 0
fi
stmp=;sout=;output -b $_slen:$_balg -v sout -- "$stxt"
for _smod in "${amod[@]}";do
_slen=$((${_smod%:*}));_nidx=$((_nidx - 1))
if [ "$_nidx" = 0 ];then
decorate -a stmp -d ${_smod#*:} -m -- "$sout";break
fi
decorate -a stmp -d ${_smod#*:} -- "${sout::_slen}"
sout="${sout:_slen+1}";stmp+=' '
done
output -l -i "$_idnt" -- "$stmp"
return 0
}
CEN_CON_BREAK_MSG=
CEN_CON_BREAK_END=
CEN_CON_BREAK_RES=
_cen_con_break() {
if [ "$CEN_CON_BREAK_END" = 2 ];then
CEN_CON_BREAK_MSG=;CEN_CON_BREAK_END=
CEN_CON_BREAK_RES=;return 1
fi
local _cols="$1" _offs="$2" _sinp="$3" _suff="$4"
if [ -z "$CEN_CON_BREAK_END" ];then
[ -z "$_sinp" -a -z "$_suff" ]&&return 1
if [ "${_offs:--}" = - -o "$_cols" -lt 8 ];then
CEN_CON_BREAK_RES="$_sinp$_suff"
CEN_CON_BREAK_END=2;return 0
fi
fi
local _balg="${_offs#*:}" _idnt _ftrm _fwrd _fhyp _mlen
if [ "$_balg" != "$_offs" ];then
[ $((_balg & 1)) = 0 ]||_ftrm=1
[ $((_balg & 2)) = 0 ]||_fwrd=1
[ $((_balg & 2)) = 0 ]||_fhyp=1
_offs="${_offs%%:*}";[ -z "$_offs" ]&&_offs=0
fi
if [ "$CEN_CON_BREAK_END" = 1 ];then
_sinp="$CEN_CON_BREAK_MSG"
[ "${_sinp::1}" = ' ' ]&&[ -n "$_ftrm" ] &&
_sinp="${_sinp#"${_sinp%%[![:space:]]*}"}"
[ $((_offs + 8)) -gt "$_cols" ]&&_offs=0
_cols=$((_cols - _offs));_mlen=0
elif [ -n "$_ftrm" ];then
_mlen="$_offs";_offs=0;
[ "${_sinp::1}" = ' ' ]&&_sinp="${_sinp#"${_sinp%%[![:space:]]*}"}"
else
_mlen="$_offs";_offs=0
fi
if [ "${#_sinp}" -le "$_cols" -o "$_cols" -lt 8 ];then
printf -v CEN_CON_BREAK_RES "%${_offs}s%s$_suff" "" "$_sinp"
CEN_CON_BREAK_END=2
return 0
fi
CEN_CON_BREAK_END=1
if [ -z "$_fwrd" ];then
printf -v CEN_CON_BREAK_RES "%${_offs}s%s\n" "" "${_sinp::_cols}"
CEN_CON_BREAK_MSG="${_sinp:_cols}"
return 0
fi
local _clen _curr="${_sinp::_cols}"
if [ "${_sinp:_cols:1}" = ' ' ];then
_clen="$_cols"
else
_curr="${_curr% *}";_clen="${#_curr}"
if [ "$_clen" -le "$_mlen" ];then
_curr="${_sinp::_cols}"
if _cen_con_more;then
printf -v CEN_CON_BREAK_RES "%${_offs}s%s\n" "" "$_curr"
CEN_CON_BREAK_MSG="${_sinp}";return 0
fi
_clen=$((_cols - 1))
elif [ "$_clen" -ge "$_cols" ];then
if _cen_con_more;then
printf -v CEN_CON_BREAK_RES "%${_offs}s%s\n" "" "$_curr"
CEN_CON_BREAK_MSG="${_sinp}";return 0
fi
((--_clen))
fi
fi
_sinp="${_sinp:_clen+1}"
_cen_con_more $((_cols - _clen - 1))
printf -v CEN_CON_BREAK_RES "%${_offs}s%s\n" "" "$_curr"
CEN_CON_BREAK_MSG="${_sinp}";return 0
}
_cen_con_more() {
[ -n "$_fhyp" ]||return 1
if [ -z "$1" ];then
local _wlft="${_curr%-*}"
[ "$_wlft" = "$_curr" ]&&return 1
local _wlen="${#_wlft}"
[ "$_wlen" -ge "$_cols" ]&&return 1
_curr="$_wlft-";_sinp="${_sinp:_wlen+1}"
return 0
fi
local _ldif="$1";[ "$_ldif" -lt 2 ]&&return
local _word="${_sinp%% *}"
local _wlft="${_word%-*}"
local _wlen="${#_wlft}"
if [ "$_wlft" = "$_word" ];then
[ "$_wlen" -gt "$_ldif" ]&&return 1
_curr+=" $_wlft";_sinp="${_sinp:_wlen}"
return 0
fi
while [ "$_wlen" -ge "$_ldif" ];do
_word="${_wlft%-*}"
[ "$_word" = "$_wlft" ]&&return 1
_wlft="$_word";_wlen="${#_wlft}"
done
_curr+=" $_wlft-";_sinp="${_sinp:_wlen+1}"
return 0
}
_cen_con_mesg() {
local _eopt _hasi _fatl _fbrk _ffmt _fmul _fnnl _fxnl=$'\n' _scal _args _deco
local _verb="$CEN_VERB" _stat=0
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) shift;[ "${CEN_COLS:-0}" = 0 ]||_fbrk="$1";;
-d) shift;[ "${1::1}" = + ]||_deco="$1";;
-a) [ -n "$CEN_AUTOIND" ]&&{ _hasi=1;_args+=('-i');};;
-c) _scal=1;;
-e) _eopt="$1";_stat="$CEN_EXIT";_verb=1;;
-f) _eopt="$1";_stat="$CEN_EXIT";_verb=1;_fatl=1;;
-i|-r)
_args+=("$1");;
-l) _args+=("$1");_hasi=1;_verb=1;;
-m) _fmul=2;;
-n) _fmul=1;;
-p) _ffmt=1;;
-s) _args+=("$1");_fnnl=1;_fxnl=;;
-t) _eopt="$1";;
-w) _eopt="$1";;
*) _cen_abort -2 - "$1"
esac;shift
done
[ "$_verb" -gt 0 ]||return "$_stat"
CEN_AUTOIND=1
local _mesg _mlen _mret=:
if [ -n "$_scal" ];then
_cen_shortfmt _scal - "$1";shift
[ "$1" == '--' ]&&shift
fi
if [ -n "$_ffmt" ];then
printf -v _mesg "$@"
else
_mesg="$*"
fi
[ -n "$_scal" ]&&_mesg="${_scal:1} $_mesg"
if [ -n "$_eopt" ];then
[ -n "$_fbrk" ]&&_args+=('-b' "$_fbrk")
case "$_fmul" in
1) _cen_message $_eopt -n "${_args[@]}" -- "$_mesg";;
2) _cen_message $_eopt -m "${_args[@]}" -- "$@";;
*) _cen_message $_eopt "${_args[@]}" -- "$_mesg"
esac
return
fi
if [ -n "$_fmul" ];then
if [ "$_fmul" = 1 ];then
local _sifs="$IFS";IFS=$'\n'
_mesg="${_mesg// \\n /$IFS}";_mesg="${_mesg//\\n/$IFS}"
set -f;set -- $_mesg;set +f;IFS="$_sifs"
fi
[ -n "$_deco" ]&&_args+=('-d' "$_deco")
while [ "$#" != 0 ];do
_cen_con_mesg "${_args[@]}" -- "$1"
shift;[ -z "$_hasi" ]&&_args+=('-i');_hasi=1
done;return "$_stat"
fi
if [ -n "$_fbrk" ];then
local _snam="${CEN_EMBED:-$CEN_NAME}" _sdec
local _obrk="$((CEN_COLS - ${#_snam} - 2))"
[ -n "$_deco" ]&&_sdec="-d $_deco"
while _cen_con_break "$_obrk" "$_fbrk" "$_mesg" "$_fxnl";do
_cen_con_mesg -s $_sdec "${_args[@]}" -- "$CEN_CON_BREAK_RES"
[ -z "$_hasi" ]&&_args+=('-i');_hasi=1
done;return "$_stat"
fi
if [ -n "$CEN_CONS_MSGLEN" ];then
if [ -n "$_fatl" ];then
echo
else
_mret='echo -n -e \r'
if [ "$CEN_CONS_MSGLEN" -gt "${COLUMNS:-200}" ];then
CEN_CONS_MSGLEN=0;echo 1>&2
else
$_mret 1>&2
fi
_mlen="${#_mesg}"
[ "$CEN_CONS_MSGLEN" -gt "$_mlen" ]&&printf -v _mesg "%s%$((CEN_CONS_MSGLEN-_mlen))s" "$_mesg"
fi
CEN_CONS_MSGLEN=
[ -z "$_fnnl" ]&&_mret=:
fi
if [ -n "$_deco" ];then
decorate -d "$_deco" -s _mesg "$_mesg"
_cen_message -s "${_args[@]}" -- "$_mesg$_fxnl"
else
_cen_message "${_args[@]}" -- "$_mesg"
fi
$_mret 1>&2;return "$_stat"
}
_cen_con_prog() {
[ "${CEN_CONSOLE:-0}" = 0 ]&&return 1
local _prog="$1" _fend="$2" _flin="$3" _find="$4" _step="$5" _ftxt="$6"
shift 6
[ -n "$_step" -a -z "${_step//[0-9]/}" ]&&_prog='.'
if [ -n "$_ftxt" ];then
if [ "$_ftxt" = 2 ];then
printf -v _ftxt "$@";set -- "$_ftxt"
fi
if [ -z "$_prog" -a -z "$_step" ];then
_flin=1
else
CEN_CONS_PROGLN=1
if [ -n "${_prog//[0-9]/}" ];then
_prog="$* $_prog";set --
else
_prog=
fi
fi
elif [ -n "$_prog" -a -z "${_prog//[0-9]/}" ];then
[ -z "$*" ]&&return 0
fi
if [ -z "$_flin$_prog" ];then
_prog="$1";shift
[ -z "${_prog//[0-9]/}" ]&&prog=
fi
local _mesg="$_prog$*";_cen_compactify _mesg
local _leng="${#_mesg}"
if [ -n "$_flin" ];then
[ -n "$CEN_CONS_MSGLEN" ]||CEN_CONS_MSGLEN=0
_cen_con_mesg -s -l $_find -- "$_mesg"
CEN_CONS_MSGLEN="$_leng";CEN_CONS_PROGLN=1
elif [ -n "$_fend" ];then
[ "${CEN_CONS_MSGLEN:-0}" = 0 ]||echo "$_mesg" 1>&2
CEN_CONS_MSGLEN=;CEN_CONS_MSGTXT=;CEN_CONS_PROGLN=
elif [ "$_leng" != 0 ];then
if [ -n "$CEN_CONS_PROGLN" ];then
[ "${CEN_CONS_MSGLEN:-0}" = 0 ]||_cen_con_mesg -s -l -i
CEN_AUTOIND="$_aind";CEN_CONS_PROGLN=;CEN_CONS_MSGTXT=
fi
if [ "${CEN_CONS_MSGLEN:-0}" = 0 ];then
if [ -n "$CEN_CONS_MSGTXT" ];then
_mesg="$CEN_CONS_MSGTXT$_mesg";_leng="${#_mesg}"
fi
_cen_con_mesg -s -l $_find -- "$_mesg"
CEN_CONS_MSGLEN="$_leng";CEN_CONS_MSGTXT="$_mesg"
else
((CEN_CONS_MSGLEN += _leng));CEN_CONS_MSGTXT+="$_mesg"
echo -n "$_mesg" 1>&2
fi
elif [ -n "$CEN_CONS_MSGLEN" ];then
_cen_con_mesg -s -l -i;CEN_CONS_PROGLN=;CEN_CONS_MSGTXT=
fi
CEN_AUTOIND="$_aind"
[ -n "$_fdel" ]&&sleep "$_fdel"
return 0
}
[ -n "$CEN_CONSOLE" ]&&return
[ -n "${CEN_MODULES[_centauri_bash_win]}" ] &&
fatal $"module conflict:" '_centauri_bash_con/win'
[ -n "${CEN_MODULES[_centauri_bash_svc]}" ] &&
fatal $"module conflict:" '_centauri_bash_con/svc'
windows() { return 1;}
windialog() { error $"windialog: not available with _centauri_bash_con";}
if [ "$1" = '-i' ];then
console
elif ! [ "$1" = '-n' ];then
console -c 0
fi
:
}
_cen_bash_load_iom(){
CEN_MODULES['_centauri_bash_iom']='0.04:2'
CEN_IOM_QUEUE=()
CEN_IOM_OPT_E=
CEN_IOM_OPT_I=
CEN_IOM_OPT_R=
CEN_IOM_OPT_O=
CEN_IOM_OPT_W=
CEN_SERIALIZE=
embed -c '_centauri_bash_ext'
_cen_iom_cachedir() {
local _opts='-g' _fldr="centauri-bash-lib_${CEN_MODULES['_centauri_bash_lib']%%:*}"
if [ "$1" = '-r' ];then
shift
elif [ "$1" = '-w' ];then
shift;_opts='-f -m -r'
fi
folder $_opts -s "$1" -u 'cache' -- "$_fldr"
}
CEN_IOM_ERROR=
_cen_iom_error() {
if [ -n "$CEN_IOM_ERROR" ];then
shift
optarg "${CEN_IOM_ERROR%%=*}" "${CEN_IOM_ERROR#*=}" -e "$1"
elif [ $# -le 2 ];then
$1 "$2"
else
$1 "$2:" "${@:3}"
fi
}
inpdata() {
local _oerr='error -z' _anam _func _hndl _oinp _orun _stat=0 _file _coun
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-a) shift;_anam="$1";;
-c) shift;_func="$1";;
-f) _oerr='fatal';;
-h) shift;_hndl="$1";;
-l) _oinp+=('-l');;
-q) _oerr="$CEN_TRACE";;
-r) _orun='-r';;
-x) shift;_oinp+=('-x' "$1");;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_func" ];then
isfunction -a -- "$_func"
elif [ -z "$_anam" ];then
_cen_abort + '-a | -r'
fi
[ -n "$_hndl" -a -n "$1" ]&&_cen_abort - '-h'
[ -z "$_hndl" ]&&_file="${1:--}"
if [ "$_file" = - ];then
_hndl=0
elif [ "$_file" = + -a -n "$_oinp" ];then
inpfile $_orun -s _file "${_oinp[@]}" +||return 1
fi
if [ -n "$_hndl" ];then
if ! dryrun $_orun "mapfile -u $_hndl $_anam";then
_cen_iom_reader "$_hndl" - "$_oerr" "$_anam" "$_func"||_stat=$?
fi
elif [ -r "$_file" ];then
if ! dryrun $_orun "mapfile $_anam <$_file";then
_cen_iom_reader - "$_file" "$_oerr" "$_anam" "$_func" <"$_file"||_stat=$?
fi
else
$_oerr $"Not a readable file:" "$_file";_stat=1
fi
return $_stat
}
_cen_iom_reader() {
local _stat=0 _rarg _rmsg="$2" _oerr="$3" _anam="$4" _func="$5"
if [ -n "$_anam" ];then
local -n _vrdr="$_anam";_vrdr=()
fi
if [ "$1" != - ];then
_rarg="-u $1";_rmsg="#$1"
fi
if [ -n "$_func" ];then
local _line
while IFS= read $_rarg -r _line;do
$_func "$_line"
case $? in
0) [ -n "$_anam" ]&&_vrdr+=("$_line");;
1);;
2) return 0;;
*) return 3;;
esac
done
return 0
else
if mapfile -t $_rarg $_anam 2>/dev/null;then
eval _coun=\${#$_anam[@]}
$CEN_TRACE -p $"Read %s line(s) from: %s" "$_coun" "$_rmsg"
return 0
fi
_stat=1
fi
$_oerr -p $"Failed to read from: %s" "$_rmsg";return $_stat
}
CEN_INPFILE=
inpfile() {
local _fblk _fcan _fdir _femp _ffil _floo _fopt _fext _fset='CEN_INPFILE' _oerr='error -z' _stat
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) _break;;
-b) _fblk=1;;
-c) _fcan=1;;
-d) _fdir=1;;
-e) _femp=1;;
-f) _ffil=1;;
-l) _floo=1;;
-o) _fopt=1;;
-q) _oerr="$CEN_TRACE";;
-s) shift;_fset="$1";;
-x) shift;_fext="$1";;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fblk$_fdir" ]&&_ffil=1
_cen_inpfile() {
local -n _varg="$_fset";_varg="$1"
if [ "$_varg" = + ];then
if isfunction -c windows;then
if [ -n "$_fdir" ];then
windialog -k getexistingdirectory -t $"Select an input folder" "$PWD"
else
local _xext ; [ "${_fext:--}" != '-' ] && printf -v _xext \
                        "*.%s (*.%s);; %s (*.*)" "$_fext" "$_fext" $"All files"
windialog -k getopenfilename -t $"Select an input file" "$PWD" "$_xext"
fi
if [ $? = 0 ];then
_varg="$CEN_CONFIRM"
else
_varg=
[ -n "$_fopt" ]&&return 1;return 2
fi
else
local _dext _mesg=$"Please enter an input path"
[ "$_fdir:$_ffil" = ':1' ]&&_mesg=$"Please enter an input file name"
[ "$_fdir:$_ffil" = '1:' ]&&_mesg=$"Please enter an input folder name"
[ -n "$_fblk" ]&&_mesg=$"Please enter a device name"
[ -n "$_fext" ]&&_dext=$"Default extension"": $_fext"
confirm -m -p - -s "$_fset" -u "$_mesg" "$_dext" \
                        $"Current folder"": $PWD" || return 2
fi
fi
if [ -z "$_varg" ];then
[ -n "$_fopt" ]&&return 0
_cen_iom_error "$_oerr" $"No input path specified";return 1
fi
if [ "$_varg" = - ];then
_varg='/dev/stdin';return 0
elif [ -n "$_fext" ];then
suffixpath -d -s "$_fset" -- "$_fext"
fi
[ "${_varg::7}" = 'file://' ]&&_varg="${_varg:7}"
[ -n "$_fcan" -a "${_varg::2}" != '//' ]&&prettypath -c -s "$_fset" -- "$_varg"
if [ -n "$_fblk" ];then
if [ ! -b "$_varg" ];then
[ "${_varg::2}" = '//' ]&&return 0
if [ "${_varg%.iso}" != "$_varg" ];then
[ -r "$_varg" ]&&return 0
_mesg=$"Input file not readable"
else
_mesg=$"Input is not a device"
fi
else
[ -r "$_varg" ]&&return 0
_mesg=$"Device is not readable"
fi
elif [ -d "$_varg" ];then
[ "$_varg" = / ]||_varg="${_varg%/}"
[ -n "$_fdir" ]&&return 0
_mesg=$"Input cannot be a folder"
elif [ -z "$_ffil" ];then
_mesg=$"Input must be an existing folder"
elif [ -r "$_varg" ];then
[ -n "$_femp" ]&&return 0
[ -s "$_varg" ]&&return 0
_mesg=$"Input file is empty"
elif [ -e "$_varg" ];then
_mesg=$"Input file not readable"
else
_mesg=$"Input file not found"
fi
_cen_iom_error "$_oerr" "$_mesg" "$_varg";return 1
}
[ "$1" = + ]||_floo=
while :;do
_cen_inpfile "$1";_stat=$?
[ "$_stat" = 1 ]||return $_stat
[ -z "$_floo" ]&&return 1
done
}
outdata() {
local _oerr='error -z' _anam _hndl _oind _oloo='-a' _oout _orun _stat=0 _file _line
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-a) _oind=1;[ -z "$CEN_AUTOIND" ]&&_oind=2;;
-f) _oerr='fatal';;
-h) shift;_hndl="$1";;
-i) _oind=1;;
-l) _oloo+=' -l';;
-o) shift;_anam="$1";;
-q) _oerr="$CEN_TRACE";;
-r) _orun='-r';;
-t) _oout+=('-t');;
-x) shift;_oout+=('-x' "$1");;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_anam" ]&&_cen_abort + '-o'
[ -n "$_hndl" -a $# -gt 0 ]&&_cen_abort - '-h'
_file="$1"
[ -z "$_hndl" -a -z "$_file" ]&&_hndl=2
if [ "$_file" = - ];then
_hndl=1
elif [ -z "$_hndl" ];then
outfile $_orun -s _file $_oloo "${_oout[@]}" "$_file"||return 1
fi
dryrun -s $_orun 'outdata:' "$_file"&&return 0
local -n _vwrt="$_anam"
[ "${#_vwrt[@]}" -gt 0 ]||return 0
if [ -n "$_oind" ];then
CEN_AUTOIND=1
local _snam="${CEN_EMBED:-$CEN_NAME}: "
local _sind="${_snam//?/ }"
[ "$_oind" = 1 ]&&_snam="$_sind"
fi
if [ -n "$_hndl" ];then
for _line in "${_vwrt[@]}";do
printf '%s\n' "$_snam$_line"||{ _stat=1;break;}
_snam="$_sind"
done >&$_hndl 2>/dev/null
_line="#$_hndl"
elif [ -w "$_file" ];then
for _line in "${_vwrt[@]}";do
printf '%s\n' "$_line"||{ _stat=1;break;}
done >>"$_file" 2>/dev/null
_line="$_file"
else
$_oerr $"Not a writable file:" "$_file";return 1
fi
if [ "$_stat" = 0 ];then
$CEN_TRACE -p $"Wrote %s line(s) to: %s" "${#_vwrt[@]}" "$_line"
else
$_oerr -p $"Failed to write to: %s" "$_line"
fi
return $_stat
}
CEN_OUTFILE=
outfile() {
local _fcan _fexi _ffil _fdir _floo _fopt _fext _fook _frun _ftru \
          _fset="CEN_OUTFILE" _oerr='error -z' _stat
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-a) _fook=1;;
-c) _fcan=1;;
-d) _fdir=1;;
-e) _fexi=1;;
-f) _ffil=1;;
-l) _floo=1;;
-o) _fopt=1;;
-q) _oerr="$CEN_TRACE";;
-r) _frun='-r';;
-s) shift;_fset="$1";;
-t) _ftru=1;;
-x) shift;_fext="$1";;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fdir" ]&&_ffil=1
_cen_outfile() {
local -n _varg="$_fset";_varg="$1"
if [ "$_varg" = + ];then
if isfunction -c windows;then
if [ -n "$_fdir" ];then
windialog -k getexistingdirectory -t $"Select an output folder" "$PWD"
else
local _xext ; [ "${_fext:--}" != '-' ] && printf -v _xext \
                        "*.%s (*.%s);; %s (*.*)" "$_fext" "$_fext" $"All files"
windialog -k getsavefilename -t $"Select an output file" "$PWD" "$_xext"
fi
if [ $? = 0 ];then
_varg="$CEN_CONFIRM";_fook=1
else
_varg=
[ -n "$_fopt" ]&&return 1;return 2
fi
else
local _dext _dtyp=$"Please enter an output path"
[ "$_fdir:$_ffil" = ':1' ]&&_dtyp=$"Please enter an output file name"
[ "$_fdir:$_ffil" = '1:' ]&&_dtyp=$"Please enter an output folder name"
[ -n "$_fext" ]&&_dext=$"Default extension"": $_fext"
confirm -m -p - -s "$_fset" -u "$_dtyp" "$_dext" \
                        $"Current folder"" '$PWD'" || return 2
fi
fi
if [ -z "$_varg" ];then
[ -n "$_fopt" ]&&return 2
_cen_iom_error "$_oerr" $"No output path specified";return 2
fi
if [ "$_varg" = - ];then
_fexi=1;_varg='/dev/stdout';return 0
elif [ -n "$_fext" ];then
suffixpath -d -s "$_fset" -- "$_fext"
fi
[ "${_varg::7}" = 'file://' ]&&_varg="${_varg:7}"
if [ -n "$_fcan" ];then
prettypath -c -s "$_fset" -- "$_varg"
fi
if [ -d "$_varg" ];then
[ -n "$_fdir" ]&&return 0
_cen_iom_error "$_oerr" $"Output cannot be a folder" "$_varg";return 1
elif [ -z "$_ffil" -a -n "$_fexi" ];then
_cen_iom_error "$_oerr" $"Output must be an existing folder" "$_varg";return 1
fi
if [ -s "$_varg" -a ! -c "$_varg" ];then
if ! [ -n "$_fexi" -o -n "$_fook" -o -n "$CEN_OPT_DRYRUN" ];then
confirm -n $"Overwrite existing output file" "'$_varg'" || return 2
fi
elif [ -n "$_fexi" ];then
_cen_iom_error "$_oerr" $"Output file does not exist" "$_varg";return 1
fi
local _ochk="$_varg"
if ! [ -e "$_varg" ];then
prettypath -b -s _ochk -- "$_varg"||return 1
fi
if [ -w "$_ochk" ];then
if [ -n "$_ftru" ];then
create $_frun -t -- "$_varg"||return 1
fi
_floo=;return 0
fi
_cen_iom_error "$_oerr" $"Output not writable" "$_varg";return 1
}
[ "$1" = + ]||_floo=
while :;do
_cen_outfile "$1";_stat="$?"
[ "$_stat" = 1 ]||return $_stat
[ -z "$_floo" ]&&return 1
done||:
}
CEN_CACHEFILE=
cachefile() {
$CEN_DEBUG -c -- "$*"
local _fwri _ferr _fglo=1 _fpri=1 _fqui _fsrc _fdef _spri _scfg
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-d) _fdef=1;;
-f) _ferr='-f';;
-g) _fpri=;_spri='-g';;
-p) _fglo=;_spri='-p';;
-q) _ferr='-q';_fqui='-q';;
-r) _fwri=;;
-s) _fscr=1;;
-w) _fwri=1;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fglo" -a -z "$_fpri" ]&&_cen_abort - '-g -p'
CEN_CACHEFILE=
local _cfil="${1:--}";[ "$_cfil" = - ]&&_cfil="$CEN_NAME.dat"
if [ -n "$2" ];then
[ -n "$_fpri" -a -z "$_fdef" ]&&_scfg='-p'
configfile $_fqui $_scfg -i true -n "$2"
if cachefile $_ferr $_spri -- "$_cfil";then
if [ "$CEN_CACHEFILE" -nt "$CEN_CONFIGFILE" ];then
[ -n "$_fscr" ]&&serialize $_ferr -r -n "$CEN_CACHEFILE"
return 0
fi
fi
[ -z "$_fwri" ]&&return 1
cachefile $_ferr $_spri -w -- "$_cfil"
if [ "$CEN_CACHEFILE" -nt "$CEN_CONFIGFILE" ];then
[ -n "$_fscr" ]&&serialize $_ferr -r -n "$CEN_CACHEFILE"
return 0
fi
return 1
fi||:
if [ "${_cfil/\//}" != "$_cfil" ];then
prettypath $_ferr -s CEN_CACHEFILE -- "$_cfil"
[ -n "$_fwri" ]&&return 0
[ -r "$CEN_CACHEFILE" ];return
fi
if [ -n "$_fglo" ];then
folder $_ferr -s CEN_CACHEFILE -g -b persistent -- "$_cfil"
if [ -n "$_fwri" ];then
[ "$EUID" = 0 ]&&return 0
elif [ -r "$CEN_CACHEFILE" ];then
return 0
fi
fi
if [ -n "$_fpri" ];then
if [ -n "$_fwri" ];then
_cen_iom_cachedir -w CEN_CACHEFILE;CEN_CACHEFILE+="/$_cfil"
return 0
fi
_cen_iom_cachedir CEN_CACHEFILE;CEN_CACHEFILE+="/$_cfil"
[ -r "$CEN_CACHEFILE" ]&&return 0
fi||:
return 1
}
CEN_CONFIGFILE=
configfile() {
$CEN_DEBUG -c -- "$*"
local _file _aflg _init _priv _rlin _read _ropt='-r' _sopt _sect=()
local _ocom _oerr _omul _oqui _ovar _orep='error -z' _otra="$CEN_TRACE"
while [ "${1::1}" = - ];do
case "$1" in
-) break;;
--) shift;break;;
-a) shift;_read="$1";_aflg=1;_ropt=;;
-c) _ocom=1;;
-e) _oerr='error -z';shift;_rlin="$1";;
-f) _oerr='fatal';shift;_rlin="$1";;
-i) shift;_init="$1";;
-l) shift;_read="$1";_rlin=1;;
-m) _omul=1;;
-n) shift;_file="$1";;
-p) _priv=1;;
-q) _orep="$CEN_TRACE";_oqui='-q';;
-r) shift;_read="$1";;
-s) _sopt="$1";_otra=:;;
-v) _ovar=1;;
-x) _ocom=2;;
-w) _oerr='warning';shift;_rlin="$1";;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_oerr" ];then
[ -n "$_read" ]&&_cen_abort - '-a|-l|-r'
elif [ "$_read" = '.' ];then
[ -z "$_rlin" -o -n "$_aflg" ]&&_cen_abort - '-a|-r'
_rlin=
elif [ -n "$_ovar" ];then
[ -n "$_aflg" ]&&_cen_abort - '-a'
[ -z "$_read" ]&&_cen_abort + '-l'
local -n _vvar="$_read";_vvar=()
elif [ -n "$_read" ];then
isfunction -a -x "$_read"
fi||:
if [ -n "$_oerr" ];then
[ -z "${CEN_CONFIGFILE[2]}" ]&&_cen_abort $"not in callback" '-e|-f|-w'
[ "${_rlin:--}" = - ]&&_rlin=$"configfile"
if [ "$#" = 0 ];then
[ -z "$_oqui" ]&&set -- $"invalid statement:" "${CEN_CONFIGFILE[1]}"
else
local _cen_configfile_mesg="$1$2$3"
if [ -z "${_cen_configfile_mesg//[-+0-9]/}" ];then
arguments -I _cen_configfile_mesg "${3:-0}" "${1:-0}" "${2:-+}"&&return 0
set -- "$_cen_configfile_mesg:" "${CEN_CONFIGFILE[1]}"
fi
fi
if [ "${CEN_CONFIGFILE[2]:--}" = - ];then
$_oerr -n -p $"%s [file='%s']\n%s" "$_rlin" "${CEN_CONFIGFILE[0]}" "$*"
else
$_oerr -n -p $"%s [file='%s' line=%s]\n%s" "$_rlin" \
                "${CEN_CONFIGFILE[0]}" "${CEN_CONFIGFILE[2]}" "$*"
fi
return 1
fi
_cen_configfile_fltr() {
[ "${#_sect[@]}" = 0 ]&&return 1
_line="${_line%% *}"
[ "${_line//[[:alnum:]_-]/}" = '[]' ]||return 1
local _item _snam="${_line:1:-1}"
for _item in "${_sect[@]}";do
[ "$_snam" = "$_item" -o "$_item" = '*' ]||continue
CEN_CONFIGFILE[3]="$_snam";_skip=
[ -z "$_omul" ];return
done
CEN_CONFIGFILE[3]=
_skip=1;return 0
}
_cen_configfile_call() {
local _stat=0
CEN_CONFIGFILE[1]="$_line";CEN_CONFIGFILE[2]="$_lnum"
if [ "$_ocom" = 2 ];then
local _cen_config_lin
if ! spliteval -q -s _cen_config_lin -- "$_line";then
_stat=2
[ -z "$_oqui" ]&&configfile -e - $"syntax error:" "$_line"
fi
_line="$_cen_config_lin"
elif [ -n "$_ocom" ];then
local _comp
_line="${_line//[[:space:]]/ }"
while [ "$_comp" != "$_line" ];do
_comp="$_line"
_line="${_line//   / }"
_line="${_line//  / }"
done
fi
if [ -n "$_aflg" ];then
local _args;set -f
if ! eval _args=("$_line") &>/dev/null;then
set +f;_stat=2
[ -z "$_oqui" ]&&configfile -e - $"syntax error:" "$_line"
else
set +f;$_read "${_args[@]}"||_stat=$?
fi
elif [ -n "$_ovar" ];then
_vvar+=("$_line")
else
$_read "$_line"||_stat=$?
fi
CEN_CONFIGFILE[1]=;CEN_CONFIGFILE[2]=
return $_stat
}
_cen_configfile_init() {
if [ -z "$_init" ];then
$_orep $"Configuration file not found:" "$_file"
return 1
fi
isfunction -a -x -c $_init "$_file"
}
CEN_CONFIGFILE=();_sect=("$@")
[ "${_file:--}" = - ]&&_file="$CEN_NAME"
if [ "$_file" = "${_file/\//}" ];then
local _locf _loci _locs=()
[ -n "$_priv" ]&&_locs=( ~/.config/ ~/.local/ ~/. )
folder $_oqui -s _loci -b default&&_locs+=("$_loci/")
for _loci in "${_locs[@]}" '';do
if [ -z "$_loci" ];then
_cen_configfile_init;return
fi
_locf="$_loci$_file"
[ -e "$_locf" ]||continue
_file="$_locf";break
done
elif [ ! -e "$_file" ];then
_cen_configfile_init;return
fi||:
if [ ! -r "$_file" ];then
$_orep $"Configuration file not readable:" "$_file"
return 1
elif [ -d "$_file" ];then
$_orep $"Configuration path is a folder:" "$_file"
return 1
elif [ -z "$_read" ];then
CEN_CONFIGFILE[0]="$_file";return 0
fi
local _fhan _join _line _lnum=0 _skip _stat=0
redirect $_oqui -s -v _fhan -i "$_file"||return 1
_file="$CEN_REDIRECT";CEN_CONFIGFILE[0]="$_file"
if [ -n "$_rlin" -o "${_read:-.}" != '.' ];then
$_otra -a -c $" read" -- "$_file [$*]"
[ "${#_sect[@]}" = 0 ]||_skip=1
if [ -n "$_rlin" ];then
while IFS= read -r -u $_fhan _line;do
((_lnum += 1))
if [ "${#_sect[@]}" != 0 ];then
if [ "${_line::1}" = '[' ];then
_cen_configfile_fltr&&continue
fi
[ -n "$_skip" ]&&continue
fi
_cen_configfile_call&&continue
_stat=$?;break
done
else
while read $_ropt -u $_fhan _line;do
((_lnum += 1))
if [ -n "$_join" ];then
_line="$_join$_line";_join=
fi
[ "${_line::1}" = '#' ]&&continue
_line="${_line% #*}"
[ -z "${_line//[[:space:]]/}" ]&&continue
if [ "${_line%\\}" != "$_line" ];then
_join="${_line%\\}";continue
fi
if [ "${_line::1}" = "[" ];then
_cen_configfile_fltr&&continue
fi
[ -n "$_skip" ]&&continue
_cen_configfile_call&&continue
_stat=$?;break
done
fi
else
$_otra -a -c $" load" -- "$_file"
true;. "$_file";_stat=$?
[ "$_stat" = 0 ]||error $"Invalid data in configuration file:" "$_file"
fi
redirect $_oqui -s -v _fhan
return $_stat
}
serialize() {
$CEN_DEBUG -c -- "$*"
local _fdel _fdec _fmod _fref _fzer _fqui _mode
local _ffil="$CEN_NAME.dat" _oerr='error -z' _otra="$CEN_TRACE -a"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-f) _oerr='fatal';;
-d) _fdel=1;;
-m) shift;_mode="$1";;
-n) shift;_ffil="$1";;
-q) _oerr="$CEN_TRACE";_fqui='-q';;
-r|-w)
_fmod="$1";;
-s) _otra=:;;
-t) shift;_fref="$1";;
-z) _fzer=1;;
-x) _fdec=1;;
*) _cen_abort - "$1"
esac;shift
done
local _fhan _item
CEN_SERIALIZE=
if [ "${_ffil/\//}" = "$_ffil" ];then
_cen_iom_cachedir $_fmod _item;_ffil="$_item/$_ffil"
else
prettypath -s _ffil -- "$_ffil"
fi
[ -n "$_fref " ]&&[ "$_fref" -nt "$_ffil" ]&&return 1
CEN_SERIALIZE="$_ffil"
if [ "$_fmod" = '-w' ];then
local _sout _sser
for _item in "$@";do
local -n _varg="$_item"
_sser="${_varg[@]@A}"
if [ -z "$_fdec" ];then
case "$_sser" in
'') _item="$_item=";;
declare\ -?\ *=*) _item="${_sser:11}";;
declare\ -a\ *) _item="${_sser:11}=()";;
declare\ -?\ *) _item="${_sser:11}=";;
*=*) _item="$_sser";;
*)  _item="$_sser="
esac
else
_item="${_sser:-$_item=}"
fi
_sout+="$_item";_sout+=$'\n'
done
dryrun "serialize: $_ffil"&&return
create $_fqui -v _sout -h - -s -t -- "$_ffil" $_mode||return 1
$_otra -c $" write" -- "$_ffil"
elif [ "$_fmod" = '-r' ];then
if [ -r "$_ffil" ];then
local _trap="$CEN_QUIT_TRAP";CEN_QUIT_TRAP=
. $_ffil &>/dev/null
CEN_QUIT_TRAP="$_trap"
if [ $? = 0 ];then
$_otra -c $" read" -- "$_ffil"
else
$_oerr $"Failed to deserialize data from:" "$_ffil"
return 1
fi
elif [ -n "$_fqui" ];then
$CEN_TRACE -c $" missing" -- "$_ffil";return 1
else
$_oerr $"Cannot deserialize data from:" "$_ffil";return 1
fi||true
fi
if [ -n "$_fzer" ];then
for _item in "$@";do
local -n _vvar="$_item"
[ ${#_vvar[@]} -gt 1 ]&&_vvar=()
[ ${#_vvar[@]} = 1 ]&&_vvar=
done
fi
if [ -n "$_fdel" ];then
remove $_fqui -- "$_ffil"||return 1
fi
return 0
}
spliteval() {
local _oinp _oset _oerr=error _oglo _onoe _oset _stat=0
local -n _vvei _vveo
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a|-u)
_oset="$1";shift;_vveo="$1";_vveo=();;
-g) _oglo=1;;
-i) shift;_oinp=1;_vvei="$1";;
-n) _onoe=1;;
-q) _oerr="$CEN_TRACE";;
-s) _oset="$1";shift;_vveo="$1";_vveo=;;
-w) _oerr=warning;;
*) _cen_abort - "$1"
esac;shift
done
[ -n "$_oinp" ]&&set -- "${_vvei[@]}"
if [ "$_oset" = '-u' ];then
if [ -n "$_oglo" ];then
eval _vveo=("$*");_stat=$?
else
set -f;eval _vveo=("$*");_stat=$?;set +f
fi 2>/dev/null
[ "$_stat" = 0 ]&&return 0
_vveo=("$*")
$_oerr $"Syntax error:" "$_vveo";return 1
fi
[ -z "$_oset" ]&&_cen_abort = '-a|-s|-u'
local _line _item _ugly _args=()
[ -z "$_oglo" ]&&set -f
for _item in "$@";do
if [ -n "$_onoe" ];then
_args+=("$_item")
else
if [ "$_item" != "${_item/[(|)]/}" ];then
_item="${_item//|/\\|}";_item="${_item//(/\\(}"
_item="${_item//)/\\)}";_ugly=1
fi
if ! eval _args+=("$_item") 2>/dev/null;then
[ -z "$_oglo" ]&&set +f
$_oerr $"Syntax error:" "$_item"
_args+=("$_item");_stat=1
fi
fi
done
[ -z "$_oglo" ]&&set +f
for _item in "${_args[@]}";do
if [ -n "$_ugly" ];then
_item="${_item//\\\|/|}";_item="${_item//\\\(/(}"
_item="${_item//\\\)/)}"
fi
if [ "$_oset" = '-a' ];then
_vveo+=("$_item")
continue
fi
case "$_item" in
'')     _item="''" ;;
*[![:alnum:]]*)
[ -n "${_item//[[:alnum:]-+=_.:@\/\[\]]/}" ]&&_item="${_item@Q}";;
esac
[ -z "$_line" ]&&_line="$_item"||_line+=" $_item"
done
[ "$_oset" = '-s' ]&&_vveo="$_line"
return $_stat
}
_cen_optarg_iom() {
if [ $# != 1 ];then
CEN_IOM_QUEUE+=("$1"$'\t'"$2"$'\t'"$3"$'\t'"$CEN_ACTARR")
return 0
fi
local _emsg _opta _optf _argo;splitjoin -s _argo -- "$1"
CEN_IOM_ERROR="${_argo[1]}=${_argo[3]}"
case "${_argo[0]}" in
-a|-w)
[ -n "$CEN_OPT_FORCE" -o "${_argo[0]}" = a ]&&_opta='-a'
outfile $_opta -c -l -s _optf -- "${_argo[3]}"
case $? in
0) optarg "${_argo[1]}" "${_argo[2]}" -t "$_optf";;
1) quit;;
*) _emsg=$"No output path provided"
esac
;;
-d) outfile -c -l -d -e -s _optf -- "${_argo[3]}"
case $? in
0) optarg "${_argo[1]}" "${_argo[2]}" -t "$_optf";;
1) quit;;
*) _emsg=$"No folder path provided"
esac
;;
-s) inpfile -c -l -d -e -s _optf -- "${_argo[3]}"
case $? in
0) optarg "${_argo[1]}" "${_argo[2]}" -t "$_optf";;
1) quit;;
*) _emsg=$"No folder path provided"
esac
;;
*) inpfile $CEN_IOM_OPT_E -c -l -s _optf -- "${_argo[3]}"
case $? in
0) optarg "${_argo[1]}" "${_argo[2]}" -t "$_optf";;
1) quit;;
*) _emsg=$"No input path provided"
esac
;;
esac
CEN_IOM_ERROR=
[ -z "$_emsg" ]&&return 0
optarg "${_argo[1]}" "${_argo[3]}" -e "$_emsg";return 1
}
_cen_iom_option() {
case "$1" in
"")
local _item
for _item in "${CEN_IOM_QUEUE[@]}";do
_cen_optarg_iom "$_item"||break
done;CEN_IOM_QUEUE=()
;;
--help)
[ "$2" = 'opts' ]&&_cen_iom_add_opts;;
-i|--inp*)
[ -n "$CEN_IOM_OPT_I" ]&&optarg 'input' CEN_INPFILE -r;;
-o|--out*)
[ -n "$CEN_IOM_OPT_O" ]&&optarg 'output' CEN_OUTFILE -w;;
-r|--rea|--read)
[ -n "$CEN_IOM_OPT_R" ]&&optarg 'input' CEN_INPFILE -r;;
-w|--wri*)
[ -n "$CEN_IOM_OPT_W" ]&&optarg 'output' CEN_OUTFILE -w;;
esac||:
$CEN_IOM_HOOK_OPTIONS "$@"
}
_cen_iom_add_opts() {
[ -n "$CEN_IOM_OPT_I" ]&&_cen_use_option '-i' '--input   <file>' $"Open file for input"
[ -n "$CEN_IOM_OPT_O" ]&&_cen_use_option '-o' '--output  <file>' $"Open file for output"
[ -n "$CEN_IOM_OPT_R" ]&&_cen_use_option '-r' '--read    <file>' $"Open file for reading"
[ -n "$CEN_IOM_OPT_W" ]&&_cen_use_option '-w' '--write   <file>' $"Open file for writing"
}
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-e) CEN_IOM_OPT_E='-e';;
-i) CEN_IOM_OPT_I=1;;
-o) CEN_IOM_OPT_O=1;;
-r) CEN_IOM_OPT_R=1;;
-w) CEN_IOM_OPT_W=1;;
esac;shift
done
CEN_IOM_HOOK_OPTIONS="$CEN_HOOK_OPTIONS"
CEN_HOOK_OPTIONS=_cen_iom_option
:
}
_cen_bash_load_pro(){
CEN_MODULES['_centauri_bash_pro']='0.03:2'
embed -c '_centauri_bash_utl'
CEN_PROGRESS=
progress() {
[ $# = 0 ]&&_fend=0
local _prog _fdel _fend _flin _find _ftxt _step _work _stat=0 _aind="$CEN_AUTOIND"
while [ "${1::1}" = - ];do
case "$1" in
-) break;;
--) shift;break;;
-a) _find='-a';;
-c) shift;_prog="$1";;
-d) shift;[ -n "$CEN_OPT_DRYRUN" ]&&_fdel="$1";;
-e) _fend=1;;
-i) _find='-i';;
-l) _flin=1;;
-p) _ftxt=2;;
-s) shift;_step="$1";;
-t) _ftxt=1;;
-v) [ "$CEN_VERB" -gt 1 ]&&CEN_PROGRESS=0;;
-w) shift;_work="$1";;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$CEN_PROGRESS" ];then
if [ -n "$CEN_PAGER" -o "$CEN_VERB" -lt 1 -o "$CEN_CONSOLE" = 0 ];then
CEN_PROGRESS=0
elif [ "$CEN_OPT_GUI" = 0 ];then
_stat=1
trace -c ' disabled' 'option --gui=0'
elif [ -z "${CEN_MODULES["_centauri_bash_win"]}" ] ; then
console||_stat=$?
elif [ -z "$CEN_WINDOWS" ];then
windows||_stat=$?
fi
if [ "$_stat" != 0 ];then
CEN_PROGRESS=0
[ -z "$_work" ]&&return $_stat
fi
fi
if [ "$CEN_PROGRESS" != 0 ];then
[ -z "$_fend" ]&&CEN_PROGRESS=2||CEN_PROGRESS=1
fi
[ "$_fend" = 0 ]&&_fend=
if [ -z "$_ftxt" ]&&[ "${CEN_NOBREAK:-2}" = 2 ]&&[ -z "$CEN_WINDOWS" ];then
local _text="$*";_cen_compactify _text;set -- "$_text"
fi
if [ -n "$_work" ];then
local _mini="${_step#*:}";[ "$_mini" = "$_step" ]&&_mini=1
[ "$CEN_PROGRESS" = 0 ]&&_mini=0
_cen_pro_work "$_work" "$_fdel" "${_step%:*}" "$_mini" "$_prog" "$_text"||_stat=$?
elif [ "$CEN_PROGRESS" != 0 ];then
if [ -n "$CEN_WINDOWS" ];then
_cen_win_prog "$_prog" "$_fdel" "$_fend" "$_flin" "$_step" "$_ftxt" "$@"||_stat=$?
else
_cen_con_prog "$_prog" "$_fend" "$_flin" "$_find" "$_step" "$_ftxt" "$@"||_stat=$?
[ -n "$_fdel" ]&&timer -w "$_fdel"
fi
fi
return "$_stat"
}
_cen_pro_work() {
local _work="$1" _fdel="$2" _totl="$3" _mini="${4:-0}" _frmt="$5" _text="$6" _done="$7"
[ "$_frmt" = - ]&&_frmt=$"%s of %s"
[ "$_text" = - ]&&_text=
isfunction -a -- "$_work"
local _perc _mesg _epoc _curr=0 _plst=0 _stat=0
[ "$_totl" -le "$_mini" -o "$_mini" = 0 ]&&_plst=
[ -n "$CEN_CONSOLE" ]&&context -t +
while [ "$_curr" -lt "$_totl" ];do
_perc=$((_curr++ * 100 / _totl))
if [ -n "$_plst" -a "$_curr" -ge "$_mini" ];then
[ "$_perc" -gt '99' ]&&_perc=99
if [ "$_perc" -gt "$_plst" -o "$EPOCHSECONDS" != "$_epoc" ];then
_epoc="$EPOCHSECONDS";_plst="$_perc"
printf -v _mesg -- "$_frmt" "$_curr" "$_totl"
progress -a -c "$_perc" -t "$_text" "$_mesg"
fi
fi
$_work "$_curr"||_stat=$?
[ "$_stat" = 0 ]||break
[ -n "$_fdel" ]&&timer -w "$_fdel"
done
if [ -n "$_plst" ];then
if [ "${_done:--}" != - ];then
progress -a -c 100 -t "$_text" "$_done"
timer -w 0.5
else
progress -a -c 100
fi
fi
$_work 0||_stat=$?
[ -n "$_fdel" ]&&timer -w "$_fdel"
[ -n "$CEN_CONSOLE" ]&&context -t -
return "$_stat"
}
_cen_pro_quit() {
[ "${CEN_PROGRESS:-0}" -gt 1 ]&&progress
}
:
}
_cen_bash_load_txt(){
CEN_MODULES['_centauri_bash_txt']='0.03:2'
CEN_TXT_SORT=
CEN_TXT_UNIQ=
CEN_TXT_GREP=
txtsort() {
local _ffat _fqui _fmax=15 _frev _farr _leng _xopt _stat=0
local _vinp _vout='-s -' _vsys _cen_sort_aarg
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_farr="$1";_vout="-s $1";_vsys="-a $1";;
-f) _ffat='-f';;
-i) shift;_vinp="$1";;
-m) shift;_fmax="$1";;
-n) _xopt='-o -n';;
-q) _fqui='-q';;
-r) _frev='-r';;
-s) shift;_vout="-j $1 -d \n";_vsys="-s $1";;
*) _cen_abort - "$1"
esac;shift
done
local -n _varr
if [ -z "$_vinp" ];then
_cen_sort_aarg=("$@")
_varr='_cen_sort_aarg';_vinp='_cen_sort_aarg'
elif [ "$_vinp" = - ];then
IFS=$'\n' read -r -d '' -a _cen_sort_aarg||true
_varr='_cen_sort_aarg';_vinp='_cen_sort_aarg'
else
_varr="$_vinp"
if [ "${#_varr[@]}" = 1 ];then
local -n _varr='_cen_sort_aarg'
splitjoin -s _cen_sort_aarg -n -i "$_vinp"
_vinp='_cen_sort_aarg'
fi
fi
_leng="${#_varr[@]}"
if [ "$_leng" -gt "$_fmax" ];then
extsort $_vsys -i "$_vinp" $_xopt $_frev $_ffat $_fqui||_stat=1;
return $_stat
fi
if [ -n "$_farr" ];then
local -n _barr="$_farr"
else
local _barr
fi
_barr=("${_varr[@]}")
local _iter _curr _next _temp _oper='>'
[ -n "$_frev" ]&&_oper='<'
for ((_iter=0;_iter < _leng;_iter++));do
if [ -n "$_xopt" ];then
for ((_curr=0;_curr < _leng-_iter-1;_curr++));do
((_next=_curr+1))
if ((${_barr[_curr]%%[!0-9]*} $_oper ${_barr[_next]%%[!0-9]*}));then
_temp="${_barr[_curr]}"
_barr[_curr]="${_barr[_next]}"
_barr[_next]="$_temp"
fi
done 2>/dev/null
else
for ((_curr=0;_curr < _leng-_iter-1;_curr++));do
((_next=_curr+1))
if [ "${_barr[_curr]}" $_oper "${_barr[_next]}" ];then
_temp="${_barr[_curr]}"
_barr[_curr]="${_barr[_next]}"
_barr[_next]="$_temp"
fi
done
fi
done
[ -z "$_farr" ]&&splitjoin $_vout -l -i _barr||true
return 0
}
extsort() {
local _ferr='-e' _fopt _frev _funi _fnam _vinp _vout='-s -' _acmd
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_fnam="$1";_vout="-a $1";;
-f) _ferr='-f';;
-i) shift;_vinp="-i $1";;
-o) shift;_fopt="$1";;
-q) _ferr='-q';;
-r) _frev='-r';;
-s) shift;_fnam="$1";_vout="-s $1";;
-u) _funi=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$CEN_TXT_SORT" ];then
sysfind ${_ferr/-q/} -s CEN_TXT_SORT -c sort||return 1
embed -m '_centauri_bash_pip'
fi
if [ -z "$_funi" ];then
_acmd=("$CEN_TXT_SORT" $_frev $_fopt)
else
_acmd=('_cen_sort_uniq')
if [ -z "$CEN_TXT_UNIQ" ];then
sysfind ${_ferr/.q/} -s CEN_TXT_UNIQ -c uniq||return 1
_cen_sort_uniq() {
set -o pipefail;"$CEN_TXT_SORT" $_frev $_fopt | "$CEN_TXT_UNIQ"
}
fi
fi
if [ -z "$_vinp" ];then
local _cen_sort_aarg=("$@");_vinp='-i _cen_sort_aarg'
fi
dryrun -r 'extsort:' "$CEN_TXT_SORT" $_frev $_fopt "${_funi:+| $CEN_TXT_UNIQ}"||true
local _sout _stat=0 _copr
[ "$CEN_PIP_BUSY" = "$BASHPID" ]||_copr='-x'
syspipe -r $_ferr $_copr -n -y $_vinp $_vout -- "${_acmd[@]}"||_stat=$?
[ "$_stat" = 0 ]&&return 0
if [ -n "$_fnam" -o "$_ferr" != '-q' ];then
splitjoin -d '\n' -i "$_fnam" -j _sout
message -a -n -- "$_sout"
fi
return $_stat
}
txtgrep() {
local _fnam _fnot _fexp _expr _vinp _vout _stop
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vout="$1";;
-i) shift;_vinp="$1";;
-m) _stop='break';;
-n) _fnot=1;;
-s) shift;_fnam="$1";;
-x) shift;_expr="$1";_fexp=1;;
-y) shift;_expr="$1";_fexp=2;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fexp" ]&&_cen_abort + '-x|-y'
[ -n "$_fnot" ]&&((_fexp += 2))
[ -z "$_vout" -a -z "$_fnam" ]&&_stop='break'
local -n _varr _rslt
local _cen_grep_aarg _txtgrep_rarg _line
if [ -z "$_vinp" ];then
_cen_grep_aarg=("$@");_varr='_cen_grep_aarg'
elif [ "$_vinp" = - ];then
IFS=$'\n' read -r -d '' -a _cen_grep_aarg;_varr='_cen_grep_aarg'
else
_varr="$_vinp"
if [ "${#_varr[@]}" = 1 ];then
local -n _varr='_cen_grep_aarg'
splitjoin -s _cen_grep_aarg -n -i "$_vinp"
fi
fi||:
if [ "$_vinp" = "$_vout" ] ||
[ "${_vout:--}" = - ];then
_txtgrep_rarg=();_rslt='_txtgrep_rarg'
else
_rslt="$_vout"
fi
_rslt=()
if [ "$_fexp" = 1 ];then
for _line in "${_varr[@]}";do
[[ "$_line" =~ $_expr ]]||continue
_rslt+=("$_line");$_stop
done
elif [ "$_fexp" = 2 ];then
for _line in "${_varr[@]}";do
[[ "$_line" == $_expr ]]||continue
_rslt+=("$_line");$_stop
done
elif [ "$_fexp" = 3 ];then
for _line in "${_varr[@]}";do
[[ "$_line" =~ $_expr ]]&&continue
_rslt+=("$_line");$_stop
done
else
for _line in "${_varr[@]}";do
[[ "$_line" == $_expr ]]&&continue
_rslt+=("$_line");$_stop
done
fi
if [ -n "$_stop" -a -z "$_vout" -a -z "$_fnam" ];then
[ "${#_rslt[@]}" = 0 ]&&return 1||return 0
fi
if [ "${_vout:--}" = - ];then
splitjoin -j "${_fnam:--}" -n -l -i _rslt
elif [ "$_vinp" = "$_vout" ];then
local -n _vslt="$_vout";_vslt=("${_rslt[@]}")
fi||:
return 0
}
extgrep() {
local _ferr='-e' _fexp _fnam _vinp _vout='-s -' _acmd=(-) _aopt
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_fnam="$1";_vout="-a $1";;
-f) _ferr='-f';;
-i) shift;_vinp="-i $1";;
-l) _acmd+=('-n');;
-m) _acmd+=('-q');;
-n) _acmd+=('-v');;
-o) shift;_aopt+=("$1");;
-q) _ferr='-q';;
-s) shift;_fnam="$1";_vout="-s $1";;
-u) _acmd+=('-i');;
-x) shift;_fexp=1;_acmd+=('-e' "$1");_acmd+=('-E');;
-y) shift;_fexp=2;_acmd+=('-e' "$1");;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fexp" ]&&_cen_abort + '-x|-y'
if [ -z "$CEN_TXT_GREP" ];then
sysfind ${_ferr/-q/} -s CEN_TXT_GREP -c grep||return 1
embed -m '_centauri_bash_pip'
fi
_acmd[0]="$CEN_TXT_GREP";_acmd+=("${_aopt[@]}")
if [ -z "$_vinp" ];then
local _cen_grep_aarg=("$@");_vinp='-i _cen_grep_aarg'
fi
dryrun -r "extgrep: ${_acmd[@]}"||true
local _sout _stat=0 _copr
[ "$CEN_PIP_BUSY" = "$BASHPID" ]||_copr='-x'
syspipe -r $_ferr -g $_copr -n -y $_vinp $_vout -- "${_acmd[@]}"||_stat=$?
[ "$_stat" = 0 ]&&return 0
if [ -n "$_fnam" -o "$_ferr" != '-q' ];then
splitjoin -d '\n' -i "$_fnam" -j _sout
message -a -n -- "$_sout"
fi
return $_stat
}
txtfold() {
local _deli _nmax _sout _frmt=:
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-d) shift;_deli="${1:--}";;
-f) shift;_frmt="$1";;
-m) shift;_nmax="$1";;
-s) shift;_sout="$1";;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_sout" -o "${_nmax:-0}" -lt 1 ]&&_cen_abort -
[ "$_deli" = - ]&&_deli=$'\n'
_cen_txt_fold "$_nmax" "$1" "$_sout"||return 1
local -n _vcur="$_sout" _vxxx="$1"
local _cen_txt_more _nmor _ncur=${#_vcur}
$_frmt "$_sout" _nmax
while :;do
_rest=$((_nmax - _ncur))
while [ "$_rest" -gt 1 ];do
_cen_txt_fold - "$1" _cen_txt_more||break
_nmor="${#_cen_txt_more}"
$_frmt _cen_txt_more _nmax
((_ncur += ${#_cen_txt_more} + 1))
[ "$_ncur" -gt "$_nmax" ]&&break
_vcur+=" $_cen_txt_more"
_vxxx="${_vxxx:_nmor+1}"
_rest=$((_nmax - _ncur - 1))
done
[ -z "$_vxxx" ]&&break
[ -z "$_deli" ]&&break
_vcur+="$_deli"
_cen_txt_fold "$_nmax" "$1" _cen_txt_more||return 1
_vcur+="$_cen_txt_more";_ncur=${#_cen_txt_more}
done
return 0
}
_cen_txt_fold() {
local _omax="$1"
local -n _vtxt="$2" _vout="$3"
if [ "$_omax" = - ];then
_vtxt="${_vtxt#"${_vtxt%%[![:space:]]*}"}"
[ -z "$_vtxt" ]&&return 1
_vout="${_vtxt%% *}"
return 0
fi
_vout="${_vtxt%%[![:space:]]*}"
local _trim=${#_vout}
_vout="${_vtxt:_trim:_omax+1}"
if [ -z "$_vout" ];then
_vtxt=;return 1
fi
local _nout=${#_vout};((_nout += _trim))
local _vtmp="${_vout%[[:space:]]}"
if [ "$_vtmp" = "$_vout" ];then
if [ $_nout -gt $_omax ];then
_vtmp="${_vout%[[:space:]]*}"
if [ "$_vtmp" = "$_vout" ];then
_vout="${_vtmp::_omax}"
else
_vout="$_vtmp"
fi
_nout=${#_vout};((_nout += _trim))
fi
else
_vout="$_vtmp"
fi
_vtxt="${_vtxt:_nout}"
_vtmp="${_vout//[[:space:]]/ }";_vtmp="${_vtmp//  / }"
while [ "$_vtmp" != "$_vout" ];do
_vout="$_vtmp"
_vtmp="${_vout//  / }"
done
_vout="${_vout%"${_vout##*[! ]}"}"
return 0
}
}
_cen_bash_load_utl(){
CEN_MODULES['_centauri_bash_utl']='0.03:1'
listsearch() {
local _fbin _fcas _fglo _finp _fwrd _fidx _frex _ftrm _funi _sdel _word _list
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) _fbin=1;;
-c) _fcas=1;;
-d) shift;_sdel="$1";;
-g) _fglo=0;;
-i) shift;local -n _vinp="$1";_finp=1;;
-n) shift;local -n _vidx="$1";_vidx=;_fidx=1;;
-m) shift;local -n _vres="$1";_vres=;_fwrd=1;;
-t) _ftrm=1;;
-u) _funi=1;;
-x) _fglo=0;_frex=1;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_fcas" ]&&_word="${1,,}"||_word="$1";shift
[ -n "$_finp" ]&&set -- "${_vinp[@]}"
if [ -n "$_sdel" ];then
splitjoin -s _list -d "$_sdel" -- "$@"
else
_list=("$@")
fi
local _ibeg=0 _iend="${#_list[@]}" _irun _curr _cwrd
for ((_irun=_ibeg;_irun<_iend;_irun++));do
_curr="${_list[_irun]}"
if [ -n "$_ftrm" ];then
_curr="${_curr%"${_curr##*[![:space:]]}"}"
_curr="${_curr#"${_curr%%[![:space:]]*}"}"
fi
_cwrd="$_curr"
[ -z "$_fcas" ]&&_curr="${_curr,,}"
if [ -n "$_fglo" ];then
[ $_fglo -ge ${#_curr} ]&&continue
if [ -n "$_frex" ];then
[[ "$_curr" =~ $_word ]]||continue
else
[[ "$_curr" == $_word ]]||continue
fi
[ -n "$_fidx" ]&&_vidx="$_irun"
[ -n "$_fwrd" ]&&_vres="$_cwrd"
_fglo=${#_curr};_funi=2
elif [ -z "$_funi" ];then
[ "$_word" = "$_curr" ]||continue
[ -n "$_fidx" ]&&_vidx="$_irun"
[ -n "$_fwrd" ]&&_vres="$_cwrd"
return 0
else
[ "${_curr#$_word}" = "$_curr" ]&&continue
[ "$_funi" = 2 ]&&return 2
[ -n "$_fidx" ]&&_vidx="$_irun"
[ -n "$_fwrd" ]&&_vres="$_cwrd"
((_funi += 1))
fi
done
[ "$_funi" = 2 ]
}
CEN_NUMBER=
number() {
local _dflt _oerr=: _orea _ouns _narg _nmin _nmax _nabs _vnam='CEN_NUMBER'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-|-[0-9]*)
break;;
-d) shift;_dflt="$1";;
-e) _oerr='error';;
-f) _oerr='fatal';;
-r) _orea=1;;
-s) shift;_vnam="$1";;
-u) _ouns=1;;
*) _cen_abort - "$1"
esac;shift
done
[ $# -gt 3 ]&&_cen_abort @
local -n _cen_txt_number="$_vnam";_cen_txt_number=-
_narg="${1:--}";_nmin="${2:--}";_nmax="${3:--}"
[ "$_narg" = - ]&&_narg="$_dflt"
_narg="${_narg%"${_narg##*[![:space:]]}"}"
_narg="${_narg#"${_narg%%[![:space:]]*}"}"
case "$_narg" in
''|-|0[0-9xX]*)
$_oerr $"Not a decimal integer number:" "$_narg";return 3;;
-*) if [ -n "$_ouns" ];then
$_oerr $"Not an unsigned decimal number:" "$_narg";return 3
fi
_nabs="${_narg:1}";;
*) _nabs="$_narg"
esac
if [ -n "$_orea" ];then
_nmin=-;_nmax=-;_nabs="${_nabs/./}"
fi
if [ -n "${_nabs//[0-9]/}" ];then
$_oerr $"Unexpected text data, not a number:" "$_narg";return 3
fi
if [ "$_nmin" != - ]&&[ "$_narg" -lt "$_nmin" ];then
$_oerr -p $"Value to small (min is %s):" "$_nmin" "$_narg";return 1
elif [ "$_nmax" != - ]&&[ "$_narg" -gt "$_nmax" ];then
$_oerr -p $"Value to large (max is %s):" "$_nmax" "$_narg";return 2
fi
_cen_txt_number="$_narg"
return 0
}
optmake() {
local _vset _name _vflg _asep _blti _fmin _valu
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vset=a;local -n _vvaa="$1";;
-b) shift;_blti="$1";;
-f) shift;_valu="$1";_vflg=0;;
-m) shift;_fmns=1;;
-j) shift;_vset=j;local -n _vvaa="$1";;
-k) shift;_name="=$1";;
-s) shift;_vset=d;local -n _vvaa="$1";_vvaa=;;
-n) shift;_name="$1";;
-v) shift;_valu="$1";_vflg=1;;
-z) shift;_valu="$1";_vflg=2;;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$_vflg" ];then
_valu="$1";_vflg=0
fi
if [ -n "$_blti" ];then
[ -n "$_name" ]&&_cen_abort - '-b|-n|-k'
_name="$_blti";_vflg=0
eval _valu="\$CEN_OPT_${_name^^}"
case "$_blti" in
dryrun|force|silent|trace|quiet|zombie)
[ -z "$_valu" ]&&return;;
gui) [ "$_valu" = 2 ]&&return
_vflg=1;;
pager) _vflg=1;;
verb*) [ "$CEN_VERB" -le 1 ]&&return;;
yesno) [ -z "$CEN_YESNO" ]&&return
[ "$CEN_YESNO" = y ]&&_name='yes'||_name='no';;
*) _cen_abort $"unknown option:" "$_blti"
esac
else
case "$_valu" in
"") return;;
-) [ -z "$_fmns" ]&&return;;
0) [ "$_vflg" = 2 ]&&return;;
esac
fi
case "$_name" in
"");;
--*) _asep=1;;
-*);;
=*) _name="${_name:1}";;
?) _name="-$_name";;
*) _name="--$_name"
esac
if [ "$_vset" = a ];then
[ -n "$_name" ]&&_vvaa+=("$_name")
[ "${_vflg:-0}" != 0 ]&&_vvaa+=("$_valu")
[ $# -gt 0 ]&&_vvaa+=("$@")
else
_valu="${_valu//\"/\\\"}"
[ -n "$_vvaa" ]&&_vvaa+=' '
[ -n "$_name" ]&&_vvaa+="$_name"
if [ "${_vflg:-0}" != 0 ];then
if [ -n "$_asep" ];then
_vvaa+="=\"$_valu\""
else
[ -n "$_vvaa" ]&&_vvaa+=' '
_vvaa+="\"$_valu\""
fi
fi
[ $# -gt 0 ]&&_vvaa+=" $*"
fi
}
pluralize() {
local _opts=() _caps _numi _zero _word _waut _frmt _oone _ogen _omsg='message'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a|-i)
_opts+=("$1");;
-c) shift;_caps="$1";;
-e) _omsg='error';;
-f) _omsg='fatal';;
-g) _ogen=1;;
-o) _oone=1;;
-n) _numi=1;;
-p) shift;_frmt="$1";;
-s) shift;_save="$1";;
-t) _omsg="$CEN_TRACE";[ "$_omsg" = : ]&&return 0;;
-w) _omsg='warning';;
-z) _zero=0;;
*) _cen_abort - "$1"
esac;shift
done
[ "$#" = 2 ]&&set -- "$1" "$2" -
[ "$#" -lt 3 ]&&_cen_abort +
if [ "$1" = 0 ];then
[ -n "$_zero" ]&&_word="$3"||_word="$2"
[ -z "$_numi" ]&&_numi=$"zero"||_numi=0
[ "$_numi" = 'zero' ]&&_numi='no'
[ "${4:--}" = - ]||_numi="$4"
elif [ "$1" = 1 ];then
_word="$2"
[ -z "$_numi" ]&&_numi=$"one"||_numi=1
[ "${5:--}" = - ]||_numi="$5"
else
_word="$3";_numi="$1"
fi
if [ "$_word" = - ];then
_word="$2s";_waut="$2"$"s"
fi
local _temp="$_word" _indx
local _weng=('line' 'lines' 'file' 'files' 'folder' 'folders' 'error' 'errors')
if listsearch -i _weng -n _indx -- "$_temp";then
_weng=($"line" $"lines" $"file" $"files" $"folder" $"folders" $"error" $"errors")
_word="${_weng[_indx]}"
_temp="${_word%|-g}"
if [ "$_temp" != "$_word" ];then
_word="$_temp";_ogen=1
fi
else
[ -n "$_waut" ]&&_word="$_waut"
fi
[ -n "$_ogen" ]&&_numi="${_numi#*|}"||_numi="${_numi%|*}"
[ "$((_caps & 1))" = 1 ]&&_word="${_word^}"
[ "$((_caps & 2))" = 2 ]&&_numi="${_numi^}"
[ "${_frmt:--}" = - ]&&_frmt='%s %s'
if [ -n "$_save" ];then
printf -v "$_save" -- "$_frmt" "$_numi" "$_word"
else
[ -n "$_oone" -a "$1" = 0 ] &&
case "$_omsg" in
:);;
message) _omsg="$CEN_TRACE";;
*) _omsg='message'
esac
$_omsg "${_opts[@]}" -p -- "$_frmt" "$_numi" "$_word"
fi
}
splitcall() {
local _oerr _vnam _call _deli _fdry _fpre _good _ivar _maxi _ppar _srun
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vnam="$1";;
-c) shift;_call="$1";isfunction -f -- "$1";;
-d) shift;_deli="$1";;
-e) _oerr='-e';_fpre='-p';;
-f) _oerr='-f';_fpre='-p';;
-g) shift;_good="$1";;
-i) shift;_ivar="$1";;
-m) shift;_maxi="$1";;
-p) _ppar=1;;
-q) _oerr='-q';;
-r) _fdry='-r';;
-s) shift;local _cen_splitcall
sysfind -f -s _cen_splitcall -- "$1";_srun="$_cen_splitcall";;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_call" -a -z "$_srun" ]&&_cen_abort = '-c|-s'
if [ -n "$_ivar" ];then
local _iarr
splitjoin -s _iarr -i "$_ivar";set -- "${_iarr[@]}"
fi
[ -n "$_deli" ]&&fatal -t 'Not yet implented:' '-d'
local _offs= _leng _coun="$#" _aidx _args _stat _save _savd _rval=0
_leng="${_maxi:-1024}"
if [ -n "$_vnam" ];then
listsearch -c -n _aidx -i "$_vnam" -- '@' ||
_cen_abort $"No '@' in arguments array:" '-a'
local -n _cen_splitcall="$_vnam"
fi
if [ -n "$_ppar" ];then
_cen_scal_find -i "${_maxi:--}"
_fake=100;_frun=$_fake
while [ $# -gt 0 ];do
if _cen_scal_find -f 0;then
CEN_UTL_SCTAG[CEN_UTL_SCIDX]="$1"
if [ -n "$_call" ];then
$CEN_TRACE2 -c ' function' "$CEN_UTL_SCIDX: $_call $1"
eval "$_call" "$1" &
else
$CEN_TRACE2 -c ' program' "$CEN_UTL_SCIDX: $_srun $1"
fi
CEN_UTL_SCPID[CEN_UTL_SCIDX]="$!"
else
wait -p _frun -n ${CEN_UTL_SCPID[*]}
$CEN_TRACE2 -c ' finished' -- "$_frun"
_cen_scal_find -f $_frun||_cen_abort $"invalid 'wait' result"
CEN_UTL_SCPID[CEN_UTL_SCIDX]=0
continue
fi
shift
done
return
fatal -t 'Not yet implented:' '-p'
fi
if [ "${_good:--}" = - ];then
_save="$CEN_ERROR";_savd="$CEN_DONE"
error -c
fi
while [[ "$_offs" -lt "$_coun" ]];do
if [ -n "$_vnam" ];then
_args=("${_cen_splitcall[@]::_aidx}")
_args+=("${@:_offs+1:_leng}")
_args+=("${_cen_splitcall[@]:_aidx+1}")
else
_args=("${@:_offs+1:_leng}")
fi
if [ -n "$_srun" ];then
sysrun -n $_fdry $_fpre $_oerr -- "$_srun" "${_args[@]}"
else
$_call $_fdry $_oerr "${_args[@]}"
fi
_stat="$?";((_offs+=_leng))
[ "$_stat" = 0 ]&&continue
if [ "${_good:--}" = - ];then
error -t&&continue
elif [ "$_stat" -le "${_good:-0}" ];then
continue
fi
_rval="$_stat";break
done||:
if [ "${_good:--}" = - -a "$CEN_ERROR" = 0 ];then
CEN_ERROR="$_save";CEN_DONE="$_savd"
fi
return $_rval
}
CEN_UTL_SCPID=
CEN_UTL_SCTAG=
CEN_UTL_SCMAX=
CEN_UTL_SCIDX=
CEN_UTL_SCOLD=
_cen_scal_find() {
if [ "$1" = '-i' ];then
CEN_UTL_SCPID=()
CEN_UTL_SCTAG=()
if [ "$2" = - ]||[ "$2" -le 0 ];then
CEN_UTL_SCMAX=2
local _keyw _sepa _data
while read _keyw _sepa _data;do
[ "$_keyw" = 'processor' ]||continue
[ "$_sepa" = : ]||continue
((CEN_UTL_SCMAX += 1))
done < /proc/cpuinfo 2>/dev/null
else
CEN_UTL_SCMAX="$2"
fi
$CEN_TRACE -c ' init' -- "$CEN_UTL_SCMAX processes"
return 0
fi
CEN_UTL_SCIDX=0
if [ "$1" = '-p' ];then
local spid _stat
while [ "$CEN_UTL_SCIDX" -lt "$CEN_UTL_SCMAX" ];do
spid="${CEN_UTL_SCPID[CEN_UTL_SCIDX]:- }"
if [ "${spid#* }" = "$spid" ];then
kill -n 0 "$spid"||return 0
fi
((CEN_UTL_SCIDX += 1))
done 2>/dev/null
else
while [ "$CEN_UTL_SCIDX" -lt "$CEN_UTL_SCMAX" ];do
[ "${CEN_UTL_SCPID[CEN_UTL_SCIDX]:-0}" = "$2" ]&&return 0
((CEN_UTL_SCIDX += 1))
done
fi
return 1
}
_cen_scal_wait() {
local _ppid _stat
if [ -n "$CEN_UTL_SCOLD" ];then
wait -f -n ${CEN_UTL_SCPID[*]};_stat=$?
else
wait -p _ppid -f -n ${CEN_UTL_SCPID[*]};_stat=$?
fi
if [ -n "$_ppid" ];then
_cen_scal_wait -f "$_ppid"||return 127
else
_cen_scal_wait -p||return 127
fi
CEN_UTL_SCPID[CEN_UTL_SCIDX]+=" $_stat"
return $_stat
}
_cen_timer_cvt() {
local _tnum="${1%[.,]*}" _tfra=0
[ "$_tnum" != "$1" ]&&_tfra="${1#*[.,]}000"
_tfra="${_tfra::3}"
_tnum="000000$_tnum";_tnum="1${_tnum:${#_tnum}-6}"
case "$_tfra" in
00?) _tfra="${_tfra:2}";;
0??) _tfra="${_tfra:1}";;
esac
_time=$((_tnum * 1000 + _tfra))
}
CEN_UTL_SLEEP=
[ -v CEN_UTL_STIME ]||CEN_UTL_STIME="$EPOCHREALTIME"
timer() {
local _call=: _vnam _aopt _hopt _ropt _spri _sset _stic _swai _mesg _time _stat
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _aopt="$1";;
-c) shift;isfunction -f -- "$1";_call="$1";;
-h) _hopt=1;;
-i) shift;_sset="$1";;
-l) shift;_stic="$1";;
-m) _mesg='message';;
-p) shift;_spri="$1";;
-r) _ropt="$1";;
-s) shift;_vnam="$1";;
-t) _mesg="$CEN_TRACE";;
-w) shift;number -e -r -u -s _swai -- "$1"||return;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_mesg" -a -n "$_aopt" ]&&_mesg="$CEN_TRACE"
[ -n "$_mesg" -a -z "$_spri" ]&&_spri=-
[ -n "$_hopt" ]&&context -t +
$_call -b "$_swai"
if [ -n "$_spri" ];then
local _tnow
_cen_timer_cvt "$EPOCHREALTIME";_tnow="$_time"
_cen_timer_cvt "$CEN_UTL_STIME"
if [ "$_tnow" -ge "$_time" ];then
_time=$((_tnow - _time))
else
_time=$((_tnow - _time + 100))
fi
if [ "$_spri" = - ];then
[ -n "$_vnam" ]&&_spri='%s'||_spri=$"Elapsed time: %s [ms]"
fi
printf -v _time "$_spri" "$_time"
[ -n "$_mesg" ]&&$_mesg $_aopt -- "$_time" "$@"
fi
if [ -n "$_vnam" ];then
[ -z "$_time" ]&&_time="$CEN_UTL_STIME"
printf -v "$_vnam" '%s' "$_time"
fi
if [ -n "$_stic" ];then
[ "$_call" = : ]&&_cen_abort = '-c'
[ -z "$_swai" ]&&_cen_abort = '-w'
[ -z "$CEN_UTL_SLEEP" ]&&sysfind -f -b -s CEN_UTL_SLEEP -- sleep
local _tbeg _tend _tnow _twai
_cen_timer_cvt "$EPOCHREALTIME";_tnow="$_time"
_cen_timer_cvt "$_swai";_twai="$_time"
((_twai -= 1000000000))
_tbeg="$_tnow";_tend=$((_tbeg + _twai))
while [ "$_tnow" -lt "$_tend" ];do
$_call -l "$((_tnow - _tbeg))" "$_twai";_stat=$?
[ "$_stat" = 1 ]||break;_stat=
dryrun $_ropt "$CEN_UTL_SLEEP $_stic"||$CEN_UTL_SLEEP $_stic
_cen_timer_cvt "$EPOCHREALTIME";_tnow="$_time"
[ "$_tnow" -lt "$_tbeg" ]&&((_tnow += 1000000000))
done
if [ -z "$_stat" ];then
$_call -l "$((_tnow - _tbeg))" "$_twai";_stat=$?
fi
elif [ -n "$_swai" ];then
[ -z "$CEN_UTL_SLEEP" ]&&sysfind -f -b -s CEN_UTL_SLEEP -- sleep
if [ "$_swai" != - ];then
dryrun $_ropt "$CEN_UTL_SLEEP $_swai"||$CEN_UTL_SLEEP $_swai
fi
fi
if [ -n "$_sset" ];then
[ "$_sset" = - ]&&CEN_UTL_STIME="$EPOCHREALTIME"||CEN_UTL_STIME="$_sset"
fi
[ -z "$_stat" ]&&_stat=0
$_call -e $_stat
[ -n "$_hopt" ]&&context -t -
return $_stat
}
CEN_TRIMJOIN=
trimjoin() {
local _oapp _octl _olea=1 _omax _otra=1 _ospa _deli=' ' _drun _strm _snam='CEN_TRIMJOIN'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _oapp=1;;
-c) _octl=1;;
-d) shift;_deli="$1";;
-l) _otra=;;
-m) shift;_omax="${1:--}";;
-s) shift;_snam="$1";;
-t) _olea=;;
-w) _ospa=1;;
*) _cen_abort - "$1"
esac;shift
done
local -n _svar="$_snam"
[ $# = 0 ]&&set -- "$_svar"
[ -z "$_oapp" ]&&_svar=
for _strm in "$@";do
_svar+="$_drun"
[ -n "$_octl" ]&&_strm="${_strm//[[:cntrl:]]/ }"
[ -n "$_otra" ]&&_strm="${_strm%"${_strm##*[![:space:]]}"}"
[ -n "$_olea" ]&&_strm="${_strm#"${_strm%%[![:space:]]*}"}"
_svar+="$_strm";_drun="$_deli"
done
if [ -n "$_ospa" ];then
_strm="${_svar//[[:space:]]/ }";_strm="${_strm//  / }"
while [ "$_strm" != "$_svar" ];do
_svar="$_strm";_strm="${_svar//    / }";_strm="${_svar//  / }"
done
fi
[ -n "$_omax" ]&&_cen_compactify "$_snam" "$_omax"
return 0
}
}
_cen_bash_load_pip(){
CEN_MODULES['_centauri_bash_pip']='0.02:1'
CEN_PIP_WAIT=
CEN_PIP_BUSY=
CEN_PIP_BMAP=
embed -c '_centauri_bash_ext'
CEN_SYSBIND=
sysbind() {
local _emsg="$CEN_TRACE" _inam='CEN_SYSBIND' _stat=0 _frun
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;;
-i) shift;_inam="$1";;
-c) shift;_frun=2;;
-d) shift;;
-e) _emsg='error';;
-f) _emsg='fatal';;
-s) _frun=1;;
-t) _frun=0;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_frun" ]&&_cen_abort + '-s|-c|-t'
if [ "$_inam" = '*' ];then
[ "${#CEN_SYSBIND[*]}" -le 1 ]&&return 0
$CEN_TRACE 'sysbind terminate all instances'
for _frun in "${!CEN_PIP_BMAP[@]}";do
sysbind -t "$_frun"
done
return 0
fi
local -n _inst="$_inam"
if [ "$_frun" = 0 ];then
[ -z "$_inst" ]&&return 0
_inst=(-)
elif [ "$_frun" = 1 ];then
if [ "${_inst:--}" != - ];then
_emsg -- $"sysbind instance already running:" "$_inam";return 1
fi
if [ "${#CEN_SYSBIND[*]}" -le 1 ];then
unset CEN_PIP_BMAP
declare -g -A CEN_PIP_BMAP;CEN_SYSBIND=(-)
fi
CEN_PIP_BMAP["$_inam"]="$_inam"
declare -p CEN_PIP_BMAP
_inst=(- - - - -)
else
if [ -z "$_inst" ];then
_emsg -- $"sysbind instance not running:" "$_inam";return 1
fi
fatal 'not implemented'
fi
return $_stat
}
syspager() {
local _ocap _opag _odel
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) shift;_opag="${1:-$CEN_OPT_PAGER}";;
-d) CEN_PAGER=;_odel=1;;
-y) _ocap='-y';;
*) _cen_abort - "$1"
esac;shift
done
[ -n "$_odel" -a -z "$_opag" ]&&return 0
if [ -z "$CEN_PAGER" -a -n "$TERM" ]&&[ -t 1 -a -t 2 ];then
local _plst _tool="$CEN_PAGER_TOOL"
[ -z "$_opag" ]&&_opag="${CEN_OPT_PAGER:-less}"
case "$_opag" in
less|yes|on) _plst=('less' 'more');;
none|no|off) _plst='none';_tool=;;
more) _plst=('more' 'less');;
*)  _plst=("$_opag" -);_tool=
esac
if [ "$_plst" = 'none' ];then
:
elif [ "${_tool:--}" != - ]&&sysfind -s CEN_OPT_PAGER -- "$_tool";then
CEN_PAGER_TOOL="$CEN_OPT_PAGER"
CEN_PAGER="syspager $_ocap"
elif sysfind -s CEN_OPT_PAGER -- "${_plst[0]}";then
CEN_PAGER="syspager $_ocap"
elif sysfind -s CEN_OPT_PAGER -- "${_plst[1]}";then
CEN_PAGER="syspager $_ocap"
else
fatal $"Pager not found:" "$_plst"
fi
fi
[ $# = 0 ]&&return 0
isfunction -e -x -- "$1"||return 1
if [ -z "$CEN_PAGER" -o -n "$CEN_SYSPIPE" ];then
"$@";return
fi||:
local _args _sane
case "${CEN_OPT_PAGER##*/}" in
true) _args=($CEN_TOOLS/centaurihelp --force --tool '<pipe>')
;;
centaurihelp) _args=("$CEN_OPT_PAGER" --tool '<pipe>')
[ -n "$CEN_FEATURE_T" ]&&_args+=('--l10n')
;;
less) if [ "$CEN_OPT_PAGER" = "$CEN_PAGER_TOOL" ];then
_args=("$CEN_OPT_PAGER" $CEN_PAGER_OPTS)
else
_args=("$CEN_OPT_PAGER" -r -F -R -X)
fi
;;
*) if [ "$CEN_OPT_PAGER" = "$CEN_PAGER_TOOL" ];then
_args=("$CEN_OPT_PAGER" $CEN_PAGER_OPTS)
else
_args=("$CEN_OPT_PAGER")
fi
esac
_sane="$CEN_QUIT_SANE";CEN_QUIT_SANE=1;context -t +
if [ -n "$CEN_PACKAGE" ];then
CEN_ROOT= syspipe -c + -n -o "$*" -r $_ocap -- "${_args[@]}"
else
syspipe -c + -n -o "$*" -r $_ocap -- "${_args[@]}"
fi||:
CEN_QUIT_SANE="$_sane";context -t -
}
CEN_SYSPIPE=
syspipe() {
local _fbak _fcop _fcap _fnoc _fqui _ftra \
          _ocal='_cen_pip_error' _ocon _odst _oerr _ogra _omsg='error -z' _osrc _oinp _oout _orun
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;[ "$1" = - ]&&_oout=2||_oout=1;_ocon="splitjoin -s $1 -i - -l -n";;
-b) shift;_fbak="$1";;
-c) shift;_ocal="$1";;
-d) shift;_oout=0;_ocon="$1";;
-e) _oerr='-e';;
-f) _oerr='-f';_omsg='fatal';;
-g) _ogra=1;;
-i) shift;_oinp="$1";_osrc="splitjoin -s - -i $1 -l -n";;
-n) _fnoc=1;;
-o) shift;_osrc="$1";;
-q) _omsg="$CEN_TRACE";;
-r) _orun='-r';;
-s) shift;_oout=1;_ocon="splitjoin -j $1 -i - -l -n";;
-t) _ftra=1;;
-x) _fcop=1;;
-y) _fcap=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_fbak" ];then
_fnoc=1
[ "${_oout:-0}" = 0 ]||_cen_abort - '-a|-s'
[ -z "$_osrc$_oout" ]&&_cen_abort + '-i|-o'
[ -n "$_osrc" -a -n "$_ocon" ]&&_cen_abort ? '-i|-o'
[ -z "$_fcop$_oinp" ]||_cen_abort - '-i|-x'
elif [ -z "$_osrc$_ocon" ];then
_cen_abort + '-i|-o|-d|-a|-s'
fi
CEN_SYSPIPE=
local _stat=0 _verb="$CEN_VERB" _acmd=("$@") _cen_pip_temp
if [ -z "$_fnoc" ];then
[ -z "$_oerr" -a "$_omsg" != "$CEN_TRACE" ]&&_oerr='-e'
sysfind $_oerr -c -s _cen_pip_temp -- "$_acmd"||return 1
acmd[0]="$_cen_pip_temp"
if [ -n "$_osrc" -a -z "$_oinp" ];then
isfunction $_oerr -x -- "${_osrc%% *}"||return 1
fi
if [ "$_oout" = 0 ];then
isfunction $_oerr -x -- "${_ocon%% *}"||return 1
fi
fi
_cen_pip_error() {
IFS=$' \n\t'
if [ "$1" = 'STATUS' ];then
[ "$2" -gt "${_ogra:-0}" ] &&
$_omsg -p $"command failed (status %s): %s" "$2" "$3"
else
$_omsg -p $"command failed (%s): %s" "$1" "$3"
fi
CEN_SYSPIPE=
}
if [ "$_oinp" = - -a "${_oout:-0}" != 0 ];then
[ -n "$_ftra" ]&&context -t +
if [ "$_oout" = 2 ];then
system -z $_orun -d '--' -n -- "${_acmd[@]}"||_stat=$?
else
system -m -s _cen_pip_temp $_orun -d '--' -n -- "${_acmd[@]}"||_stat=$?
${_ocon/-i -/-i _cen_pip_temp}
fi
case "${_ocal:--}" in
-|+);;
*) [ "$_stat" != 0 ]&&$_ocal 'STATUS' "$_stat" "$_acmd"
esac
[ -n "$_ftra" ]&&context -t -
return $_stat
fi
[ -z "$_fcop" ]&&_cen_pip_temp='[PIPE]'||_cen_pip_temp='[COPROC]'
dryrun $_orun "$_cen_pip_temp" "${_acmd[@]}"&&return 1
[ -n "$_ftra" ]&&context -t +
if [ "$_ocal" != - ];then
local _call='CEN_SYSPIPE=; '
[ "$_ocal" = '+' ] && _call+='quit' || _call+="$_ocal SIGPIPE - '$_acmd'"
_call+='; _ocal='
trap "trap SIGPIPE; exec 1>&$CEN_STDOUT 2>&$CEN_STDERR; $_call" SIGPIPE
fi
if [ -n "$_fcop" ];then
[ -z "$_osrc" ]&&_cen_abort + '-o'
[ -z "$_ocon" ]&&_cen_abort + '-d'
[ "$CEN_PIP_BUSY" = "$BASHPID" ]&&_cen_abort $"coproc already in use" "$BASHPID"
CEN_PIP_BUSY="$BASHPID"
if [ -n "$_fcap" ];then coproc { "${_acmd[@]}";} 2>&1
else  coproc { "${_acmd[@]}";}
fi
local _hout=${COPROC[0]} _hinp=${COPROC[1]} _cpid="$COPROC_PID"
CEN_SYSPIPE="$_hout $_hinp"
if [ -n "$_fcap" ];then
$_osrc >&"$_hinp" 2>&1
else
$_osrc >&"$_hinp"
fi
eval exec "$_hinp"'>&-'
[ -r /dev/fd/$_hout ]&&$_ocon <&"$_hout"
wait $_cpid||_stat=$?
CEN_PIP_BUSY=;CEN_SYSPIPE=
else
embed -m '_centauri_bash_ext'
_cen_pip_worker() {
if [ "$1" = - ];then
[ "$_verb" -gt 1 ]&&context -v 1
[ -n "$_fcap" ]&&exec 2>&1
shift
if isfunction -- "$_acmd";then
"${_acmd[@]}";wait;tmpfile -d;return
else
exec "${_acmd[@]}"
fi
fi
tmpfile -r -s _pipe[0] -p -f;CEN_SYSPIPE="$_pipe"
if [ "$1" = '<>' ];then
tmpfile -r -s _pipe[1] -f;CEN_SYSPIPE="${_pipe[*]}"
fi
trace -a -c "() $1" "worker: $_acmd"
if [ "$1" = '<>' ];then
_cen_pip_worker - <"${_pipe[0]}" >"${_pipe[1]}" &
elif [ "$1" = '<' ];then
_cen_pip_worker - <"$_pipe" &
elif [ "$1" = '>' ];then
_cen_pip_worker - >"$_pipe" &
fi
}
local _pipe
if [ -n "$_fbak" ];then
_acmd=("$_fbak" "$@")
if [ -z "$_osrc" ];then
_cen_pip_worker '>';CEN_PIP_WAIT=$!
"$_ocon" "$@" < "$_pipe"||_cen_pip_error STATUS "$?" "$_ocon"
else
_cen_pip_worker '<';CEN_PIP_WAIT=$!
"$_osrc" "$@" > "$_pipe"||_cen_pip_error STATUS "$?" "$_osrc"
fi
elif [ -n "$_osrc" ];then
if [ -n "$_ocon" ];then
_cen_pip_worker '<>';CEN_PIP_WAIT=$!
else
_cen_pip_worker '<';CEN_PIP_WAIT=$!
fi
if [ -n "$_fcap" ];then
$_osrc >"$_pipe" 2>&1
else
$_osrc >"$_pipe"
fi
else
_cen_pip_worker '>';CEN_PIP_WAIT=$!
$_ocon <"$_pipe"
fi
wait $CEN_PIP_WAIT;_stat=$?;CEN_PIP_WAIT=
[ -n "${_pipe[1]}" ]&&$_ocon <"${_pipe[1]}"
[ "$_verb" -gt 1 ]&&context -v "$_verb"
CEN_SYSPIPE=
remove -r -s -- "${_pipe[@]}"
fi
case "${_ocal:--}" in
-);;
+) trap SIGPIPE;;
*) trap SIGPIPE
[ "$_stat" != 0 ]&&$_ocal 'STATUS' "$_stat" "$_acmd"
esac
[ -n "$_ftra" ]&&context -t -
return $_stat
}
_cen_pip_reset() {
[ -z "$CEN_PIP_WAIT" ]&&return
exec 1>&- 2>&-
exec 1>&$CEN_STDOUT 2>&$CEN_STDERR
trap SIGPIPE
if ! kill -0 "$CEN_PIP_WAIT" 2>/dev/null;then
$CEN_TRACE2 'background pid invalid'
elif [ -n "$CEN_TRAPSIG" ];then
kill $CEN_PIP_WAIT
else
wait $CEN_PIP_WAIT
fi
}
CEN_SYSLOOP=
sysloop() {
local _emsg="$CEN_TRACE" _fatl _frun _isok _pipe _time _rpip
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) shift;isfunction -a -- "$1";_frun=1
CEN_SYSLOOP=("$CEN_SYSLOOP" "$1" "${CEN_SYSLOOP[2]}");;
-e) _emsg='error';;
-f) _emsg='fatal';_fatl='-f';;
-m) _frun=2;;
-p) shift;_pipe="${1:--}";_isok=1;;
-q) _frun=0;;
-r) _rpip=1;;
-t) shift;_time="$1";_isok=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$CEN_SYSLOOP" -o -n "$_pipe" ];then
if [ "${_pipe:--}" = - ];then
tmpfile $_fatl -p -r -s _pipe||return 1
elif [ -p "$_pipe" ];then
:
elif [ ! -e "$_pipe" ];then
sysrun ${_fatl:--e} -p -r -- mkfifo -- "$_pipe"||return 1
else
$_emsg 'Not a pipe:' "$_pipe";return 1
fi
prettypath -s CEN_SYSLOOP -- "$_pipe"
fi
if [ -n "$_time" ];then
if [[ "$_time" =~ ^[0-9]+(.[0-9]*)? ]];then
_cen_pip_ticker "$_time" "$1"
else
$_emsg 'Invalid time:' "$_time";return 1
fi
fi
if [ "$_frun" = 0 ];then
echo "$BASHPID" - > "$CEN_SYSLOOP" 2>/dev/null
$CEN_TRACE -a -c ' sent quit' "status=$?"
elif [ "$_frun" = 1 ];then
$CEN_TRACE -c ' loop' "pipe=$CEN_SYSLOOP"
local _epid _emsg _earg _ecnt _stat=0
CEN_SYSLOOP[3]="$_rpip"
while [ -n "${CEN_SYSLOOP[1]}" ];do
_epid=
while read -r _epid _ecnt _emsg < "$CEN_SYSLOOP";do
if [ -n "${_epid//[0-9]/}" -o -n "${_ecnt//[-0-9]/}" ];then
$CEN_TRACE -c ' ignored' -- "$_epid" "$_ecnt"
continue
elif [ "${_ecnt:--}" = - ];then
$CEN_TRACE -a -c ' quit msg' "from PID=$_epid"
_stat=0;CEN_SYSLOOP[1]=;break
elif [ "$_ecnt" -gt 1 ];then
splitjoin -s _earg -d '\a' -- "$_emsg"
${CEN_SYSLOOP[1]} "$_epid" "${_earg[@]}"&&continue
else
${CEN_SYSLOOP[1]} "$_epid" "$_emsg"&&continue
fi
done
if [ -z "$_epid" ]&&[ ! -r "$CEN_SYSLOOP" ];then
error 'Cannot read pipe:' "$CEN_SYSLOOP"
_stat=2;break
fi
done
$CEN_TRACE -c ' end loop' "status=$_stat"
_cen_pip_ticker
[ "$_stat" -gt 1 ]&&return $_stat
elif [ "$_frun" = 2 ];then
local _mesg="$1"
[ $# -gt 1 ]&&splitjoin -j _mesg -d '\a' -- "$@"
if echo "$BASHPID" $# "${_mesg//$'\n'/$'\t' }" > "$CEN_SYSLOOP" 2>/dev/null ; then
$CEN_TRACE -a -c ' send OK' -- "$BASHPID $*"
else
$_emsg -c ' send err' -- "$BASHPID $*";return 1
fi
else
[ -z "$_isok" ]&&_cen_abort + '-c|-m|-q|-t'
fi
return 0
}
_cen_pip_ticker() {
if [ "$1" = 'term' ];then
message -c ' ticker' 'got signal - sending quit'
trap '' 14
echo "$BASHPID" - > $CEN_SYSLOOP
trace -c ' ticker' 'terminated';exit
elif [ "$1" = 'stop' ];then
trace -a -c ' ticker' 'stopped';exit
elif [ $# = 0 ];then
[ -z "${CEN_SYSLOOP[2]}" ]&&return 1
kill -s 14 "${CEN_SYSLOOP[2]}" 2>/dev/null &&
trace -c ' ticker' 'stopping'
if [ -n "${CEN_SYSLOOP[3]}" ];then
$CEN_TRACE -a -c 'removing pipe' "$CEN_SYSLOOP"
remove -s -- "$CEN_SYSLOOP";CEN_SYSLOOP=
fi
CEN_SYSLOOP[2]=;CEN_SYSLOOP[3]=
context -t -
return 0
elif [ $# -lt 3 ];then
[ -n "${CEN_SYSLOOP[2]}" ]&&return 1
context -t +
_cen_pip_ticker "$1" "${2:-TICK}" "$$" &
CEN_SYSLOOP[2]=$!
$CEN_TRACE -c ' ticker' "started (PID=$!):" "$1" "${2:-TICK}"
return 0
fi
trap '_cen_pip_ticker stop' 14
trap '_cen_pip_ticker term' 1 2 3 15
while sleep "$1";do
echo "$3 0 $2" > "$CEN_SYSLOOP" 2>/dev/null||return 1
done
}
_cen_pip_quit() {
sysbind -i '*' -t
_cen_pip_reset
_cen_pip_ticker
}
}
_cen_bash_load_ext(){
CEN_MODULES['_centauri_bash_ext']='0.26:2'
CEN_EXT_TEMP=
CEN_EXT_TIDX=
CEN_EXT_TPID=
CEN_EXT_REALP=
_cen_path_pretty() {
local _fchk _vnam _fpwd
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-e) _fchk=1;;
-p) _fpwd=1;;
*) _cen_abort - "$1"
esac;shift
done
local -n _vcpp="$1";shift;_vcpp="$1"
while true;do
case "$_vcpp" in
""|/)  return 0;;
.|./)  _vcpp='.';[ -z "$_fpwd" ]&&return 0
_vcpp="$PWD";return 0;;
..|../) _vcpp='..';[ -z "$_fpwd" ]&&return 0
_vcpp="${PWD%/*}"
[ -z "$_vcpp" ]&&_vcpp=/;return 0;;
//|/.|/..) _vcpp=/;return 0;;
./*) _vcpp="${_vcpp:2}";[ -n "$_fpwd" ]&&_vcpp="$PWD/$_vcpp";;
//*) _vcpp="${_vcpp:1}";;
*/) _vcpp="${_vcpp::-1}";;
*/.) _vcpp="${_vcpp::-2}";;
*/./*|/./*) _vcpp="${_vcpp/\/.\//\/}";;
*//*)  _vcpp="${_vcpp/\/\//\/}";;
../*)  [ -z "$_fpwd" ]&&break
_vcpp="${PWD%/*}${_vcpp:2}";break;;
*)  [ -z "$_fpwd" -o "${_vcpp::1}" = / ]&&break
_vcpp="$PWD/$_vcpp"
esac
done
[ -z "$_fchk" ]&&return 0
[ "$1" -ef "$_vcpp" ]
}
_cen_path_regex() {
_cen_path_regck() {
local _path="$1" _item _iarg=1
for _item in "${BASH_REMATCH[@]:1}";do
_path="${_path//%$_iarg/$_item}"
((_iarg += 1))
done
[ "$_logi" -ef "$_path" ]||return 1
_logi="$_path";return 0
}
local _fltr="$1";_logi="$2"
case "$_logi" in
/) return 0;;
/*/) _logi="${_logi::-1}";;
/*);;
*) return 0
esac
[ -e "$_logi" ]||return 0
local _item _path _sifs="$IFS"
set -f
for _item in "${CEN_PATH_REXP[@]}";do
IFS=$'\a';set -- $_item;IFS="$_sifs"
[ "$_fltr" = "$1" ]||continue
[[ "$_logi" =~ $2 ]]||continue
shift 2
for _path in "$@";do
_cen_path_regck "$_path"||continue
_item=;break
done
[ -z "$_item" ]&&break
done
set +f;return 0
}
_cen_path_ltrim() {
[ -n "$2" ]&&_logi="$2"
[ -z "$1" ]&&return 1
if [ "$1" = "$2" ];then
_logi='.';return 0
fi
local _leng="${#1}"
[ "${_logi:_leng:1}" = / ]||return 1
[ "${_logi::_leng}" = "$1" ]||return 1
_logi="${_logi:_leng+1}";return 0
}
_cen_path_realp() {
local _exro _retr _rslt _opta
_logi=
case "$CEN_EXT_REALP$1" in
0-a) _exro+=(realpath -s);;
1-a) _exro+=(realpath -s);_opta=1;_retr=1;;
0-c) _exro+=(readlink -m);;
1-c) _exro+=(realpath);_opta=1;_retr=1;;
?-l) if [ -e "$2" ];then _exro+=(readlink)
elif [ -h "$2" ];then _exro+=(readlink)
else  return 1;fi;;
-*) CEN_EXT_REALP=0
if [ -n "$CEN_FEATURE_A" ];then
if _cen_dyn_builtin 'realpath' >/dev/null;then
CEN_COMMANDS['realpath']=-;CEN_EXT_REALP=1
fi
fi
_cen_path_realp "$@"
return;;
*) _cen_abort - "$CEN_EXT_REALP$_olow"
esac
if [ -n "$_opta" ];then
_exro+=(-q -a _rslt -- "$2")
[ "$CEN_VERB" -gt 1 ]&&dryrun -r 'builtin' "${_exro[@]}"
builtin "${_exro[@]}" &>/dev/null&&_retr=0
else
sysrun -q -r -a _rslt -b "${_exro[@]}" -- "$2"&&_retr=0
fi
if [ "$_retr" = 1 ];then
sysrun -q -r -a _rslt -b -- readlink -m -- "$2"&&_retr=0
fi
[ "$_retr" = 0 ]||return 1
_logi="$_rslt";return 0
}
copy() {
local _oflg='-e -p' _oerr='error' _omsg="$CEN_TRACE" _oarc _ocow _oupd _olis _odes _orem
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _oarc='-a';;
-f) _oerr='fatal';_oflg='-f -p';;
-n) _ocow='--reflink=never';;
-o) _ocow='--reflink=auto';;
-q) _oerr="$CEN_TRACE";_oflg='-q';;
-r) _orun='-r';;
-s) _omsg=:;;
-u) _oupd='-u';;
-v) _omsg=message;;
-x) _orem=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ $# = 2 ];then
_olis="$1";_odes="$2"
elif [ $# -lt 2 ];then
_cen_abort $"Missing arg(s)"
else
_olis=("${@:1:$#-1}");_odes="${@:$#}"
if [ ! -d "$_odes" ];then
$_oerr $"Copy destination is not a folder"": $_odes";return 2
fi
fi
if [ -e "$_odes" ];then
if [ -n "$_orem" ];then
$_omsg -a $"Removing destination before copy"": $_odes"
remove $_orun ${_oflg/-p/} -d -- "$_odes"||return 1
elif [ ! -w "$_odes" ];then
$_oerr $"Copy destination is not a writable"": $_odes";return 1
fi
fi
if [ $# -gt 2 ];then
$_omsg -a -p $"Copying %d item to '%s'" "${#_olis[*]}" "$_odes"
else
$_omsg -a -p $"Copying '%s' to '%s'" "${_olis[*]}" "$_odes"
fi
sysrun $_oflg $_orun -b -o 'copy()' -- \
           cp $_oarc $_ocow $_oupd -- "${_olis[@]}" "$_odes" && return 0
[ -n "$CEN_OPT_DRYRUN" ]
}
CEN_JOINPATH=
joinpath() {
local _fset='CEN_JOINPATH' _oabs _orel _opre _odef _opte _path _elem
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _oabs=1;;
-c) _opre='-q -c';;
-d) _odef='-d';;
-e) shift;_opte="$1";;
-p) _opre='-q';;
-r) _orel=1;;
-s) shift;_fset="$1";;
*) _cen_abort - "$1"
esac;shift
done
local -n _varg="$_fset";_varg=
while [ "$#" -gt 0 ];do
if [ -z "$1" ];then
:
elif [ -z "$_path" ];then
_path="$1"
elif [ "${1::2}" = './' ];then
if [ -n "$_oabs" ];then
_path+="${1:1}"
elif [ -z "$_orel" ];then
_path="${1:2}"
else
_path+="/$1"
fi
elif [ "${1::1}" = / ];then
[ -z "$_orel" ]&&_path=
_path+="$1"
else
_path+="/$1"
fi;shift;[ "$_path" = / ]||_path="${_path%/}"
done
_path="${_path//\/\//\/}"
_path="${_path//\/.\//\/}"
[ "${_opte:-.}" != '.' ]&&suffixpath -s _path $_odef -- "$_opte"
_path="${_path:-.}"
[ -n "$_opre" ]&&prettypath $_opre -s _path -- "$_path"
_varg="$_path"
}
CEN_MATCHPATH=
matchpath() {
local _oarr _ostr _oone _opre _otyp _orea _owri _oexe _scal=: _smat=:
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_oarr="$1";;
-c) shift;isfunction -f -- "$1";_scal="$1";;
-d) _otyp='-d';;
-e) _otyp='-e';;
-f) _otyp='-f';;
-l) _otyp='-h';;
-m) _smat='filter';;
-n) _otyp='! -e';;
-o) _oone=1;;
-p) _opre=1;;
-r) _orea=1;;
-s) shift;_ostr="$1";_oarr='_cen_ext_matchpath';;
-w) _owri=1;;
-x) _oexe=1;;
*) _cen_abort - "$1"
esac;shift
done
local -n _varr="${_oarr:-CEN_MATCHPATH}";_varr=()
local _item _stat=1
for _item in "$@";do
$_smat -- "$_item"||continue
if [ -n "$_otyp" ];then
[ $_otyp "$_item" ]||continue
fi
if [ -n "$_orea" ];then
[ -r "$_item" ]||continue
fi
if [ -n "$_owri" ];then
[ -w "$_item" ]||continue
fi
if [ -n "$_oexe" ];then
[ -x "$_item" ]||continue
fi
_stat=0
[ -n "$_opre" ]&&_cen_path_pretty -p _item "$_item"
$_scal "$_item"||continue
_varr+=("$_item")
[ -n "$_oone" ]&&break
done
if [ -n "$_ostr" ];then
if [ "${#_varr[@]}" -le 1 ];then
local -n _rslt="$_ostr";_rslt="$_varr"
else
splitjoin -j "$_ostr" -d '\n' -i "$_oarr"
fi
fi
return $_stat
}
move() {
local _oftl _orep _orun _osys='-e -p' _oerr=error _omsg="$CEN_TRACE"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-f) _oftl='-f';_osys='-f -p';_oerr=fatal;;
-o) _orem=1;;
-q) _orep='-q';_osys='-q';_oerr="$CEN_TRACE";;
-r) _orun='-r';;
-s) _orep='-s';_omsg=:;;
-v) _orep='-v';_omsg=message;;
-x) _orem=2;;
*) _cen_abort - "$1"
esac;shift
done
local _dest="$2"
if [ $# -gt 2 ];then
_dest="${@:$#}";_orem=
if [ ! -d "$_dest" ];then
$_oerr $"Move destination is not a folder:" "$_dest";return 1
fi
elif [ $# -lt 2 ];then
_cen_abort $"Missing arg(s)"
fi
if [ -e "$_dest" ];then
if [ -z "$_orem" ];then
if [ ! -w "$_dest" ];then
$_oerr $"Move destination not writable:" "$_dest";return 1
fi
elif [ "$_orem" = 2 ];then
[ "$_osmg" = : ]||$CEN_TRACE -a $"Removing destination before move:" "$_dest"
remove $_oftl $_orun $_orep -d -- "$_dest"||return 1
fi
fi
$_omsg -a -p $"Moving '%s' to '%s'" "${*:1:$#-1}" "$_dest"
sysrun $_orun $_osys -b -o 'move()' -- mv -f -- "${@:1:$#-1}" "$_dest"&&return 0
[ -n "$CEN_OPT_DRYRUN" ]
}
CEN_PRETTYPATH=
prettypath() {
local _ocan _oerr='error' _oexi _obas _otrm _logi _phys
local _fset='CEN_PRETTYPATH' _fltr='-l'
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) _obas=1;;
-c) _ocan=2;;
-e) _oexi=1;;
-f) _oerr='fatal';;
-l) _ocan=1;;
-n) _fltr='-n';;
-p) _phys=1;;
-q) _oerr=:;;
-s) shift;_fset="$1";;
-t) shift;_otrm="$1";;
-w) _oerr='warning';;
*) _cen_abort - "$1"
esac;shift
done
local -n _varg="$_fset";[ $# = 0 ]&&set -- "$_varg"
_varg=
if [ -n "$_oexi" ];then
if [ ! -e "$1" ];then
$_oerr $"No such file or folder:" "$1";_varg=;return 1
fi
fi
if [ "$_ocan" = 1 ];then
_cen_path_realp -l "$1"&&_varg="$_logi"
elif [ -n "$_ocan" ];then
_cen_path_realp -c "$1"&&_varg="$_logi"
else
_cen_path_pretty -p "$_fset" "$1"
if [[ "$_varg" == *..* ]];then
_cen_path_realp -a "$1"&&_varg="$_logi"
fi
fi
if [ -n "$_obas" ];then
_varg="${_varg%/*}";[ -z "$_varg" ]&&_varg=/
fi
if [ -z "$_phys" ];then
_cen_path_regex "$_fltr" "${_varg:-$1}";_varg="$_logi"
fi
_cen_path_ltrim "$_otrm" "$_varg"&&_varg="$_logi"
return 0
}
CEN_READLINE=
readline() {
local _oerr='trace' _finp _oqui= _oarr _oexi _vnam='CEN_READLINE' _mesg
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vnam="$1";_oarr='-a';;
-e) _oerr='error';;
-f) _oerr='fatal';;
-h) shift;_finp="/dev/fd/$1";;
-i) shift;_finp="$1";;
-q) _oqui=1;;
-s) shift;_vnam="$1";_oarr=;;
-w) _oerr='warning';;
-x) _oexi=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ ! -r "$_finp" ];then
[ -z "$_oexi" ]&&return 2
_mesg=$"Cannot read from:"" $_finp"
elif ! read $_oarr $_vnam <"$_finp" &>/dev/null;then
_mesg=$"Failed to read from:"" $_finp"
elif [ -z "$_oqui" ];then
trace -a -c ' file OK' -- "$_finp"
fi
[ -z "$_mesg" ]&&return 0
$_oerr -- "$_mesg";return 1
}
CEN_REDIRECT=
redirect() {
local _sinp _sout _ocnt=0 _oapp _ofnd _osav _hndl _oaop='>' _oerr='error -z' _otra="$CEN_TRACE"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_sout="${1:--}";_oapp='-a' _oaop='>>';;
-f) shift;((_ocnt += 1));_osav="${1:--}";_ofnd=1;;
-h) shift;((_ocnt += 1));_hndl="$1";;
-i) shift;_sinp="${1:--}";;
-o) shift;_sout="${1:--}";;
-q) _oerr="$CEN_TRACE";;
-s) _otra=:;;
-v) shift;((_ocnt += 1));_osav="${1:--}";;
-x) shift;_sout="${1:--}";_oapp='-a' _oaop='>';;
*) _cen_abort - "$1"
esac;shift
done
[ "$_ocnt" = 1 ]||_cen_abort - '-f|-h|-v'
local -n _ovar;[ -n "$_osav" ]&&_ovar="$_osav"
if [ -z "$_sinp$_sout$_ofnd" ];then
if [ -n "$_osav" ];then
_hndl="$_ovar";_ovar=
fi
CEN_REDIRECT=
[ -z "$_hndl" ]&&return 0
[ -e "/dev/fd/$_hndl" ]||return 0
$_otra -a 'redirect:' $"closing file handle:" "$_hndl"
[ "$CEN_VERB" -gt 2 ]&&dryrun -r "exec $_hndl>&-"
eval exec "$_hndl>&-";return
fi
if [ -n "$_ofnd" -o -z "$_hndl" ];then
[ -n "$_osav" ]&&_ovar=
if [ -n "$_hndl" ];then
if [ -e "/dev/fd/$_hndl" ];then
$_oerr -p $"File handle %s is in use" "$_hndl";return 1
fi
elif [ -z "$_osav" ];then
$_oerr $"Got no variable to save file handle";return 1
else
_cen_handle _hndl
$_otra -a 'redirect:' $"found file handle:" "$_hndl" "${_sinp:-$_sout}"
_ovar="$_hndl";[ -n "$_ofnd" ]&&return 0
fi
fi
[ -n "$_osav" ]&&_ovar=
if [ -n "$_sinp" ];then
CEN_REDIRECT=
embed -r -m '_centauri_bash_iom'
inpfile -e -f -l -s CEN_REDIRECT -- "$_sinp"||return 1
[ "$CEN_VERB" -gt 2 ]&&dryrun -r "exec $_hndl<$CEN_REDIRECT"
eval exec "$_hndl<'$CEN_REDIRECT'" || return 1
elif [ -n "$_sout" ];then
CEN_REDIRECT=
embed -r -m '_centauri_bash_iom'
outfile $_oapp -f -l -s CEN_REDIRECT -- "$_sout"||return 1
[ "$CEN_VERB" -gt 2 ] &&  dryrun -r "exec $_hndl$_oaop'$CEN_REDIRECT'"
eval exec "$_hndl$_oaop'$CEN_REDIRECT'" || return 1
fi
[ -n "$_osav" ]&&_ovar="$_hndl";return 0
}
remove() {
local _oerr='-e -p' _orec _ofrc='-f' _oone _orun _omsg="$CEN_TRACE" _oitm=$"file" _smpl
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-d) _orec='-r';;
-e) _ofrc=;;
-f) _oerr='-f -p';;
-o) _oone='--one-file-system';;
-q) _oerr='-q';;
-r) _orun='-r';;
-s) _omsg=:;;
-v) _omsg=message;;
*) _cen_abort - "$1"
esac;shift
done
if [ $# = 1 ];then
[ "${1:--}" = - ]&&return 0
if [ -h "$1" ];then
_oitm=$"symlink";_smpl=unlink
elif [ -d "$1" ];then
_oitm=$"folder"
[ -z "$_orec" ]&&_smpl=rmdir
elif [ ! -e "$1" ];then
return 0
else
_smpl=unlink
fi
elif [ $# = 0 ];then
return 0
else
_oitm=$"entries"
fi
$_omsg -a -c " $_oitm" -- "$*"
if [ -n "$_oone" ];then
sysrun $_oerr $_orun -i -- rm $_oone $_orec $_ofrc -- </dev/null "$@"&&return 0
elif [ -n "$_smpl" ];then
sysrun $_oerr $_orun -d -b -o "$_oitm" \
               -m $"Cannot remove %s: %s" -- $_smpl -- "$1" && return 0
else
sysrun $_oerr $_orun -b -- rm $_orec $_ofrc -- "$@" </dev/null&&return 0
fi
[ -n "$CEN_OPT_DRYRUN" ]
}
rename() {
local _oftl _omis _orep _orun _osys='-e -p' _oerr=error _omsg="$CEN_TRACE" _suff
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-b) shift;_suff="${1#.}";_orem=1;;
-f) _oftl='-f';_osys='-f -p';_oerr=fatal;;
-m) _omis=1;;
-o) _orem=1;;
-q) _orep='-q';_osys='-q';_oerr="$CEN_TRACE";;
-r) _orun='-r';;
-s) _orep='-s';_omsg=:;;
-v) _orep='-v';_omsg=message;;
-x) _orem=2;;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_omis" ];then
[ -e "$1" -o -h "$1" ]||return 0
fi
[ "$#" = 1 -a -z "$_suff" ]&&_suff='bak'
local _dest="$2"
if [ -n "$_suff" -a $# -ge 1 ];then
[ $# -gt 1 ]&&_cen_abort $"Extra arg(s)" "$_dest"
[ -e "$1" ]||return 0
_dest="$1.$_suff";_orem=1
elif [ $# -gt 2 ];then
_cen_abort $"Extra arg(s)" "$*"
elif [ $# -lt 2 ];then
_cen_abort $"Missing arg(s)"
fi
if [ -e "$_dest" ]||[ -h "$_dest" ];then
if [ -z "$_orem" ];then
$_oerr $"Rename destination exists:" "$_dest";return 1
elif [ -d "$_dest" ];then
if [ "$_orem" != 2 ];then
$_oerr $"Rename destination is a folder:" "$_dest";return 1
fi
[ "$_osmg" = : ]||$CEN_TRACE -a $"Removing destination before rename:" "$_dest"
remove $_oftl $_orun $_orep -d -- "$_dest"||return 1
fi
fi
$_omsg -a -c ' ' -- "$1 => $_dest"
sysrun -b $_orun $_osys -- mv -f -- "$1" "$_dest"&&return 0
[ -n "$CEN_OPT_DRYRUN" ]
}
CEN_RESOLVE=
resolve() {
local _ocan _otrm _oexe _osys='-e -p' _pret \
          _vset="CEN_RESOLVE" _varr _vrrr _xchk _xerr=error _nret=0
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vset=;local -n _vvaa="$1";_vvaa=();;
-c) _ocan='-e';;
-e) _xchk=1;;
-f) _xerr=fatal;_osys='-f -p';;
-l) _olnk='-l';;
-m) _ocan='-m';;
-p) _pret=1;;
-q) _xerr=:;_osys='-q';;
-s) shift;_vset="$1";_varr=;;
-t) shift;_otrm="$1";;
-x) _oexe=1;;
-y) _oexe=2;;
*) _cen_abort - "$1"
esac;shift
done
if [ -n "$_vset" ];then
local -n _vsss="$_vset";_vsss=
fi
if [ -n "$_oexe" ];then
local _logi _self="$CEN_TOOLS:$CEN_LIBRARY:${BASH_ARGV0%/*}"
[ -n "$1" ]&&PATH="$PATH:$_self" sysrun -q -r -a _logi -- type -f -p -- "$1"
if [ -z "$_logi" ];then
[ -h "$BASH_ARGV0" ]&&_cen_path_realp -c "$BASH_ARGV0"||_logi="$BASH_ARGV0"
case "$_logi" in
/*/*) _self="${_logi%/*}";;
/*) _self=/;;
*/*) _self="$PWD/${_logi%/*}";;
*) _self="$PWD"
esac
set -- "$_self${1:+/}$1"
if [ "$_oexe" = 1 ];then
[ -x "$1" ]||_nret=1
else
[ -e "$1" ]||_nret=1
fi
else
set -- "$_logi"
fi
fi
if [ -n "$_xchk" ];then
local _file _flst=()
for _file in "$@";do
if [ -h "$_file" ]||[ -e "$_file" ];then
_flst+=("$_file");continue
fi
$_xerr $"No such file or folder:" "$_file";_nret=1
done
set -- "${_flst[@]}"
fi
if [ -n "$_ocan" -o -n "$_olnk" ];then
if [ $# = 1 ];then
if [ "$_ocan" = '-e' ]&&[ ! -e "$1" ];then
$_xerr $"No such file or folder:" "$1";return 1
else
_cen_path_realp ${_olnk:--c} "$1"||return 1;set -- "$_logi"
fi
elif [ $# -gt 1 ];then
sysrun $_osys -a _vrrr -r -- readlink $_ocan -- "$@"||return 1
set -- "${_vrrr[@]}"
fi
fi
if [ -n "$_pret" -o -n "$_otrm" ];then
_vrrr=()
for _logi in "$@";do
if [ -n "$_pret" ];then
_cen_path_pretty -e -p _logi "$_logi"||continue
_cen_path_regex '-l' "$_logi"
fi
[ -n "$_otrm" ]&&_cen_path_ltrim "$_otrm"
_vrrr+=("$_logi")
done
set -- "${_vrrr[@]}"
fi
if [ -n "$_vset" ];then
splitjoin -j "$_vset" -d '\n' -- "$@"
else
_vvaa=("$@")
fi
return $_nret
}
splitkeyval() {
local _vkey="${2:--}" _vval="${3:--}" _deli="${4:-=}" _skey _sval _stat=0
_skey="${1%%$_deli*}"
[ "$_skey" = "$1" ]&&_stat=1||_sval="${1#*$_deli}"
[ "$_vkey" = - ]||printf -v $_vkey '%s' "$_skey"
[ "$_vval" = - ]||printf -v $_vval '%s' "$_sval"
return $_stat
}
splitpath() {
local _vset _oext _odmy _opar _left _righ _path _ofir _ospl _owrk _pref
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vset="$1";local -n _vvaa="$1";_vvaa=();;
-e) _oext=1;;
-f) _ofir=1;_ospl=1;;
-g) _oext=2;;
-p) _opar=1;_ospl=1;;
-w) _owrk=1;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$_vset" ]&&_cen_abort = '-a'
_path="${1:-.}";[ "$_path" = '.' ]&&_path="$PWD"
case "$_path" in
/);;
/*/) _path="${_path:1}";_pref=/
_cen_path_pretty _path "${_path::-1}";[ -n "$_oext" ]&&_odmy=1;_oext=;;
/*) _cen_path_pretty _path "${_path:1}";_pref=/;;
*/) _cen_path_pretty -p _path "${_path::-1}";[ -n "$_oext" ]&&_odmy=1;_oext=;;
*) _cen_path_pretty -p _path "$_path"
esac
if [[ "$_path" == *..* ]];then
sysrun -q -r -b -a _path -- readlink -s -m -- "$1"||return 2
fi
if [ "$_path" = / ];then
_vvaa=('' / '');return 1
fi
if [ -n "$_ofir" ];then
_left="${_path%%/*}";_righ="${_path#*/}"
elif [ -n "$_opar" ];then
_left="${_path%/*}";_righ="${_path##*/}"
fi
if [ -n "$_ospl" ];then
if [ "$_left" = "$_righ" ];then
_vvaa=("$_pref");_path="$_righ"
else
_vvaa=("$_pref$_left");_path="$_righ"
fi
else
_path="$_pref$_path"
fi
if [ "$_oext" = 2 ];then
_left="${_path%%.*}";_righ="${_path#*.}"
[ "$_left" = "$_righ" ]&&_righ=
_vvaa+=("$_left" "$_righ")
elif [ -n "$_oext" ];then
_left="${_path%.*}";_righ="${_path##*.}"
[ "$_left" = "$_righ" ]&&_righ=
_vvaa+=("$_left" "$_righ")
else
_vvaa+=("$_path")
[ -n "$_odmy" ]&&_vvaa+=("")
fi
if [ -n "$_owrk" ];then
[ "$_vvaa" = "$PWD" ]&&_vvaa=||_vvaa="${_vvaa#$PWD/}"
fi
return 0
}
CEN_SUFFIXPATH=
suffixpath() {
local _vnam='CEN_SUFFIXPATH' _suff _from _optd _olow _orem _oxcl
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-) break;;
-c) shift;_from="$1";;
-d) _optd=1;;
-l) _olow=1;;
-r) _orem=1;;
-s) shift;_vnam="$1";;
-x) _oxcl=1;;
*) _cen_abort - "$1"
esac;shift
done
local -n _vsuf="$_vnam"
[ $# -gt 1 ]&&_vsuf="$2"
local _snam="${_vsuf##*/}"
[ -z "$_snam" ]&&return 1
_snew="${1#.}";[ -z "$_snew" ]&&return 1
if [ "${_snam:${#_snam}-1:1}" = '.' ];then
[ -n "$_oxcl" -a -d "$_vsuf" ]&&return 1
_vsuf="${_vsuf::${#_vsuf}-1}";return 0
fi
local _scur="${_snam#*.}"
if [ "$_scur" = "$_snam" ];then
[ -n "$_orem" ]&&return 0
[ -n "$_oxcl" -a -d "$_vsuf" ]&&return 1
_vsuf+=".$_snew";return 0
elif [ -z "$_optd" -a -z "$_from" -a -z "$_orem" ];then
[ -n "$_oxcl" -a -d "$_vsuf" ]&&return 1
_vsuf+=".$_snew";return 0
fi
if [ -n "$_olow" ];then
_scur="${_scur,,}";_from="${_from,,}"
fi
if [ -n "$_from" ]&&[ "$_from" = - -o "$_from" = "$_scur" ];then
[ -n "$_oxcl" -a -d "$_vsuf" ]&&return 1
_vsuf="${_snam%.*}.$_snew";_scur="$_snew"
fi
[ -z "$_orem" ]&&return 0
if [ "$_orem" = - -o "$_scur" = "$_orem" ];then
[ -n "$_oxcl" -a -d "$_vsuf" ]&&return 1
_vsuf="${_snam%.*}"
fi
return 0
}
symlink() {
local _fign _targ _ocan _odir _oftl='error' _onck _orel _osys='-e -p' _move _mesg="$CEN_TRACE"
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) _ocan=1;;
-d) _odir=1;;
-f) _oftl='fatal';_osys='-f -p';;
-i) _fign=1;;
-m) _move=1;;
-n) _onck='-f';;
-q) _oftl=:;_osys='-q';;
-r) _orel=1;;
-s) _mesg=:;;
-v) _mesg='message';;
-w) _oftl='warning';_osys='-w -p';;
-x) _move=0;;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$1" ]&&_cen_abort +
local _etxt _link="$2" _targ="${1%/}"
[ -z "$1" ]&&_targ=/
[ -z "$_link" ]&&_link="${_targ##*/}"
if [ $# -gt 2 ];then
local _leng="$#";_link="${!_leng}"
folder ${_osys//-[ep]/} -- "$_link"||return 1
sysrun $_osys -i -m "$_etxt" -d -- ln $_onck $_orel -s -- "$@"||return 2
return 0
fi
if [ -z "$_onck" -o -n "$_fign" ];then
if [ ! -e "$_targ" ];then
[ -z "$_fign" ]&&$_oftl $"Link target does not exist:" "$_targ"
[ -z "$_onck" ]&&return 1
$_mesg -a -c $"Stale symlink" "$_link"
fi
fi
if [ -e "$_link" ];then
if [ "$_move" = 0 ];then
remove -d -- "$_link"||return 2
elif [ -h "$_link" ];then
if [ -n "$_move" ];then
remove -- "$_link"
elif [ "$_targ" -ef "$_link" ];then
$_mesg -a -c $"Link is current" "$_link";return 0
elif [ -z "$_odir" -a -n "$_onck" ]&&[ -d "$_link" ];then
remove -d -- "$_link"
fi
elif [ -n "$_move" ];then
sysrun $_osys -b -- mv -f -- "$_link" "$_link.$CEN_NAME"||return 2
$_mesg -a $"Link '$_link' file/fldr moved"": $_link.$CEN_NAME"
elif [ -d "$_link" ];then
if [ -n "$_odir" ];then
$_mesg -a $"Link is a folder:" "$_link"
else
$_oftl $"Link is an existing folder:" "$_link";return 2
fi
elif [ -z "$_onck" ];then
$_oftl $"Link is an existing file:" "$_link";return 2
fi
elif [ -h "$_link" ];then
_onck='-f'
fi
_etxt=$"Failed to create symbolic link"': %s%s'
if [ -n "$_orel" ];then
sysrun $_osys -m "$_etxt" -i -- ln $_onck -s -r -- "$_targ" "$_link"||return 1
else
sysrun $_osys -b -m "$_etxt" -d -- ln $_onck -s -- "$_targ" "$_link"||return 1
fi
$_mesg -a -c $" created" -- "$_link => $_targ";return 0
}
sysrun() {
$CEN_NOTRACE set +x
local _ecmd="$CEN_TRACE" _emsg _vstr _vnam
local _ofmt _oign _osta _opre _orun _oout _over _owho _fqui _ffnd=1
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) shift;_vnam="$1";_oout=0;;
-b) _ffnd=0;;
-c) shift;_osta="$1";;
-d) _opre=1;;
-e) _ecmd=error;;
-f) _ecmd=fatal;;
-i) _oign='-i';;
-m) shift;_emsg="$1";[ -z "$_oout" ]&&_oout=0;;
-n) _ffnd=;;
-o) shift;_owho="$1";;
-p) _ofmt=1;[ -z "$_oout" ]&&_oout=0;;
-q) _fqui=1;[ -z "$_oout" ]&&_oout=0;;
-r) _orun='-r';;
-s) shift;_vstr="$1";_oout=0;_vnam=-;;
-v) _over=1;;
-w) _ecmd=warning;;
-z) _oout=1;;
*) _cen_abort - "$1"
esac;shift
done
local _xmsg _xerr _xarg _xtmp _xcmd="$1" _outf;shift
[ -z "$_vnam" -a -n "$_ofmt" ]&&_vnam=-
[ "$_vnam" = - ]&&{ local _cen_ext_sysrun;_vnam='_cen_ext_sysrun';}
if [ -z "$_osta" ];then
if [ -z "$_ffnd" ];then
_opre=
elif [ "${_xcmd/\//}" != "$_xcmd" ];then
_opre=
else
_xtmp="${CEN_COMMANDS["${_xcmd:--}"]}"
if [ "$_xtmp" = - ];then
if [ -z "$_oign" ];then
_xtmp="$_xcmd"
else
sysfind -i -s _xtmp -- "$_xcmd"||_osta=127
fi
elif [ -n "$_xtmp" ];then
_xtmp+="/$_xcmd"
if [ "$_ffnd" = 0 ];then
if BASH_LOADABLES_PATH= enable -a "$_xcmd" &>/dev/null;then
_xtmp="$_xcmd"
elif PATH= type -t -- "$_xcmd" >/dev/null;then
[ -n "${CEN_MODULES["_centauri_bash_dyn"]}" ] &&
_cen_dyn_builtin "$_xcmd" >/dev/null&&_xtmp="$_xcmd"
fi
fi
elif ! sysfind ${_oign:--b} -c -s _xtmp -- "$_xcmd";then
_osta=127
fi
if [ "${_xtmp::1}" = / ];then
_opre=;_xcmd="${_xtmp/\/\//\/}"
elif [ -n "$_xtmp" ];then
_xcmd='builtin';set -- "$_xtmp" "$@"
fi
fi
[ -z "$_owho" ]&&_owho="$_xcmd"
fi
if [ -z "$_osta" ];then
if [ -n "$_opre" ];then
local _afix=()
while [ $# -gt 0 ];do
if [ "$1" == '--' ];then
if [ "${2::1}" = - ];then
_afix+=("./$2");shift
fi
shift;break
fi
_afix+=("$1");shift
done
set -- "${_afix[@]}" "$@"
fi||:
if dryrun $_orun -- "$_xcmd" "$@";then
$CEN_NOTRACE set -x;return 1
fi
if [ -n "$_vnam" ];then
_osta=0
[ "$CEN_EXT_TPID" = "$$" ] && _outf="${CEN_EXT_TEMP}0" \
                                       || tmpfile ${_orun:+-r} -s _outf -f -n 0
if [ "$_oout" = 0 ];then
"$_xcmd" "$@" &>"$_outf"||_osta=$?
else
"$_xcmd" "$@" 2>"$_outf"||_osta=$?
fi
IFS=$'\n' read -a "$_vnam" -d '' -r <"$_outf"
elif [ "$_oout" = 0 ];then
"$_xcmd" "$@" &>/dev/null;_osta=$?
else
"$_xcmd" "$@";_osta=$?
fi||:
fi
if [ -n "$_vstr" ];then
local -n _rarr="$_vnam"
if [ "${#_rarr[@]}" -le 1 ];then
local -n _rslt="$_vstr";_rslt="$_rarr"
else
splitjoin -j "$_vstr" -d '\n' -i "$_vnam"
fi
fi
[ -z "$_osta" ]&&_osta=1
if [ "$_osta" = 0 -o -n "$_fqui" ];then
$CEN_NOTRACE set -x;return $_osta
fi
case "$_osta" in
1);;
2) _xmsg=$"Invalid argument(s)";;
126) _xmsg=$"File not executable";;
127) _xmsg=$"Program not found";;
*) if [ "$_osta" -gt 128 ];then
_xmsg=$"Signal"" $((_osta - 128))"
else
_xmsg=$"Status"" $_osta"
fi
esac
[ "${_emsg:--}" = '-' ] && _emsg=$"Running '%s%s' failed"
[ -n "$_xmsg" ]&&_xmsg=": $_xmsg"
if [ "$_ecmd" = "$CEN_TRACE" -a -n "$_ofmt" ];then
splitjoin -j _xtmp -d '\n' -i "$_vnam"
message -n "$_xtmp"
$CEN_NOTRACE set -x;return $_osta
elif [ -n "$_ofmt" ];then
splitjoin -s _xtmp -d '\n' -i "$_vnam"
_xarg="${_xtmp#/*: }"
if [ "$_xcmd" = 'builtin' -a "$_xarg" != "$_xtmp" ];then
_xarg="${_xarg#[[:alpha:]]*[0-9]: }"
_xarg="${_xarg#$1: }"
fi
splitjoin -j _xarg -n -- "$_xarg" "${_xtmp[@]:1}"
[ "$_xcmd" = 'builtin' ]&&_xtmp=" $1"||_xtmp=
[ -n "$_over" ]&&_xtmp+=" $*"
$_ecmd -n -p "$_emsg%s\n%s" "${_owho:-($_xcmd)}" "$_xtmp" "$_xmsg" "$_xarg"
else
[ "$_xcmd" = 'builtin' ]&&_xtmp=" $1"||_xtmp=
[ -n "$_over" ]&&_xtmp+=" $*"
$_ecmd -p "$_emsg$_xmsg" "${_owho:-($_xcmd)}" "$_xtmp"
fi
$CEN_NOTRACE set -x;return $_osta
}
CEN_TMPFILE=
CEN_EXT_TSUB=
tmpfile() {
local _odel _oftl _onoc _opip _oerr='error -z' _orun _updt _snam='CEN_TMPFILE' _base
while [ "${1::1}" = - ];do
case "$1" in
-) break;;
--) shift;break;;
-b) shift;[ "${1:--}" = - ]||_base="${1%/}";_updt=1;;
-d) _odel=1;;
-f) _oerr=fatal;_oftl='-f';;
-i) CEN_EXT_TSUB="$BASHPID";CEN_EXT_TPID=;return 0;;
-n) _onoc=1;;
-p) _opip=1;;
-r) _orun='-r';;
-s) shift;_snam="$1";;
-t) _base=;_updt=1;;
-v) _base=-;_updt=1;;
*) _cen_abort - "$1"
esac;shift
done
if [ -z "$_base" -a -z "$_updt" ];then
_base="${XDG_RUNTIME_DIR:-$CEN_EXT_TEMP}"
[ -z "$_base" ]&&_updt=1
fi
local _ssuf
if [ "$CEN_EXT_TPID" != "$BASHPID" ];then
[ -z "$CEN_EXT_TPID" ]&&_updt=1
CEN_EXT_TIDX=1
CEN_EXT_TPID="$BASHPID"
fi
if [ "$CEN_EXT_TPID" != "$$" ];then
[ "$CEN_EXT_TSUB" != "$BASHPID" ]&&_ssuf="$BASHPID-"
fi
if [ -n "$_updt" ];then
local _name="${LOGNAME:-$USER}"
[ "$EUID" = 0 ]&&_name='root'
[ "$_base" = - ] &&
[ -d "${CEN_PATHS[3]}/tmp" ]&&_base="${CEN_PATHS[3]}/tmp/centauri-${_name:-$EUID}"
[ "${_base:--}" = - ] &&
_base="${CEN_PATHS[4]}/centauri-${_name:-$EUID}"
if [ -z "$_odel" ];then
if [ -n "$CEN_EXT_TEMP" ];then
_updt="${CEN_EXT_TEMP%/*}"
[ "$_updt" = "$_base" ]||$CEN_TRACE2 -c $" update" -- "$_updt => $_base"
fi
folder $_oftl $_orun -m -s _base -- "$_base" 700||return 1
fi
CEN_EXT_TEMP=
_base+="/$CEN_NAME-${CEN_EXT_TSUB:-$$}-"
else
_base="$CEN_EXT_TEMP"
fi
if [ -n "$_odel" ];then
[ -z "$_base" ]&&return 0
$CEN_TRACE2 -c $" remove" -- "$_base$_ssuf*"
CEN_EXT_TEMP=;CEN_TMPFILE=
[ -d "$_base" ]&&return 0
set +f;set -- "$_base$_ssuf"*
[ "$1" = "$_base$_ssuf*" ]&&return 0
sysrun $_orun -q -b -- rm -f -r -- "$@";return
fi
if [ -z "$CEN_EXT_TEMP" ];then
CEN_EXT_TEMP="$_base"
fi
[ -n "$_onoc" -a -z "$_snam" ]&&return 0
local _suff="${1:--}";local -n _svar="$_snam"
case "$_suff" in
-) _svar="$CEN_EXT_TEMP$_ssuf$((CEN_EXT_TIDX++))";;
.*) _svar="$CEN_EXT_TEMP$_ssuf${_suff#.}";;
*) _svar="$CEN_EXT_TEMP$_ssuf$_suff"
esac
[ -n "$_onoc" ]&&return 0
if [ -z "$_opip" ];then
dryrun $_orun ">'$_svar'" && return 1
2>/dev/null >"$_svar"&&return 0
$_oerr $"Cannot create" "$_svar"||return 1
else
sysrun -e -b $_orun -- mkfifo "$_svar"||return 1
fi
return 0
}
CEN_WALK_FILES=()
CEN_WALK_DIRS=()
CEN_WALK_LEVEL=0
declare -g -A CEN_WALK_DMAP
walk() {
local _fdir=false _ffil=: _fexc=: _frec _fadd _fbro _fhid _fnod _fext=() _stat _levl=999999999
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-a) _fadd=1;;
-b) _fbro=1;;
-c) _fexc='filter --';;
-d) shift;_fdir="$1";;
-e) shift;_fext+=("$1");;
-f) shift;_ffil="$1";;
-h) _fhid=1;;
-l) shift;_levl="$1";;
-n) _fnod=1;;
-r) _frec=1;;
-i) _fexc='filter -i --';;
*) _cen_abort - "$1"
esac;shift
done
_cen_walk() {
((CEN_WALK_LEVEL += 1))
local _item _inam _dirs=() _stat=0
for _item in "$@";do
_item="${_item/\/\//\/}"
if [ -d "$_item" ];then
[ -n "$_fnod" ]&&[ -h "$_item" ]&&continue
_dirs+=("$_item");continue
elif [ -e "$_item" ];then
_inam="${_item##*/}"
elif [ -h "$_item" ];then
[ -n "$_fbro" ]||continue
_inam="${_item##*/}"
else
continue
fi
if [ -n "$_fext" ];then
local _iext=0 _sext="${_inam##*.}"
while [ $_iext -lt "${#_fext[@]}" ];do
if [ "$_sext" = "${_fext[_iext]}" ];then
_iext=-1;break
fi
((_iext += 1))
done
[ $_iext = -1 ]||continue
fi
$_fexc "$_inam"||continue
$_ffil "$_item";_stat=$?
[ "$_stat" -ge 2 ]&&break
[ "$_stat" = 0 ]&&CEN_WALK_FILES+=("$_item")
done
if [ -n "$_dirs" -a "$_stat" -lt 3 ];then
local _full _indx=0 _cen_walk_dirn
resolve -a _cen_walk_dirn -m -- "${_dirs[@]}"||return 3
for _item in "${_dirs[@]}";do
_full="${_cen_walk_dirn[_indx++]}"
[ -n "${CEN_WALK_DMAP[$_full]}" ]&&continue
CEN_WALK_DMAP[$_full]="$_item"
_stat=0
if [ "$_ffil" = 'false' ];then
$_fexc "${_full##*/}";_stat=$?
fi
if [ "$_stat" = 0 ];then
$_fdir "$_full" "$_item";_stat=$?
fi
[ "$_stat" -ge 3 ]&&break
[ "$_stat" = 0 ]&&CEN_WALK_DIRS+=("$_full")
[ -z "$_frec" -o "$_stat" = 2 ]&&continue
[ "$CEN_WALK_LEVEL" -gt "$_levl" ]&&continue
_stat=0
if [ -n "$_fhid" ];then
_cen_walk "$_item"/.[!.]* "$_item"/*||_stat=$?
else
_cen_walk "$_item"/*||_stat=$?
fi
[ "$_stat" -ge 2 ]&&break
done
fi
((CEN_WALK_LEVEL -= 1))
return "$_stat"
}
if [ -z "$_fadd" ];then
CEN_WALK_FILES=();CEN_WALK_DIRS=();CEN_WALK_DMAP=()
fi
_stat=0;_cen_walk "$@"||_stat=$?
[ "$_stat" -ge 3 ]&&return "$_stat"
[ "${#CEN_WALK_FILES[@]}" = 0 -a "${#CEN_WALK_DIRS[@]}" = 0 ]&&return 1
return 0
}
_cen_ext_quit() {
[ "$CEN_EXT_TEMP" ]&&tmpfile -d -r
}
:
}
_cen_bash_load_use(){
CEN_MODULES['_centauri_bash_use']='0.24:2'
CEN_USE_USAGE=
CEN_USE_ADDOPTS=
CEN_USE_ADDVERB=
CEN_USE_OPTIONS=
CEN_USE_ACTIONS=
CEN_USE_PARAMS=
CEN_USE_EXAMPLE=
CEN_USE_OTHER=
CEN_CONS_UTF8=
declare -g -A CEN_USE_OMAP
usageparser() {
local _popt
local _sopt
local _otra="$CEN_TRACE"
local _vers=-
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-c) _popt="$1";;
-m) _popt="$1";_vers=;;
-s) _sopt="$1";_otra=:;;
*) _cen_abort - "$1"
esac;shift
done
local _work="$1" _file="$2" _cadd="${3:-:}" _lcnt=0
_cen_use_worker() {
$_work "$_file" "$@"
}
_cen_use_warning() {
warning -a "$_file: $1, line $_lcnt: $2"
}
_cen_use_reformat() {
isfunction -e labelsplit||return 1
local _ause _text _left _temp _leng _frem _frag _ltmp _mode
if [ "$_file" = '/dev/stdin' ];then
splitjoin -s _ause -i - -n
else
LANG=C embed -a _ause -d '--' -- "$1" --help --verbose
fi
for _text in "${_ause[@]}";do
((_lcnt += 1))
_text="${_text%"${_text##*[! ]}"}"
if [ "${_text::1}" != ' ' ];then
if labelsplit _temp "$_text";then
[ -n "$_left" ]&&_cen_use_warning $"Redefined label" "${_left%:*}"
_frem=
if [ "${#_temp}" -le 10 ];then
_temp="${_temp^}        "
_left="${_temp::10}"
[ -z "${_text#*:}" ]&&continue
_text="$_left ${_text#*: }";_left=
else
_left="${_text#*:}";_text="${_temp^}"
[ -n "$_left" ]&&_text+=" $_left";_left=
fi
elif [ -n "$_text" ];then
_frem=1
fi
elif [ -z "$_frem" ];then
_temp="${_text%%[! ]*}";_leng="${#_temp}"
if [ "$_leng" -le 4 ];then
_frem=1
elif [ "$_leng" -ge 7 ];then
_text="   $_text"
fi
fi
if [ -n "$_left" ];then
if [ -n "$_frem" ];then
_cen_use_warning $"Orphaned label" "${_left%:*}"
else
_text="$_left${_text:10}";_left=
fi
fi
if [ -z "$_frem" ];then
if [ "${_text/ \# /}" != "$_text" ];then
_text="${_text//[[/[\'\'[\'\'}"
_body+=("$_text");continue
fi
if [ "${_text/§/}" = "$_text" ];then
_frag="${_text:27:4}"
case "$_frag" in
'    ');;
'>   ');;
?'>  ');;
??'> ');;
'.   ');;
'..  ');;
?'.. ');;
[-+\|\]]'   ');;
?[-+\|\]]'  ');;
??[-+\|\]]' ');;
*) _frag=
esac
if [ -n "$_frag" ];then
_ltmp="${_text::30}"
_text="${_ltmp} § ${_text:31}"
fi
fi
_text="${_text//[[/[\'\'[\'\'}"
_body+=("$_text");continue
fi
if [ -z "$_text" -o "${_text::7}" != '       ' ];then
_mode=
elif [ "$_mode" = 1 ];then
_text=",${_text:4}"
elif [ "$_mode" = 2 ];then
_text=".${_text:4}"
elif [ "${_text::9}" = '         ' ];then
_text=".${_text:4}";_mode=2
elif [ "${_text::7}" = '       ' ];then
_text=",${_text:4}";_mode=1
fi
_text="${_text//[[/[\'\'[\'\'}"
_body+=("$_text")
done
[ -n "$_left" ]&&_cen_use_warning $"Orphaned label" "${_left%:*}"
}
local _name _ause=() _body=()
if [ "$_file" != '/dev/stdin' ];then
CEN_EXIT=0
LANG=C embed -v -d $'\n' -a _ause -- "$_file" --info detailed
if [ "$CEN_EXIT" != 0 ];then
warning -a "$_file:" $"Bad exit status ignored" "($CEN_EXIT)"
CEN_EXIT=0
fi
[ "$_popt" = '-c' ]&&_cen_use_worker '0:B0'
[ -n "$_popt" ]&&_cen_use_worker "0:V${_ause[1]:--}"
_name="$_file:${_ause[0]:--}"
else
_name="${CEN_EMBED:-$CEN_NAME}:${_ause[0]:--}"
fi
if [ -z "$_popt" ];then
_cen_use_reformat "$_file"
CEN_DOC_BLOCK=(1 "${_body[@]}")
_cen_use_worker '0:B1' "0:S$_name" # "${_body[@]}"
_cen_use_worker "$_lcnt:E"
else
_cen_use_worker "0:S$_name"
$_cadd "$_file:0:V${_ause[1]:--}";$_cadd "$_file:0:S$_name"
[ "$_popt" = '-c' ]&&_cen_use_worker '0:E'
fi
}
isfunction usage||usage() { CEN_USE_OWNFLG=1;}
_cen_completion() {
isfunction "$1"||return 0
local cfun ckey cnam cflg cxxx cyyy carr=()
type "$1" | while read cfun ckey cnam cflg cxxx cyyy;do
if [ "${cfun##*_}" != "$2" ];then
[ "$1" = 'actions' ]||continue
cyyy="$cfun $ckey $cnam $cflg $cxxx $cyyy"
cyyy="${cyyy// /}"
cxxx="${cyyy%)}"
[ "$cyyy" = "$cxxx" ]&&continue
cyyy="${cxxx//|/ }"
[ -n "${cyyy//[ a-z]/}" ]&&continue
carr=($cyyy)
continue
fi
while [ "${#ckey}" = 2 -a "${ckey::1}" = - ];do
ckey="$cnam";cnam="$cflg";cflg="$cxxx"
done
[ "$1" = 'options' ]||cflg=
[ "$ckey" != - ]&&carr=("$ckey")
for ckey in "${carr[@]}";do
case "${cflg:--f}" in
-e);;
-f) _cen_use_writeln "$3${ckey//\"/}" ;;
-m);;
*) _cen_use_writeln "$3${ckey//\"/}="
esac
done
carr=()
done
if [ "$1" = 'actions' ];then
[ -n "$CEN_USE_ADDVERB" ]&&_cen_use_writeln "$CEN_USE_ADDVERB"
elif [ "$1" = 'options' ];then
[ -n "$CEN_FEATURE_D" ]&&echo '--dryrun'
[ -n "$CEN_FEATURE_F" ]&&echo '--force'
[ -n "$CEN_FEATURE_G" ]&&echo '--gui='
[ -n "$CEN_FEATURE_I" ]&&echo '--include= --exclude='
[ -n "$CEN_FEATURE_S" ]&&echo '--silent'
[ -n "$CEN_FEATURE_Y" ]&&echo '--yes --no'
embed -r -c '_centauri_bash_pip'&&echo '--pager='
[ -n "$CEN_USE_ADDOPTS" ]&&_cen_use_writeln "$CEN_USE_ADDOPTS"
fi
return 0
}
_cen_usage() {
CEN_USE_USAGE=1
if [ "$CEN_VERB" -gt 1 ];then
context -v 1;CEN_USE_USAGE=2
fi
local cmpl="${CEN_COMPLETION%%:*}" ctxt
[ "$cmpl" != "$CEN_COMPLETION" ]&&ctxt="${CEN_COMPLETION#*:}"
if [ "$cmpl" = 'verb' ];then
$CEN_HOOK_OPTIONS '--help' 'verb' "$ctxt"
_cen_completion actions invoke
exit 0
elif [ "$cmpl" = 'opts' ];then
$CEN_HOOK_OPTIONS '--help' 'opts' "$ctxt"
_cen_completion options optarg '--'
exit 0
fi
if [ -n "$CEN_FEATURE_T" ];then
local _mesg;export TEXTDOMAINDIR
system -q -r -s _mesg -- gettext -d "$CEN_NAME" "$CEN_TITLE"&&CEN_TITLE="$_mesg"
fi
if [ -z "$CEN_USE_HEADER" ];then
CEN_USE_HEADER="[<action> <argument>... [--]]..."
if [ -n "$CEN_FEATURE_R" ];then
CEN_USE_HEADER='<argument>'
[ "$CEN_RUN_MAX_ARGS" = 1 ]||CEN_USE_HEADER+='...'
[ "$CEN_RUN_MAX_ARGS" = 0 ]&&CEN_USE_HEADER=
fi
CEN_USE_HEADER=$"usage:"" $CEN_NAME <option>... $CEN_USE_HEADER"$'\n'
else
CEN_USE_HEADER+=$'\n'
fi
[ "$CEN_TITLE" ]&&CEN_USE_HEADER+=$'\n'"       $CEN_TITLE."
local orun omsg ogrp olin=$'\n'
CEN_USE_OMAP[d]='-d --dryrun          '$"show what would be done, make no changes"
CEN_USE_OMAP[f]='-f --force           '$"override prudent default behaviours"
CEN_USE_OMAP[g]='-g --gui     <mode>  '$"gui mode (0:=off  1:=windows  2:=terminal)"
CEN_USE_OMAP[i]='-i --include <expr>  '$"include only items matching the expression"
CEN_USE_OMAP[h]='-h --help            '$"show this text"
CEN_USE_OMAP["n"]="-n --no              "$"do not prompt for confirmation, assume 'no'"
CEN_USE_OMAP[s]='-s --silent          '$"generate less output or warnings"
CEN_USE_OMAP[q]='-q --quiet           '$"report errors only"
CEN_USE_OMAP[v]='-v --verbose         '$"be verbose (use twice for debug)"
CEN_USE_OMAP[x]='-x --exclude <expr>  '$"exclude the items matching the expression"
CEN_USE_OMAP["y"]="-y --yes             "$"do not prompt for confirmation, assume 'yes'"
CEN_USE_OMAP[z]='-z --zombie          '$"next action(s) even after error"
if [ "$CEN_VERB" -gt 1 ];then
CEN_USE_OMAP['z0']=' '
CEN_USE_OMAP['z1']='   --embed   <name>  '$"use <name> instead of script name"
CEN_USE_OMAP['z2']='   --info            '$"print full path and version"
CEN_USE_OMAP['z4']='   --trace           '$"trace actions() or run()"
CEN_USE_OMAP['z5']='   --wait            '$"prompt before exit"
fi
[ "$CEN_VERB" -gt 1 -o -n "$CEN_OPT_PAGER" ]&&embed -r -q '_centauri_bash_pip' &&
CEN_USE_OMAP["z3"]="   --pager   <prog>  "$"pipe output thru pager, use 'none' to disable"
_cen_use_check() {
local -n vval="$1"
if [ -z "$vval" ];then
CEN_USE_OMAP["$2"]=;[ -n "$3" ]&&CEN_USE_OMAP["$3"]=
else
[ -z "${CEN_USE_OMAP[$2]}" -o "${#vval}" -gt 1 ]&&CEN_USE_OMAP["$2"]="$vval"
fi
return 0
}
_cen_use_check CEN_FEATURE_G g
_cen_use_check CEN_FEATURE_I i x
[ -n "$CEN_FEATURE_R" ]&&CEN_USE_OMAP[z]=
$CEN_HOOK_OPTIONS '--help' 'opts'
_cen_use_check CEN_FEATURE_D d
_cen_use_check CEN_FEATURE_F f
_cen_use_check CEN_FEATURE_S s
_cen_use_check CEN_FEATURE_Y n y
CEN_USE_OPTIONS=$"options:"
for orun in {a..z} z{0..9} {0..9} "" {A..Z} Z{0..9};do
if [ -z "$orun" ];then
ogrp=1;continue
fi
omsg="${CEN_USE_OMAP[$orun]}";[ -z "$omsg" ]&&continue
omsg="       $omsg";[ -z "${omsg// /}" ]&&omsg=
omsg="${omsg//\\n/\\n       }"
if [ -n "$CEN_USE_OPTIONS" ];then
omsg="$olin$omsg"
[ -n "$ogrp" ]&&CEN_USE_OPTIONS+="$olin";ogrp=
fi
CEN_USE_OPTIONS+="$omsg"
done
_cen_use_output() {
usage;usageset -x
}
if [ "${CEN_OPT_PAGER:--}" = - -o "$CEN_OPT_PAGER" = 'yes' ] &&
[ -e "$CEN_LIBRARY/_centauri_bash_dyn" ];then
if sysfind -c -p "$CEN_TOOLS:$PATH" -s CEN_OPT_PAGER -- 'centaurihelp';then
embed -r -q '_centauri_bash_pip'&&syspager
fi
fi
if [ "${1:-1}" = 0 ];then
$CEN_PAGER _cen_use_output 2>&1;CEN_EXIT=0
else
$CEN_PAGER _cen_use_output 1>&2;CEN_EXIT=1
fi
CEN_VERB=1;quit
}
usagecat() {
local _flit _pger="${CEN_OPT_PAGER##*/}" _verb
while [ "${1::1}" = - ];do
case "$1" in
--) shift;break;;
-l) _flit=1;;
-v) shift;_verb="${1:--}";;
*) _cen_abort - "$1"
esac;shift
done
[ -z "$CEN_USE_USAGE" ]&&_cen_usage 1
[ "$_pger" = 'centaurihelp' ]&&_flit=1
[ "$_pger" = 'usage' ]&&_flit=1
[ "$_pger" = 'true' ]&&_flit=1
CEN_USE_OWNFLG=
if [ -n "$_verb" ];then
if [ "$CEN_USE_USAGE" -gt 1 ];then
_verb=2
else
[ -z "$_flit" ]&&_verb="${_verb//[°§]/ }"
_verb="${_verb/--/\"$CEN_NAME --help --verbose\"}"
if [ "$_verb" != - ];then
_cen_use_writeln "$_verb"
while [ "$#" -gt 0 ];do _cen_use_writeln "$1";shift;done
fi
return 1
fi
fi
local _text _last
while IFS= read -r _text;do
[ -z "$_flit" ]&&_text="${_text//[°§]/ }"
_cen_use_writeln "$_text"
_last="$_text"
done
[ -n "${_last// /}" ]&&echo
return 0
}
_cen_use_writeln() {
local _text="$*"
[ -z "$CEN_USE_UTF8" ]&&_text="${_text//•/\~}"
printf '%s\n' "$_text"
}
CEN_USE_OWNHDR=
CEN_USE_OWNLBL=
CEN_USE_OWNFLG=
CEN_USE_OWNSVC=
usageset() {
[ -z "$CEN_USE_USAGE" ]&&_cen_usage 1
local _sepa=$'\n' _mesg _copt _txt1 _txt2 _wide
while [ $# -gt 0 ];do
_copt="$1";shift;_txt2=
_txt1="$1";shift;[ "$_txt1" = - ]&&_txt1=
while [ $# -gt 0 ];do
case "$1" in
-[a-z]) break;;
-) _txt2=' ';;
*) _txt2+=" $1"
esac;shift
done
case "$_copt" in
'') break;;
-a) if [ -z "$CEN_USE_ACTIONS" ];then
CEN_USE_ACTIONS=$"actions:"
isfunction -c _cen_svc_usage
fi
[ "$CEN_USE_OWNSVC" = 2 ] &&
CEN_USE_ACTIONS+="$_sepa       "$"••• other actions •••"
CEN_USE_ACTIONS+="$_sepa"
[ -n "$_txt2" ]&&printf -v _txt1 '%-19s %s' "$_txt1" "$_txt2"
[ -n "$_txt1" ]&&CEN_USE_ACTIONS+="       $_txt1"
CEN_USE_OWNSVC=1
CEN_USE_OWNFLG=1;;
-e) if [ -z "$CEN_USE_EXAMPLE" ];then
_wide=50;CEN_USE_EXAMPLE=$"examples:"
fi
if [ "$_txt1" = '§' ];then
_wide="$_txt2";continue
fi
CEN_USE_EXAMPLE+="$_sepa"
[ "${_txt1::1}" = '.' ]&&_txt1="$CEN_NAME${_txt1:1}"
[ -n "$_txt2" ]&&printf -v _txt1 "%-${_wide}s %s" "$_txt1" "$_txt2"
[ -n "$_txt1" ]&&CEN_USE_EXAMPLE+="       $_txt1"
CEN_USE_OWNFLG=1;;
-h) CEN_USE_HEADER+="$_sepa       $_txt1$_txt2"
CEN_USE_OWNFLG=1;;
-l) [ -n "$CEN_USE_OWNLBL" ]&&CEN_USE_OTHER+="$_sepa"
if [ -z "$_txt1$_txt2" ];then
CEN_USE_OWNLBL=1
elif [ -z "$_txt1" ];then
[ "${CEN_USE_OWNLBL:-0}" -gt 1 ]&&CEN_USE_OTHER+="$_sepa"
CEN_USE_OTHER+='       '
CEN_USE_OWNLBL=3
elif [ "${#_txt1}" -ge 6 ];then
[ "${CEN_USE_OWNLBL:-0}" -gt 1 ]&&CEN_USE_OTHER+="$_sepa"
CEN_USE_OTHER+="$_txt1:"
CEN_USE_OWNLBL=2
else
[ "${CEN_USE_OWNLBL:-0}" -gt 1 ]&&CEN_USE_OTHER+="$_sepa"
_mesg="$_txt1:      "
CEN_USE_OTHER+="${_mesg::7}"
CEN_USE_OWNLBL=3
fi
CEN_USE_OWNFLG=1;;
-o) CEN_USE_OPTIONS+="$_sepa"
[ -n "$_txt2" ]&&printf -v _txt1 '%-19s %s' "$_txt1" "$_txt2"
[ -n "$_txt1" ]&&CEN_USE_OPTIONS+="       $_txt1"
CEN_USE_OWNFLG=1;;
-p) [ -z "$CEN_USE_PARAMS" ]&&CEN_USE_PARAMS=$"arguments:"
CEN_USE_PARAMS+="$_sepa"
[ -n "$_txt2" ]&&printf -v _txt1 '%-11s §%s' "$_txt1" "$_txt2"
[ -n "$_txt1" ]&&CEN_USE_PARAMS+="       $_txt1"
CEN_USE_OWNFLG=1;;
-s) [ -z "$CEN_USE_ACTIONS" ]&&CEN_USE_ACTIONS=$"actions:"
[ "$CEN_USE_OWNSVC" != 2 ] &&
CEN_USE_ACTIONS+="$_sepa       "$"••• service actions •••"
CEN_USE_ACTIONS+="$_sepa"
[ -n "$_txt2" ]&&printf -v _txt1 '%-19s %s' "$_txt1" "$_txt2"
[ -n "$_txt1" ]&&CEN_USE_ACTIONS+="       $_txt1"
CEN_USE_OWNSVC=2
CEN_USE_OWNFLG=1;;
-t) [ -n "$_txt2" ]&&printf -v _txt1 '%-11s §%s' "$_txt1" "$_txt2"
case "$CEN_USE_OWNLBL" in
'') CEN_USE_OWNLBL=1
CEN_USE_OTHER+="$_txt1";;
1) CEN_USE_OTHER+="$_sepa$_txt1";;
2)
CEN_USE_OTHER+="$_sepa       $_txt1";;
*) CEN_USE_OWNLBL=2
CEN_USE_OTHER+="$_txt1"
esac
CEN_USE_OWNFLG=1;;
-u) if [ -z "$_txt1$_txt2" ];then
CEN_USE_HEADER+="$_sepa"
elif [ -z "$CEN_USE_OWNHDR" ];then
CEN_USE_OWNHDR=1
CEN_USE_HEADER=$"usage:"
[ "${#CEN_USE_HEADER}" -gt 6 ]&&CEN_USE_HEADER+="$_sepa      "
CEN_USE_HEADER+=" $_txt1$_txt2"
else
CEN_USE_HEADER+="$_sepa       $_txt1$_txt2"
fi
CEN_USE_OWNFLG=1;;
-x) [ -n "$CEN_USE_OWNFLG" ]||return 0
[ -z "$CEN_USE_ACTIONS" ]&&isfunction -c _cen_svc_usage&&true
[ -n "$CEN_USE_OPTIONS" ]&&CEN_USE_OPTIONS="$_sepa$CEN_USE_OPTIONS$_sepa"
[ -n "$CEN_USE_ACTIONS" ]&&CEN_USE_ACTIONS="$_sepa$CEN_USE_ACTIONS$_sepa"
[ -n "$CEN_USE_PARAMS" ]&&CEN_USE_PARAMS="$_sepa$CEN_USE_PARAMS$_sepa"
[ -n "$CEN_USE_EXAMPLE" ]&&CEN_USE_EXAMPLE="$_sepa$CEN_USE_EXAMPLE$_sepa"
[ -n "$CEN_USE_OTHER" ]&&CEN_USE_OTHER="$_sepa$CEN_USE_OTHER$_sepa"
usagecat <<!EOF
$CEN_USE_HEADER
$CEN_USE_OPTIONS$CEN_USE_ACTIONS$CEN_USE_PARAMS$CEN_USE_EXAMPLE$CEN_USE_OTHER
!EOF
;;
*) _cen_abort - "$1"
esac
done
return 0
}
_cen_use_option() {
local _text _lopt="$2                " _indx=0
_text="${1:-  } ${_lopt::18}$3"
if [ $# -gt 3 ];then
_lopt="$4                "
_text+="\n   ${_lopt::18}$5"
fi
if [ "${1:--}" = - ];then
while [ -n "${CEN_USE_OMAP["Z$_indx"]}" ] ; do ((_indx++)) ; done
CEN_USE_OMAP["Z$_indx"]="$_text"
else
CEN_USE_OMAP["${1:1}"]="$_text"
fi
[ -n "$CEN_USE_ADDOPTS" ]&&CEN_USE_ADDOPTS+=' '
_lopt="${2%% *}"
[ "$2" = "$_lopt" ]||_lopt+='='
CEN_USE_ADDOPTS+="$_lopt"
return 0
}
usageopt() {
local _lopt _para
[ "$3" != - ]&&_para="$3"
printf -v _lopt '%-9s %-9s' "${2:+--}$2" "$_para"
if [ "${#2}" -le 7 ];then
_cen_use_option "-$1" "$_lopt" "$4"
else
_cen_use_option "-$1" "${2:+--}$2" "" "          $_para" "$4"
fi
return 0
}
case "${LANG,,}" in
*.utf8) CEN_USE_UTF8=1;;
*.utf-8) CEN_USE_UTF8=1;;
esac
[ "$1" = '-h' ]&&_cen_usage 0
[ "$1" = '-u' ]&&_cen_usage 1
:
}
# ===================== packed module: _centauri_bash_dyn ======================
_cen_bash_load_dyn(){
CEN_MODULES['_centauri_bash_dyn']='0.24:2'
[ "$1" = '-f' ] ||
fatal "Cannot load '_centauri_bash_dyn' via embed, use '_centauri_bash_lib -a'"
_cen_dyn_load() {
set +x
local _stat=0 _modu="$1" _func="${FUNCNAME[1]}" _snot="$CEN_NOTRACE";CEN_NOTRACE=:
[ "${#_modu}" = 3 ]&&_modu="_centauri_bash_$_modu"
unset -f "$_func"
embed -m "$_modu" -A
shift
if [ -z "$_snot" ];then
CEN_NOTRACE=;set -x
fi
$_func "$@"||_stat=$?
return $_stat
}
_cen_dyn_builtin() {
local _path _func="$1" _user="$CEN_PATHS/usr";shift
unset -f $_func
if ! enable -a "$_func" &>/dev/null;then
for _path in lib lib64 lib32 -;do
if [ "$_path" = - ];then
[ $# = 0 ]&&return 1
break
fi
_path="$_user/$_path/bash"
[ -r "$_path/$_func" ]||continue
[ -n "$CEN_DYN_NOLOADABLES" ]&&break
enable -f "$_path/$_func" "$_func" &>/dev/null&&break
done
fi
[ $# = 0 ]&&return 0
$_func "$@"
}
console() { _cen_dyn_load con "$@";}
decorate() { _cen_dyn_load con "$@";}
output() { _cen_dyn_load con "$@";}
tabulator() { _cen_dyn_load con "$@";}
copy() { _cen_dyn_load ext "$@";}
joinpath() { _cen_dyn_load ext "$@";}
matchpath() { _cen_dyn_load ext "$@";}
move() { _cen_dyn_load ext "$@";}
prettypath() { _cen_dyn_load ext "$@";}
readline() { _cen_dyn_load ext "$@";}
redirect() { _cen_dyn_load ext "$@";}
remove() { _cen_dyn_load ext "$@";}
rename() { _cen_dyn_load ext "$@";}
resolve() { _cen_dyn_load ext "$@";}
splitkeyval() { _cen_dyn_load ext "$@";}
splitpath() { _cen_dyn_load ext "$@";}
suffixpath() { _cen_dyn_load ext "$@";}
symlink() { _cen_dyn_load ext "$@";}
sysrun() { _cen_dyn_load ext "$@";}
tmpfile() { _cen_dyn_load ext "$@";}
walk() { _cen_dyn_load ext "$@";}
inpdata() { _cen_dyn_load iom "$@";}
inpfile() { _cen_dyn_load iom "$@";}
outdata() { _cen_dyn_load iom "$@";}
outfile() { _cen_dyn_load iom "$@";}
cachefile() { _cen_dyn_load iom "$@";}
configfile() { _cen_dyn_load iom "$@";}
serialize() { _cen_dyn_load iom "$@";}
spliteval() { _cen_dyn_load iom "$@";}
sysbind() { _cen_dyn_load pip "$@";}
syspager() { _cen_dyn_load pip "$@";}
syspipe() { _cen_dyn_load pip "$@";}
sysloop() { _cen_dyn_load pip "$@";}
progress() { _cen_dyn_load pro "$@";}
txtsort() { _cen_dyn_load txt "$@";}
extsort() { _cen_dyn_load txt "$@";}
txtgrep() { _cen_dyn_load txt "$@";}
extgrep() { _cen_dyn_load txt "$@";}
txtfold() { _cen_dyn_load txt "$@";}
usageparser() { _cen_dyn_load use "$@";}
usagecat() { _cen_dyn_load use "$@";}
usageset() { _cen_dyn_load use "$@";}
usageopt() { _cen_dyn_load use "$@";}
listsearch() { _cen_dyn_load utl "$@";}
number() { _cen_dyn_load utl "$@";}
optmake() { _cen_dyn_load utl "$@";}
pluralize() { _cen_dyn_load utl "$@";}
splitcall() { _cen_dyn_load utl "$@";}
timer() { _cen_dyn_load utl "$@";}
trimjoin() { _cen_dyn_load utl "$@";}
sleep() { _cen_dyn_builtin sleep "$@";}
mkdir() { _cen_dyn_builtin mkdir "$@";}
mkfifo() { _cen_dyn_builtin mkfifo "$@";}
rm() { _cen_dyn_builtin rm "$@";}
rmdir() { _cen_dyn_builtin rmdir "$@";}
unlink() { _cen_dyn_builtin unlink "$@";}
ln() { _cen_dyn_builtin ln "$@";}
realpath() { _cen_dyn_builtin realpath "$@";}
stat() { _cen_dyn_builtin stat "$@";}
}

# ===================== simplified '--info' implementation =====================
_cen_bash_info() {
    local _mesg _call ; system -q -s _call -- readlink -f "$0"
    _mesg=$"<unknown author/license>"
    _mesg="${CEN_LEGAL:-$_mesg}"
    echo "${_call:-$0}; $CEN_VERSION; $_mesg [packaged]" ; exit
}

# ========================= centauri-bash-package main =========================
export CEN_ROOT CEN_TOOLS="$CEN_ROOT" CEN_LIBRARY="$CEN_ROOT"
PATH+=":$CEN_ROOT"
[ -n "$TMP" ] || export TMP="${XDG_RUNTIME_DIR:-/tmp}" ;
[ -n "$TMPDIR" ] || export TMPDIR="$TMP"

CEN_PACKAGE=1

[ -z "$_CEN_BASH_ARGS" ] && _CEN_BASH_ARGS=("$0" "0.00")
_cen_bash_load_lib "${_CEN_BASH_ARGS[@]}" || exit 2
_cen_bash_init "$@"
embed -m _centauri_bash_con
embed -m _centauri_bash_iom
embed -m _centauri_bash_pro
embed -m _centauri_bash_txt
embed -m _centauri_bash_utl
_cen_bash_main "$@"

# ======================== end of centauri-bash-package ========================
