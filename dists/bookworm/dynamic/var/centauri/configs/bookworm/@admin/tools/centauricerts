#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. JÃ¼rgen Pfennig (c) 2023-2024; BSD License"
CEN_TITLE=$"Manage X509 certificates and centificate-authorities"

# Import the bash library, set name and version
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -y - '0.11:2' || exit 2

# Data
CEN_OPT_BASE=                   # see --base (set to pki base folder
CEN_OPT_HOSTS=                  # see --hosts
CEN_OPT_INSTALL=                # see --install
CEN_OPT_OVPN=                   # see --hosts

DAT_DOMAIN=                     # qualified domain name, see find_base()
DAT_DNAME=                      # domain, see find_base()

# ------------------------------------------------------------------------------
# helper functions
# ------------------------------------------------------------------------------

# print 1st pem section: <tag> <file>
cert_body() {
    local line body
   # echo "# body of: $2"
    echo "<$1>"
    while read line ; do
        [ -n "$body" ] && printf '%s\n' "$line"
        case "$line" in
        -----BEGIN*)   body=1 ; printf '%s\n' "$line" ;;
        -----END*)     break
        esac
    done <"$2"
    echo "</$1>"
}

# create a client.template or client.conf: <dest>
client_templ() {
    local serv
    netquery -f -s serv -- server
    nethost -- "$serv"
    create -c -- 'client.template' <<!EOF
# openvpn client config - generated by $CEN_NAME

cd          /etc/openvpn/client/$DAT_DNAME

# make this a client
client

# server things
dev         tun
proto       udp6
tun-mtu     1400
nobind
remote      INSERT-SERVER-DOMAIN-NAME-HERE 1194

# validate server cert
remote-cert-tls server
cipher      AES-256-GCM

# get certs and keys
ca          ca.crt
cert        client.crt
key         client.key
tls-auth    ta.key

# miscellaneous
comp-lzo
verb        1

# routing
route       $_nethost_ip subnet $CEN_NET_NETMASK

# end
!EOF
    [ -z "$1" ] && return
    dryrun -s "create $1" && return

    local lkey lval
    while read lkey lval ; do
        case "$lkey" in
        cd|\#*|'')  ;;
        ca)         cert_body "$lkey" "$1/$lval" ;;
        cert)       cert_body "$lkey" "$1/$lval" ;;
        key)        cert_body "$lkey" "$1/$lval" ;;
        tls-auth)   cert_body "$lkey" "$1/$lval" ;;
        \<*\>)      fatal "client.template must not contain XML elements" ;;
        *)          printf "%-19s %s\n" "$lkey" "$lval"
        esac
    done <'client.template' >"$1/app-client.conf"
}

# find/create base folder: [-c]
find_base() {
    local copt ; [ "$1" = '-c' ] && { copt='-c'; shift ; }
    [ -n "$DAT_DNAME" ] && return 0         # previous success

    [ "$CEN_OPT_OVPN$CEN_OPT_HOSTS" = '1' ] ||
        quit -e "Either '--ovpn' or '--hosts' must be specified"

    netquery -f -s DAT_DOMAIN domain
    DAT_DNAME="${DAT_DOMAIN%%.*}"

    if [ -n "$CEN_OPT_BASE" ] ; then
        base="$CEN_OPT_BASE"
    else
        local auth="CertificateAuthority-"
        [ -n "$CEN_OPT_HOSTS" ] && auth+="$DAT_DNAME" || auth+='ovpn'
        if ! matchpath -d -o -s base -- "$HOME/Private/$auth" "$HOME/$auth" "$auth" ; then
            [ -d "$HOME/Private" ] && base="$HOME/Private/$auth" || base="$HOME/$auth"
        fi
    fi

    if [ ! -d "$base" ] ; then
        [ -z "$copt" ] && fatal "Not a base folder:" "$base"
        confirm -n "Create folder '$base'" || quit -t
        folder -f -m -- "$base" 700
    elif [ -n "$copt" ] ; then
        if [ -d "$base/pki" ] ; then
            invoke -e "PKI already exists" ; return 1
        fi
    elif [ ! -d "$base/pki" ] ; then
        invoke -e "Have no PKI, invalid folder:" "$base" ; return 1
    fi
    folder -f -c -- "$base"
    CEN_OPT_BASE="$base" ; return 0
}

# run easyrsa in batch mode: [-p] args...
run_easyrsa() {
    local popt ; [ "$1" = '-p' ] && { popt='-p'; shift ; }
    system -t -e $popt -- "$PWD/easyrsa" --batch "$@"
}

# alternate names: <vnam> <vasn> (-|+|*|<name>)[(,|:|;)(-|+|*|<name>)]...
subj_parse() {
    local temp item subj=()
    splitjoin -s temp -d ' ' -- "${3//[,:;]/ }"
    for item in "${temp[@]}" ; do
        case "$item" in
        +)      netconfig -f
                subj+=("$CEN_NET_SERVER_GEN.$DAT_DOMAIN")
                subj+=("${CEN_NET_SERVERS[0]}.$DAT_DOMAIN")
                item="${CEN_NET_SERVERS[1]}" ; [ -z "$item" ] && continue ;;
        '*'|'*'.*)
                if [ -z "$subj" ] ; then
                    invoke -e "Host list cannot start with wildcard" ; return 1
                fi
                ;;
        [a-z]*) ;;
        *)      invoke -e "Invalid subject name:" "$item" ; return 1
        esac
        [ "${item/./}" = "$item" ] && item+=".$DAT_DOMAIN"
        subj+=("$item")
    done

    printf -v "$1" '%s' "${subj%%.*}"
    if [ "${#subj[@]}" -gt 1 ] ; then
        local anam #='--subject-alt-name="'
        for item in "${subj[@]}" ; do
            anam+="DNS:$item,"
        done
        printf -v "$2" '%s' "${anam%,}"
    fi
    return 0
}

# ------------------------------------------------------------------------------
# create a certificate: [<type>] <host> [<cnam>]
# ------------------------------------------------------------------------------
actionCreate() {
    find_base || return

    local kind revo fldr vnam vasn
    case "$1" in
    client)     kind='client' ; shift ; vnam="$1" ; shift ;;
    revoked)    kind='client' ; shift ; vnam="${1:-revoked}" revo=1 ; shift ;;
    server)     kind='server' ; shift ; vnam="${1:-+}" ; shift ;;
    *)          kind='client' ; vnam="$1" ; shift
    esac

    if [ "${vnam:--}" = '-' ] ; then
        invoke -e "Missing <host> argument" ; return
    elif [ $# -gt 1 ] ; then
        invoke -e "Too many arguments" ; return
    fi
    subj_parse vnam vasn "$vnam" || return

    if [ -e "certs/$vnam.crt" ] ; then
        message -a -c -p "Certificate exists" "%-12s" "$vnam"
    else
        message -a -c -p "Create certificate" "%-12s (%s)" "$vnam" "$kind"
        run_easyrsa -p --req-cn="$vnam.$DAT_DOMAIN" gen-req "$vnam" nopass
        if [ -n "$vasn" ] ; then
            run_easyrsa -p "--subject-alt-name=\"$vasn\"" sign-req "$kind" "$vnam"
        else
            run_easyrsa -p $anam sign-req "$kind" "$vnam"
        fi
        error -t || return
    fi

    if [ -n "$CEN_OPT_INSTALL" -a -z "$revo" ] ; then
        # install the server certificate as 'ssl-cert-snakeoil'
        if [ -n "$CEN_OPT_HOSTS" -a "$kind" = 'server' ] ; then
            local scrt="/etc/ssl/certs" skey="/etc/ssl/private"
            copy "pki/issued/$vnam.crt" "$scrt/ssl-cert-snakeoil.pem"
            symlink "$scrt/ssl-cert-snakeoil.pem" "$scrt/$vnam.pem"
            copy "pki/private/$vnam.key" "$skey/ssl-cert-snakeoil.key"
            symlink "$skey/ssl-cert-snakeoil.key" "$skey/$vnam.key"
        fi

        # install the server key in '/etc/openvpn'
        if [ -n "$CEN_OPT_OVPN" ] ; then
            if [ "$kind" = 'server' ] ; then
                if [ ! -e "pki/crl.pem" ] ; then
                    invoke -e "Cannot cannot install: revokation list" ; return
                fi
                folder -f -m -s fldr -- "/etc/openvpn/server/$DAT_DNAME"
                copy "pki/issued/$vnam.crt" "pki/private/$vnam.key" "pki/crl.pem" "$fldr"
                symlink -q -n "$vnam.crt" "$fldr/server.crt"
                symlink -q -n "$vnam.key" "$fldr/server.key"
            else
                folder -f -m -s fldr -- "/etc/openvpn/client/$DAT_DNAME"
                copy "pki/issued/$vnam.crt" "pki/private/$vnam.key" "$fldr"
                symlink -q -n "$vnam.crt" "$fldr/client.crt"
                symlink -q -n "$vnam.key" "$fldr/client.key"
            fi
            copy -q -u "keys/ta.key" "$fldr" || warning "No 'ta.ka' in CA?"
            copy -q -u "keys/dh.pem" "$fldr" || warning "No 'dh.pem' in CA?"
            copy -u "certs/OpenVPN_CA.crt" "$fldr"
            symlink -q -n "OpenVPN_CA.crt" "$fldr/ca.crt"
        fi
    fi

    # populate folder 'certs' and 'keys'
    copy -u "pki/issued"/* "certs"
    copy -u "pki/private"/* "keys"
    remove "keys/ca.key"
    #rename -q "keys/ca.key" "keys/${DAT_DNAME^}_CA.key"
    [ -n "$revo" ] && actionRevoke "$vnam"
}

# ------------------------------------------------------------------------------
# export centificate to tar: <name> [<file>]
# ------------------------------------------------------------------------------
actionExport() {
    find_base || return
    local name="$1"
    if ! [ -e "certs/$name.crt" -a -e "keys/$name.key" ] ; then
        invoke -e "No valid certificate found:" "$name" ; return
    fi

    outfile -t -l -c -x 'tgz' -- "${2:-$name}" || return
    local canm temp ; folder -f -m -t -r -s temp '_export'
    [ -n "$CEN_OPT_OVPN" ] && canm='OpenVPN_CA.crt' || canm="${DAT_DNAME^}_CA.crt"

    copy -a -- "certs/$canm" "certs/$name.crt" "keys/$name.key" "$temp"
    [ -e "keys/ta.key" ] && copy -a -- "keys/ta.key" "$temp"
    symlink -q -n "$name.crt" "$temp/client.crt"
    symlink -q -n "$name.key" "$temp/client.key"
    symlink -q -n "$canm" "$temp/ca.crt"

    if [ -n "$CEN_OPT_OVPN" ] ; then
        client_templ "$temp"
    else
        system -e -p -t openssl x509 -inform PEM -outform DER \
                        -in "$temp/ca.crt" -out "$temp/ca-der-format.crt"
    fi
    system -e -p -t -- tar -caf "$CEN_OUTFILE" --directory "$temp" .
    remove -d -- "$temp"
    message -a -c "Created export" -- "$CEN_OUTFILE"
}

# ------------------------------------------------------------------------------
# show cert info: <file>|<name>
# ------------------------------------------------------------------------------
actionInfo() {
    case "$1" in
    */*|*.*|+|-)    inpfile -- "$1" || return ;;
    *)              find_base || return
                    inpfile -- "$CEN_OPT_BASE/certs/$1.crt" || return
    esac
    syspager system -e openssl x509 --in="$CEN_INPFILE" --text --nooutput
}

# ------------------------------------------------------------------------------
# list cert status: [<name>]
# ------------------------------------------------------------------------------
actionList() {
    find_base || return
    local cert item file
    matchpath -e -a cert -- "$CEN_OPT_BASE/certs"/${1:-*}.crt
    for file in "${cert[@]}" ; do
        item="${file##*/}" ; item="${item%.*}"
        if [ -e "$CEN_OPT_BASE/keys/$item.key" ] ; then
            message -a -p -- "%-21s [OK]" "$item"
        elif system -q -- cmp -s -- "$file" "$CEN_OPT_BASE/pki/ca.crt" ; then
            message -a -p -- "%-21s [certificate authority]" "$item"
        else
            message -a -p -- "%-21s [missing key]" "$item"
        fi
    done
}

# ------------------------------------------------------------------------------
# revoke a centificate: [<file>|<name>]
# ------------------------------------------------------------------------------
actionRevoke() {
    find_base || return
    if [ $# != 0 ] ; then
        local file name
        if [ "${1/\//}" = "$1" ] ; then
            file="pki/issued/$1.crt"
        else
            inpfile -s "$file" -- "$1" || return
        fi
        name="${file##*/}" ; name="${name%%.*}"

        if [ ! -e "pki/issued/$name.crt" ] ; then
            invoke -e "Certificate unknown by this CA:" "$name" ; return
        fi

        message -a -c "Revoke certificate" "$name"
        [ "$CEN_ACTION" = 'create' ] || remove -q -- "certs/$name.crt"
        remove -q -- "keys/$name.key"
        run_easyrsa -p revoke "$name"
    else
        message -a -c "Revokation list" "Create 'crl.pem'"
    fi
    run_easyrsa -p gen-crl
    symlink -q 'pki/crl.pem' 'crl.pem'
}

# ------------------------------------------------------------------------------
# setup a CA: -no args-
# ------------------------------------------------------------------------------
actionSetup() {
    find_base -c || return
    symlink -q '/usr/share/easy-rsa'/* .
    run_easyrsa init-pki || return

    local ounm='soho'
    [ -n "$CEN_OPT_OVPN" ] && ounm='openvpn'

    create -f -c -t -- 'pki/vars' <<!EOF
set_var EASYRSA_REQ_COUNTRY    "DE"
set_var EASYRSA_REQ_PROVINCE   "Hessen"
set_var EASYRSA_REQ_CITY       "Frankfurt am Main"
set_var EASYRSA_REQ_ORG        "Centauri"
set_var EASYRSA_REQ_EMAIL      "centauri@$DAT_DOMAIN"
set_var EASYRSA_REQ_OU         "centauri-$ounm"
set_var EASYRSA_ALGO           "ec"
set_var EASYRSA_DIGEST         "sha512"
set_var EASYRSA_CA_EXPIRE      "7304"
set_var EASYRSA_CERT_EXPIRE    "7304"
!EOF
    confirm -n "Edit certificate variables" && system -e -- editor 'pki/vars'

    run_easyrsa -p --req-cn="$DAT_DNAME-ca-$ounm ($DAT_DOMAIN)" build-ca nopass
    if [ -e "pki/ca.crt" ] ; then
        if [ -z "$CEN_OPT_OVPN" ] && confirm -y \
            "Add new CA to trusted CAs (${DAT_DNAME^}_CA)" ; then
            copy "pki/ca.crt" "/usr/local/share/ca-certificates/${DAT_DNAME^}_CA.crt"
            system -e -p -t -- update-ca-certificates
        fi
    else
        error "Failed to create CA Certificate" ; return
    fi

    folder -f -m 'certs' ; folder -f -m 'keys'
    if [ -z "$CEN_OPT_OVPN" ] ; then
        ounm="${DAT_DNAME^}"
    else
        ounm='OpenVPN'
        copy "pki/private/ca.key" "keys/${ounm}_CA.key"
        system -e -p -t -- openvpn --genkey --secret "keys/ta.key"
        if confirm -n "Create a 2048 bit 'dh.pem' now" ; then
            system -e -t -- openssl dhparam -out "keys/dh.pem" 2048
        else
            message "Please copy some other 'dh.pem' to '$PWD/keys/dh.pem'"
        fi
    fi
    copy "pki/ca.crt" "certs/${ounm}_CA.crt"

    [ -n "$CEN_OPT_OVPN" ] && client_templ
}

# ------------------------------------------------------------------------------
# Option parsing: <option> [<argument>]
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    -B|--bas*)
        optarg 'base'    -          -d  ;;          # folder
    -H|--hos*)
        optarg 'hosts'   -          -f  ;;
    -I|--ins*)
        optarg 'install' -          -f  ;;
    -O|--ovp*)
        optarg 'ovpn'    -          -f  ;;

    esac
}

# ------------------------------------------------------------------------------
# Action parsing: <verb> <argument>...
# ------------------------------------------------------------------------------
actions() {
    case "$1" in

    cre*)
        invoke -r 'create'  -       1 3 ;;                  # 1..3 args
    exp*)
        invoke    'export'  -       1 2 ;;                  # 1..2 args
    inf|info)
        invoke    'info'    -       1   ;;                  # 1 arg
    lis|list)
        invoke -r 'list'    -       0 1 ;;                  # 1 optional arg
    rev*)
        invoke    'revoke'  -       0 1 ;;                  # 1 optional arg
    set*)
        invoke -r 'setup'   -       0   ;;                  # no args

    esac
}

# ------------------------------------------------------------------------------
# Usage info
# ------------------------------------------------------------------------------
usage() {
    usageset \
        -h - \
        -h "This tool should be run on a server only. It uses **easyrsa** and" \
        -h "**openssl** which must both be installed."

    usageset \
        -o - \
        -o "-B --base   <path>   "$"path of CA base folder" \
        -o "-H --hosts           [*]"$"use CA for host certificates" \
        -o "-I --install         "$"install certificates at local host" \
        -o "-O --ovpn            [*]"$"use CA for openvpn certificate" \
        -o - \
        -o "[*] mandatory, either --host or --ovpn must be specified"

   usageset \
        -a 'setup'                $"setup a new CA instance" \
        -a 'create [<type>] <host> [<cnam>]' - \
        -a -                      $"create a certificate" \
        -a 'create revoked'       $"create revoked test certificate" \
        -a 'create server'        $"create certificate for generic server" \
        -a 'export <host> [<file>]' - \
        -a -                      $"export certificate as tar file" \
        -a 'info   <cert>'        $"show certificate information" \
        -a 'list   [<glob>]'      $"list certificate status" \
        -a 'revoke [<cert>]'      $"revoke certificate, generate crl.pem" \

   usageset \
        -p '<cert>'               $"name or path of a certificate or certificate" \
        -p '<cnam>'               $"overrides auto generated CN" \
        -p '<file>'               $"a file path      (examples: x.tar x.tgz)" \
        -p '<glob>'               $"glob expresssion (examples: [a-d]* user*)" \
        -p '<host>'               $"a host name list, comma separated (see below)" \
        -p '<path>'               $"a folder path" \
        -p '<type>'               $"certificate type: host|client (default: client)" \
        -p - \
        -p "When creating a certificate <host> can be a list to specify alternate subject" \
        -p "names for DNS. For names without domain the default domain is appended. Use" \
        -p "'*' for wildcard and '+' for generic/primary/secondary server."

   usageset \
        -e "# Create a Host CA instance and populate it" \
        -e ". --host --install setup" \
        -e ". --host --install create revoked -- create server" \
        -e ". --host create host2 -- create host2    # and so on" \
        -e - \
        -e "# Create a OpenVPN CA instance and populate it" \
        -e ". --ovpn --install setup" \
        -e ". --ovpn --install create revoked -- create server" \
        -e ". --ovpn create host2 -- create host2    # and so on" \
        -e - \
        -e "# list certificates, export OpenVPN config" \
        -e ". --ovpn list user*" \
        -e ". --ovpn export user1 user1-phone.tgz" \

}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
