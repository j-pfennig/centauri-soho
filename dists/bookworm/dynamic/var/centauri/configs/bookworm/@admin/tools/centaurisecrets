#!/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2007-2024; BSD License"
CEN_TITLE="Service to find a Domain Server and download Secrets"
CEN_SVC_SHORT="Get Domain Server and secrets"

### BEGIN INIT INFO
# Provides:          centaurisecrets
# Required-Start:    $remote_fs networking centaurifilter
# Required-Stop:
# X-Start-Before
# Default-Start:     3 4 5
# Default-Stop:
# Short-Description: Secrets download
# Description:       Manage the download of secrets from server to client
### END INIT INFO

# Import the bash library, set name and version (--dryrun NOT FULLY IMPLEMENTED)
PATH+=":/usr/local/bin"
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -v - '0.56:2' || exit 2

# Extra option data
CEN_OPT_NOHOOK=                         # see --nohook
CEN_OPT_IFACE=                          # see --interface
CEN_OPT_POLL='all'                      # see --poll

# Data in status file
CEN_SECRETS_HOST=                       # server name
CEN_SECRETS_WHAT=                       # CLIENT | GUEST
CEN_SECRETS_MODE=                       # static|download

# Data
DAT_COOKIE='mampf'
DAT_ACTIVE=                             # active server, see do_names
DAT_CENTAURINAME=()                     # server info, see do_names
DAT_SERVER=()                           # servers to check, see do_names
DAT_HOST=                               # homedns host, see do_names
DAT_CLI_ARG=                            # argument to "client" action
DAT_PORT_POLL=                          # port to used poll for master

DAT_DEFAULT="$CEN_ROOT/default/$CEN_NAME"       # see do_default

DAT_DIR_TEMP="$CEN_ROOT/transient"              # folder for status file
DAT_DIR_SECRETS="$CEN_ROOT/secrets"             # main secrets folder

DAT_DIR_DOWNLOAD="$DAT_DIR_TEMP/secrets-load"   # temporary download folder
DAT_DIR_FAKE="$DAT_DIR_TEMP/secrets-fake"       # server fake data folder
DAT_DIR_LOCAL="$DAT_DIR_SECRETS/local"          # server static data folder
DAT_DIR_STATIC="$DAT_DIR_SECRETS/data"          # ... (sent to clients)

DAT_MACHINE_DIR="$CEN_ROOT/machines"    # per-machine secrets folder
DAT_MACHINE_ID=                         # machine-id

DAT_BLOCKED1=                           # server that failed polling
DAT_BLOCKED2=

declare -A DAT_PASSWORDS                # dictionary see do_passwords
                                        # override file
DAT_OVERRIDE="$CEN_ROOT/persistent/centauriswitch-override"

# don't run as a service if centauriswitch is active
inhibit "Inhibited by centauriswitch"

# set umask to give all created files 0644 protection
umask 022
#context -v 2      ##### DEBUG

# -----------------------------------------------------------------------------
# Check if secrets are static/download, create folder/links: [-r]
#
# On a server this should return 0 (static).
#
# Create download folder and links if no -r option is given.
# -----------------------------------------------------------------------------
is_static() {
    # status is known already?
    [ "$CEN_SECRETS_MODE" = "static" ] && return 0
    [ "${CEN_SECRETS_MODE:-unknown}" != "unknown" ] && return 1
    [ "$1" = "-r" ] && return 1

    # the secrets folder must exist ...
    folder -m -f "$DAT_DIR_SECRETS" 755 root:root

    # the data folder makes secrets 'static', e.g. not downloaded
    if [ -d "$DAT_DIR_STATIC" ] ; then
        CEN_SECRETS_MODE="static"
        remove -d "$DAT_DIR_SECRETS/import"

        if [ ! -d "$DAT_MACHINE_DIR" ] ; then
            netquery MASTER && folder -m -f "$DAT_MACHINE_DIR" 770 root:wheel
        fi
    else
        CEN_SECRETS_MODE="download"
        folder -m -f "$DAT_DIR_DOWNLOAD" 711 root:root
        symlink -m -n -r "$DAT_DIR_DOWNLOAD" "$DAT_DIR_SECRETS/import"
    fi

    [ "$CEN_SECRETS_MODE" = "static" ]      # return status
}

# -----------------------------------------------------------------------------
# Find an active server: -no args-
# ------------------------------------------------------------------------------
do_active() {
    # no server known to be unreachable
    DAT_BLOCKED1= ; DAT_BLOCKED2=
    [ -z "$DAT_HOST" ] && return 1              # do_server failed

    # get qualified server names
    local svr1="${DAT_SERVER[0]}" svr2="${DAT_SERVER[1]}"
    if [ -z "$svr1" ] ; then                    # always want 1st server
        svr1="$svr2" ; svr2=
    fi

    # special case: am I a server?
    local inam="$HOSTNAME.$CEN_NET_DOMAIN"
    if [ "$inam" = "$svr1" ] ; then             # I am primary, check secondary
        svr1="$svr2" ; svr2="--"
    elif [ "$inam" = "$svr2" ] ; then           # I am secondary, check primary
        svr2="--"
    fi

    # yes, I am a server
    if [ "$svr2" = "--" ] ; then
        [ "$DAT_HOST" != "${DAT_SERVER[0]}" -a "$DAT_HOST" != "${DAT_SERVER[1]}" ] &&
            error "I am a server - ignoring server argument: $DAT_HOST"
        if [ "${svr1:--}" = '-' ] ; then
            trace "I am the one and only server - skip check"
            DAT_HOST="$inam" ; DAT_ACTIVE="$inam" ; return 0
        fi
        trace "I am a server - checking '$svr1'"

    # I am not server. Do we need to check?
    elif [ "$DAT_HOST" = "$DAT_ACTIVE" ] ; then
        message "Have active server: '$DAT_ACTIVE' - skip check"
        return 0
    else
        trace -i "Configured servers  [${svr1:--none-}${svr2:+ }$svr2]"
    fi
    DAT_ACTIVE=                                 # ignore current svr

    # is any interface up?
    ___ifwait() {
        local ista
        while [ -n "$1" ] ; do
            read ista <"$1" ; [ "$ista" = 'up' ] && return 0
            shift
        done ; return 1
    }

    local ilst
    matchpath -a ilst -r -- /sys/class/net/e[nt]*/operstate /sys/class/net/wl*/operstate
    if [ -z "$ilst" ] ; then
        warning "No configured interface"
        DAT_BLOCKED1="$svr1" ; DAT_BLOCKED2="$svr2" ; DAT_ACTIVE=
        return 1
    fi
    while ! ___ifwait "${ilst[@]}" ; do
        # do not wait in smart or router mode (these use networkmanage orr dhcp hooks)
        nettemp "centauriswitch" && . "$_nettemp"
        if ! [ "$DAT_SWITCH_MODE" = 'smart' -o  "$DAT_SWITCH_MODE" = 'router' ] ; then
            message "No interface is up - waiting..."
            timer -w 3 ; ___ifwait "${ilst[@]}" && break
            timer -w 3 ; ___ifwait "${ilst[@]}" && break
            timer -w 4 ; ___ifwait "${ilst[@]}" && break
        fi
        message "No interface is up"
        DAT_BLOCKED1="$svr1" ; DAT_BLOCKED2="$svr2" ; DAT_ACTIVE=
        return 1
    done

    # get primary/secondary check commands
    local pri1 pri2="false"                     # for server 1/2
    local sec1 sec2="false"                     # alternate check
    if [ -n "$DAT_PORT_POLL" -a "$CEN_OPT_POLL" != "ping" ] ; then

        # i am server - check 2nd server only for running ldap
        if [ "$svr2" = "--" ] ; then
            type -t -f netcat >/dev/null 2>&1 ||
                fatal "Required 'netcat' is no installed"
            pri1="netcat -z -w3 $svr1 $DAT_PORT_POLL"

        # check both servers, prefer netcat
        elif type -t -f netcat >/dev/null 2>&1 ; then
                              pri1="netcat -z -w3 $svr1 $DAT_PORT_POLL"
            [ -n "$svr2" ] && pri2="netcat -z -w3 $svr2 $DAT_PORT_POLL"
            if [  "$CEN_OPT_POLL" != "ldap" ] ; then
                                  sec1="ping -q -c1 -W1 $svr1"
                [ -n "$svr2" ] && sec2="ping -q -c1 -W1 $svr2"
            fi

        # must have netcat
        elif [  "$CEN_OPT_POLL" = "ldap" ] ; then
            fatal "Required 'netcat' is not installed"

        # check both servers, use ping
        else
            warning "'netcat' not found, falling back to 'ping'"
                              pri1="ping -q -c1 -W1 $svr1"
            [ -n "$svr2" ] && pri2="ping -q -c1 -W1 $svr2"
        fi

    # configured not to use ldap checks
    else
        [ "$svr2" = '-' ] || fatal "Multiple servers - cannot use ping"
                          pri1="ping -q -c1 -W1 $svr1"
        [ -n "$svr2" ] && pri2="ping -q -c1 -W1 $svr2"
    fi

    # poll helper: <phase>
    local wait=2
    __active() {
        # progress repeort  (phase 0 := initial call)
        if [ "$1" -gt 0 ] ; then
            local mesg="$svr1"
            [ "$1" -gt 1 -a "$svr2" != "--" ] && mesg+=" $svr2"
            message -i "Retry server check: $mesg"
            progress "." ; [ -n "$wait" ] && sleep "$wait"
        fi

        # primary command   (phase 1 := primary server. 1st cmd only)
        if [ "$1" -le 1 ] ; then
            $pri1 >/dev/null 2>&1 && hnam="$svr1" && return 0
            return 1
        fi

        # primary command   (phase 2 := both servers, 1st cmd only)
        if [ "$1" = 2 ] ; then
            $pri1 >/dev/null 2>&1 && hnam="$svr1" && return 0
            $pri2 >/dev/null 2>&1 && hnam="$svr2" && return 0
            return 1
        fi

        # both commands     (phase 3:= try all)
        wait=1
        $pri1 >/dev/null 2>&1 && hnam="$svr1" && return 0
        $pri2 >/dev/null 2>&1 && hnam="$svr2" && return 0
        [ -z "$sec1" ] && return 1
        $sec1 >/dev/null 2>&1 && hnam="$svr1" && return 0
        $sec2 >/dev/null 2>&1 && hnam="$svr2" && return 0
        return 1
    }

    # polling
    local hnam                                # set by __active
    if [ -n "$svr1" ] ; then
        trace "Checking for server [$svr1${svr2:+ }$svr2]"
        __active 0  || __active 1 || __active 2 || __active 2 || __active 3 || hnam=
    fi
    if [ -n "$hnam" ] ; then
        message "Server is active: $hnam"
        DAT_ACTIVE="$hnam" ; DAT_HOST="$hnam" ; return 0
    fi
    if [ "$svr2" = "--" ] ; then
        message "Server '$svr1' not active, I am MASTER"
        DAT_BLOCKED1="$svr1"
        DAT_ACTIVE="$inam" ; DAT_HOST="$inam" ; return 0
    fi
    trace -i "No active server"
    DAT_BLOCKED1="$svr1" ; DAT_BLOCKED2="$svr2" ; DAT_ACTIVE=

    hnam="${DAT_CENTAURINAME[1]:--}"
    if [ "$hnam" != '-' -a "$hnam" != 'local' ] ; then
        DAT_HOST="$hnam"
        message "Using homedns server: $DAT_HOST"
    fi
    return 1
}

# -----------------------------------------------------------------------------
# Run client side: [<host>|-]
# ------------------------------------------------------------------------------
do_client() {
    system -c -e netcat tar || return

    # centaurisoho enforces 'simple' network mode at installation time ...
    if [ -s "$DAT_OVERRIDE" ] ; then
        invoke -w "Have override file, using 'local' mode"
        set -- '-'
    fi

    # check server, load secrets
    if ! do_server -r "$1" ; then               # get home server
        if [ "${CEN_OPT_IFACE:--}" != '-' ] ; then
            do_status
            if [ "$CEN_SECRETS_IFACE" != "$CEN_OPT_IFACE" ] ; then
                trace "Interface mismatch, ignore 'local': $CEN_OPT_IFACE"
                error -s 2 ; return
            fi
            message "Execute 'local': $CEN_OPT_IFACE"
        fi
        do_dirinit                              # clear secrets folder
    elif do_active  ; then                      # check active server
        do_secrets                              # try to load
        do_status -w "$DAT_HOST" 'CLIENT'
    elif do_secrets ; then                      # get secrets
        do_status -w "$DAT_HOST" 'GUEST'
    else
        do_dirinit
    fi
    do_default                                  # fill from config file

    # run centauriswitch
    if [ -z "$CEN_OPT_NOHOOK" ] ; then
        case "$CEN_SECRETS_WHAT" in
        GUEST)  embed -v centauriswitch --nohook 'guest' "$CEN_SECRETS_HOST"
                ;;
        CLIENT) embed -v centauriswitch --nohook 'client' "$CEN_SECRETS_HOST"
                ;;
        esac
    fi
}

# -----------------------------------------------------------------------------
# create dummy secrets from configuration: [-f|-s]
#
#   -f (fake data)      templates without local/data only
#   -s (seed data)      also local/data, forced update
# ------------------------------------------------------------------------------
do_default() {
    local fake over base="$DAT_DIR_DOWNLOAD"
    if [ "$1" = '-f' ] ; then
        base="$DAT_DIR_FAKE" ; fake=1
    elif [ "$1" = '-s' ] ; then
        over=1
    elif is_static ; then
        trace -a "Secrets folder is local, do not apply defaults"
        return 1
    fi
    trace "Setting defaults:" "$base"

    # handle the "link" instruction: <user> <pasw>
    local fcre fdir ftxt fovr fusr frig llis=()
    __default_pasw() {
        if [ -n "${DAT_PASSWORDS["$1"]}" ] ; then
            $CEN_TRACE2 -a -c "passwd keep" -- "$1"
        else
            $CEN_TRACE2 -a -c "passwd load" -- "$1" "$2"
            DAT_PASSWORDS["$1"]="$2"
        fi
        return 0
    }

    # handle the "link" instruction
    __default_link() {
        fovr="$over"
        if [ "$1" = "override" ] ; then
            shift ; fovr=1
        fi
        [ -e "$1" ] || return
        ftxt="$2" ; [ -n "$ftxt" ] || ftxt="${1##*/}"
        if [ -n "$fovr" ] || [ ! -e "$fcre" ] ; then
            trace -a -c "link" "$DAT_DIR_DOWNLOAD/$ftxt"
            symlink -f -x "$1" "$DAT_DIR_DOWNLOAD/$ftxt"
        else
            trace -a -c "link skip" "$DAT_DIR_DOWNLOAD/$ftxt"
        fi
        llis+=("$ftxt") ; return 1
    }

    # handle the "create" instruction: [override] <path> [<user> [<prot>]]
    __default_crea() {
        ftxt= ; fovr="$over" ; fcre='-'
        if [ "$1" = "override" ] ; then
            shift ; fovr=1
        fi
        case "$1" in
        data/*|local/*)
                    if [ -n "$fake" ] ; then
                        fcre='-' ; return 0
                    fi
                    fdir="$DAT_DIR_SECRETS/${1%%/*}"
                    fcre="$DAT_DIR_SECRETS/$1" ;;
        */*)        return 1 ;;
        [a-z]*)     fdir="$base"
                    fcre="$base/$1" ;;
        *)          return 1
        esac
        if [ ! -d "$fdir" ] ; then
            trace -a -c "create ignore" -- "$fcre"
            fcre='-' ; return 0
        fi
        fusr="$2" ; frig="${3:-660}"
        llis+=("$1") ; return 0
    }

    # substitute password variable: <vnam> <text>
    __default_vars() {
        local _txt="$2" _lef _rig _pas
        _rig="${_txt#*\%}"
        if [ "$_rig" != "$_txt" ] ; then        # contains '%' ...
            _lef="${_txt%%\%*}" ; _pas="${_rig%%\%*}" ; _rig="${_rig#*\%}"
            if [ "$_pas" != "$_rig" ] ; then    # closing '%' ok ...
                _txt="$_lef${DAT_PASSWORDS["$_pas"]:-$RANDOM-$EPOCHSECONDS}$_rig"
            fi
        fi
        printf -v "$1" "%s" "$_txt"
    }

    # parser main routine
    local nlin=0 keyw line list=()
    if [ -r "$DAT_DEFAULT" ] ; then
        set -f                          # no glob
        while read keyw line ; do
            ((nlin++))

            # flush create file
            if [ -n "$fcre" ] ; then
                if [ "$keyw" = '+' ] ; then             # new syntax
                    __default_vars line "$line"
                    list+=("$line") ; continue
                elif [ "${keyw::1}" = '+' ] ; then      # backward compatibility
                    keyw="${keyw:1}" ; [ -n "$line" ] && keyw+=" $line"
                    __default_vars line "$keyw"
                    list+=("$line") ; continue
                fi
                if [ "$fcre" = '-' ] ; then
                    :
                elif [ -n "$fovr" ] || [ ! -e "$fcre" ] ; then
                    create -t -v list -- "$fcre" "$frig" "$fusr"
                else
                    trace -a -c "create skip" "$fcre"
                fi
                fcre= ; list=()
            fi

            # find commands
            case "$keyw${line:+-}" in
                ""|\#*)     continue ;;
                password-)  __default_pasw "${line%% *}" "${line##* }" && continue ;;
                link-)      __default_link $line && continue ;;
                create-)    __default_crea $line && continue ;;
            esac
            error "Invalid $DAT_DEFAULT line [$nlin]: $keyw $line"
        done <"$DAT_DEFAULT"
        trace -i "Parsed: $DAT_DEFAULT [$nlin lines]"
        set +f
    fi
    for line in "${llis[@]}" ; do
        [ -e "$DAT_DIR_SECRETS/$line" ] && continue
        [ -h "$DAT_DIR_SECRETS/$line" ] && continue
        symlink -i -n -- "import/$line" "$DAT_DIR_SECRETS/$line"
    done
    return 0
}

# -----------------------------------------------------------------------------
# initilize the secrets folder and status: [-u]
# -----------------------------------------------------------------------------
do_dirinit() {
    # remove download files
    if [ "$1" != '-u' ] && ! is_static ; then
        trace -a "Remove downloaded secrets"
        remove "$DAT_DIR_DOWNLOAD"/* "$DAT_DIR_DOWNLOAD/.status"
    fi

    local curr="$PWD" item list=()
    folder -c -f "$DAT_DIR_SECRETS"

    # remove stale symlinks
    for item in * ; do
        [ -e "$item" ] && continue
        [ -h "$item" ] || continue
        [ "$item" = 'local' ] && continue
        [ "$item" = 'import' ] && continue
        list+=("$item")
    done
    if [ -n "$list" ] ; then
        trace -a "Remove stale symlinks to secrets"
        remove -- "${list[@]}"
    fi

    # update links after download
    if [ "$1" = '-u' ] ; then
        trace -a "Update symlinks to secrets"
        list=()
        for item in data/* import/* local/* ; do
            [ -e "${item##*/}" ] && continue
            [ -e "$item" ] || continue
            list+=("$item")
        done
        [ -n "$list" ] && sysrun -e -d -- ln -s -- "${list[@]}" .

        # update /etc/krb5.keytab from secrets
        local ktab="/etc/krb5.keytab" ksec="$DAT_DIR_DOWNLOAD/krb5.keytab"
        [ -h "$ktab" ] && remove "$ktab"
        [ "$ksec" -nt "$ktab" ] && copy -a -- "$ksec" "$ktab"
    fi
    folder -c -f "$curr"
    do_status -w
}

# -----------------------------------------------------------------------------
# Get server name: [-r] [-p|-s] <host>
# ------------------------------------------------------------------------------
# options:      -r      force refresh (implied by <host>)
#               -p      check for primary server to poll
#               -s      check for secondary server to poll
#               <none>  homedns or nick name
# Saves data in: DAT_ACTIVE         active server
#                DAT_CENTAURINAME   array nick/homedns/active/server...
# ------------------------------------------------------------------------------
_do_names=
do_names() {
    local oref otyp qval nick
    _do_names=

    while [ "${1::1}" = '-' ] ; do
        case "$1" in
        --)     shift ; break ;;
        -r)     oref=1 ;;
        -p)     otyp="p" ;;
        -s)     otyp="s" ;;
        *)      fatal "do_names bad arg: $1"
        esac ; shift
    done

    # initial load or refresh data
    if [ -n "$oref" -o -z "${DAT_CENTAURINAME[0]}" ] ; then
        embed -a DAT_CENTAURINAME -r centauriname --qual --nick --homedns --active --server
        DAT_ACTIVE="${DAT_CENTAURINAME[2]}"
    fi

    # explicit name given - override homedns
    if [ -n "$1" ] ; then
        qval="$1"                               # add default domain...
        [ "${qval%%.*}" = "$qval" ] && qval+=".$CEN_NET_DOMAIN"
        if [ "$qval" = "${DAT_CENTAURINAME[0]}" ] ; then
            DAT_CENTAURINAME[1]='local'
        else
            DAT_CENTAURINAME[1]="$qval"
            DAT_CENTAURINAME[3]= ; DAT_CENTAURINAME[4]=
        fi

    # homedns is server nickname (am I a server?)
    elif [ "${DAT_CENTAURINAME[1]}" = "${DAT_CENTAURINAME[0]}" ] ; then
        DAT_CENTAURINAME[1]='local'
    fi

    # use only servers if homedns matches any (generic) server name or is 'local'
    local item fsrv hdns="${DAT_CENTAURINAME[1]}"
    [ "$hdns" = '-' -a -z "$1" ] && return 1    # need hdns or override
    for item in 'local' "${DAT_CENTAURINAME[3]}" "${DAT_CENTAURINAME[4]}" ; do
        [ "$item" = "$hdns" ] || continue
        fsrv=1 ; break
    done

    # what to return
    if [ "$otyp" = "p" ] ; then
        [ -z "$fsrv" ] && return 1
        qval="${DAT_CENTAURINAME[3]:--}"        # primary
    elif [ "$otyp" = "s" ] ; then
        [ -z "$fsrv" ] && return 1
        qval="${DAT_CENTAURINAME[4]:--}"        # secondary
    else
        qval="$hdns"                            # homedns
        [ "$hdns" = 'local' ] && qval="${DAT_CENTAURINAME[0]:--}"
    fi

    [ "$qval" = '-' ] && return 1               # nothing found
    _do_names="$qval" ; return 0
}

# -----------------------------------------------------------------------------
# Load passwords from seed file: (1) <seed>             # load file
#                                (2) <vnam> <user>      # return passwd
# ------------------------------------------------------------------------------
do_passwords() {
    local list item
    if [ $# = 1 ] ; then
        inpfile -c -- "$1" || return 1
        configfile -v -r list -n "$CEN_INPFILE" || return 1
        for item in "${list[@]}" ; do
            [[ "$item" = *=* ]] || continue
            DAT_PASSWORDS["${item%%=*}"]="${item##*=}"
        done
    elif [ $# = 2 ] ; then
        printf -v "$1" ${DAT_PASSWORDS["$2"]:-$RANDOM-$EPOCHSECONDS}
    else
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Download secrets: -no args-       # wants a qualified host name in DAT_HOST
# ------------------------------------------------------------------------------
do_secrets() {

    # helper to load data and to sleep
    __secrets() {
        if [ "$1" != '-' ] ; then
            message -i "Retry secrets load from: $DAT_HOST"
            progress "." ; sleep 2
        fi

        dryrun "echo $HOSTNAME $DAT_COOKIE $DAT_MACHINE_ID |"\
               "netcat -q6 -w5 -v $DAT_HOST $CEN_NET_PORT_SECR" && return
        echo -e "$HOSTNAME $DAT_COOKIE $DAT_MACHINE_ID" |
            netcat -q6 -w5 -v $DAT_HOST $CEN_NET_PORT_SECR 2>/dev/null |
            tar --directory "$DAT_DIR_DOWNLOAD" -xz --numeric-owner . 2>/dev/null
    }

    # check call
    if is_static ; then
        trace "Secrets folder is static, do not download"
        [ -n "$DAT_ACTIVE" ] ; return           # return status
    fi
    [ -z "$DAT_HOST" ] && fatal "No host name"
    if [ "$DAT_HOST" = "$DAT_BLOCKED1" -o "$DAT_HOST" = "$DAT_BLOCKED2" ] ; then
        warning "No secrets for '$DAT_HOST', failed server check"
        return 1
    elif [ "$DAT_HOST" = "$HOSTNAME" -o "$DAT_HOST" = "$HOSTNAME.$CEN_NET_DOMAIN" ] ;then
        trace "Secrets from 'localhost', reinit to defaults"
        do_dirinit ; do_default ; return 0
    fi

# TODO: use status file instead of .status
# TODO: do_dirinit should remove status file
    # try to load
    local isok=1 stat="$DAT_DIR_DOWNLOAD/.status"
    if [ -z "$CEN_OPT_FORCE" ] && readline -i "$stat" ; then
        if [ "$CEN_READLINE" = "$DAT_HOST" ] ; then
            message -i "Secrets are current:" "$DAT_HOST"
            CEN_OPT_NOHOOK=1; return 0              # do not run centauriswitch
        fi
        trace "Secrets not current:" "$CEN_READLINE"
    fi
    do_dirinit
    trace "Loading secrets from:" "$DAT_HOST"
    if [ "${DAT_ACTIVE:--}" = '-' ] ; then
        __secrets - || __secrets || __secrets || __secrets || __secrets || __secrets || isok=
    else
        __secrets - || __secrets || isok=
    fi

    # report success or failure
    if [ -n "$isok" ] ; then
        message -i "Loaded secrets from:" "$DAT_HOST"
        [ -s "$DAT_DIR_DOWNLOAD/rsync_public" ] ||
            warning -i "Server granted limited access only"
        do_dirinit -u               # update links
        create -t -v DAT_HOST -- "$stat"
        return 0
    fi
    error "Failed to load secrets from:" "$DAT_HOST"
    remove -- "$stat"
    return 1
}

# ------------------------------------------------------------------------------
# get a secrets download server name: [-m|-r] [<host>]
#
# The name is stored in "DAT_HOST" and can later be overridden by do_active.
# The primary and secondary server names are stored in "DAT_SERVER[]".
# ------------------------------------------------------------------------------
do_server() {
    # get options
    local maid refr coun
    if [ "$1" = "-m" ] ; then                   # machine id only
        maid=1 ; shift
    elif [ "$1" = "-r" ] ; then                 # refresh host
        refr="-r" ; shift
    fi
    if [ "${1::1}" = '-' ] ; then               # invalid arg -or- local
        DAT_HOST= ; DAT_SERVER=()
        return 1
    fi

    # get machine id
    if [ -z "$DAT_MACHINE_ID" ] ; then
        local dmid='/var/lib/dbus/machine-id'
        if [ ! "/etc/machine-id" -ef "$dmid" ] ; then
            error "$dmid should be a symlink to /etc/machine-id"
            return 1
        fi
        [ -r "/etc/machine-id" ] &&
            DAT_MACHINE_ID="$(< /var/lib/dbus/machine-id)"
    fi
    [ -n "$maid" ] && return 0

    for ((coun=0 ; coun < 15 ; coun++)) ; do
        [ "$coun" = 0 ] || timer -w 1

        # get a known server - if any
        do_names $refr -p "$1" ; DAT_SERVER[0]="$_do_names"
        do_names       -s "$1" ; DAT_SERVER[1]="$_do_names"
        if   [ -n "${DAT_SERVER[0]}" ] ; then
            DAT_HOST="${DAT_SERVER[0]}"
        elif [ -n "${DAT_SERVER[1]}" ] ; then
            DAT_HOST="${DAT_SERVER[1]}"
        else
            do_names "$1" ; DAT_HOST="$_do_names"
            # have no known server
            if [ -z "$DAT_HOST" ] ; then
                nettemp "centauriswitch" && . "$_nettemp"
                if  [ "$DAT_SWITCH_MODE" = 'static' ] ; then
                    DAT_SERVER[0]="${DAT_CENTAURINAME[3]}"
                    DAT_SERVER[1]="${DAT_CENTAURINAME[4]}"
                    DAT_HOST="${DAT_SERVER[0]}"
                    return 0                    # will poll for server
                fi
                [ "$CEN_ACTION" = 'auto' ] || break
                [ "$DAT_SWITCH_MODE" = 'router' ] && break
                message -a "Waiting to get name server from dhcp" $coun
                continue
            fi
        fi
        return 0                                # check/poll server
    done
    [ "$coun" = 0 ] && message "No guest or master server is known"
    return 1                                    # give up
}

# -----------------------------------------------------------------------------
# Read/write status file: [-w] <host>|- <what>|-
# ------------------------------------------------------------------------------
do_status() {
    # read
    if [ "$1" != '-w' ] ; then
        [ -n "$CEN_SECRETS_MODE" ] && return 0          # already loaded
        CEN_SECRETS_HOST=
        CEN_SECRETS_WHAT=
        CEN_SECRETS_MODE="unknown"
        CEN_SECRETS_IFACE=
        [ -r "$DAT_DIR_TEMP/$CEN_NAME" ] || return 1
        . "$DAT_DIR_TEMP/$CEN_NAME" ;       return 0
    fi

    # check temp dir (created via sys module)
    folder -f "$DAT_DIR_TEMP"

    # prepare data
    [ "$2" = '-' ] || CEN_SECRETS_HOST="$2"
    [ "$3" = '-' ] || CEN_SECRETS_WHAT="$3"
    [ -n "$CEN_SECRETS_MODE" ] || CEN_SECRETS_MODE="unknown"
    dryrun do_status "$*" && return 0

    # write
    trace -a -c "Writing status" "$DAT_DIR_TEMP/$CEN_NAME"
    local mesg="\
${CEN_SECRETS_HOST@A}
${CEN_SECRETS_WHAT@A}
${CEN_SECRETS_MODE@A}
${CEN_OPT_IFACE@A}"
    create -h - -t -v mesg -- "$DAT_DIR_TEMP/$CEN_NAME"

    # update /data folder. Args are: <mode> <server> <nick>
    local what="${CEN_SECRETS_WHAT:-UNKNOWN}"
    if [ "$what" = 'UNKNOWN' ] ; then               # home/guest network offline
        if ! [ '/data/home' -ef '/home' ] ; then
            embed -v centauridata --quiet update "$what" &
        fi
    else                                            # home/guest network online
        embed -v centauridata --quiet update "$what" "$CEN_SECRETS_HOST" "$DAT_CENTAURINAME" &
    fi
}

# -----------------------------------------------------------------------------
# action auto - switch nss, get secrets, setup firewall
# ------------------------------------------------------------------------------
actionAuto() {
    # get status, run 'client' if missing
    if ! do_status ; then
        do_client
    # have server? Run 'client' if not
    elif [ -z "$CEN_SECRETS_HOST" ] ; then
        do_client
    # current
    else
        message "Server is '$CEN_SECRETS_HOST'. No action."
    fi
}

# -----------------------------------------------------------------------------
# action init - setup secrets folder
# ------------------------------------------------------------------------------
actionInit() {
    is_static                       # setup folders
    if [ "${1::3}" = 'dro' ] ; then
        do_dirinit                  # remove downloaded secrets
    else
        do_dirinit -u               # update links
    fi
    do_default                      # fill from config file
}

# -----------------------------------------------------------------------------
# action machines: setup machine folders, update keytabs
# ------------------------------------------------------------------------------
actionMachines() {
    if [ ! -d "$DAT_MACHINE_DIR" ] ; then
        invoke -e "Not a server, missing '%s' folder" "$DAT_MACHINE_DIR"
        return
    fi
    folder -c -f "$DAT_MACHINE_DIR"

    local item dirs=()
    for item in [a-z]* ; do
        [ -d "$item" ] && dirs+=("$item")
    done

    # create/protect folders
    folder -m "@other" 770 "root:wheel"
    system -e -p -- chown "root:wheel" . "${dirs[@]}"
    system -e -p -- chmod 770 . "${dirs[@]}"

    # update keytabs
    for item in "${dirs[@]}" ; do
        [ -e "$item/krb5.keytab" -a -z "$CEN_OPT_FORCE" ] && continue
        embed -v centaurikerberos -y keytab "$item" -O "$item"/krb5.keytab
    done
}

# -----------------------------------------------------------------------------
# action register - create server-side folder, copy machine-id
# ------------------------------------------------------------------------------
actionRegister() {
    do_server -r "$1" || return                 # get home server
    local sdir="$DAT_MACHINE_DIR/$HOSTNAME"
    local verb ; [ "$CEN_VERB" -gt 1 ] && verb='-v'

    sysversion -u || return
    message -p "Register host '%s (%s)' at server '%s'" "$HOSTNAME" "$CEN_SYS_NICKNAME" "$DAT_HOST"
    [ -n "$CEN_SYS_NICKNAME" ] && verb+=" --nick $CEN_SYS_NICKNAME"
    [ -n "$CEN_OPT_FORCE" ] && verb+=" --force"
    system -e -- ssh -x "root@$DAT_HOST" \
        centaurimachines $verb --add "$HOSTNAME/$DAT_MACHINE_ID"
}

# -----------------------------------------------------------------------------
# action secrets - update samba passwords: [<trst>|<file>|- [<wrld>|-]]
# ------------------------------------------------------------------------------
actionSecrets() {
    local sdir="$DAT_DIR_DOWNLOAD"

    # get password: <message> <varname> <path>
    ___getpwd() {
        [ -r "$3" ] && read $2 < "$3" && return 0
        [ -n "$1" ] && error "Don't know password: $1" ; return 1
    }

    # ldap is umaintained since using AD/DC. This code may be broken ...
    ___useldap() {
        local rpw spw str dom
        dom="${CEN_NET_DOMAIN%%.*}"

        if [ -r $DAT_DIR_SECRETS/ldap_samba_master.secret ] ; then
            message "This computer is a '$dom' server ..."
            if [ ! $DAT_DIR_SECRETS/ldap_samba_master.secret -nt /var/lib/samba/secrets.tdb ] ; then
                message -i "Samba password is up to date, no action."
                return
            fi

            ___getpwd "ldap root"    rpw "$DAT_DIR_SECRETS/ldap_root.secret"
            ___getpwd "samba client" str "$DAT_DIR_SECRETS/ldap_samba_client.secret"
            ___getpwd "samba master" spw "$DAT_DIR_SECRETS/ldap_samba_master.secret"
            error -t || return

            system -i -m ldappasswd -x -D cn=admin,dc="$dom",dc=home \
                                        cn=admin,ou=samba,dc="$dom",dc=home \
                                    -s "$str" -w "$rpw" &&
            system -i -m ldappasswd -x -D cn=admin,dc="$dom",dc=home \
                                        uid="domain",ou=users,ou=samba,dc="$dom",dc=home \
                                    -s "$spw" -w "$rpw" &&
            system -i -m smbpasswd  -w "$spw"
        else
            ___getpwd "" spw "$DAT_DIR_SECRETS/ldap_samba_client.secret" ||
                read -r -p "$CEN_NAME: Enter ldap samba client password: " spw
            if [ -z "$spw" ] ; then
                error "Password must not be empty"
                return
            fi
            message "This computer is being made a '$dom' member ..."
            system -i -m smbpasswd  -w    "$spw" \
                                    -c    "/etc/samba/smbpass.conf"
        fi

        str="done" ; [ $CEN_EXIT -gt 1 ] && str="failed"
        message "$str."
    }

    # setup static secrets (server only)
    ___mkstatic() {
        netquery server || return 1
        folder -f -m -s sdir -- "$DAT_DIR_STATIC"
        folder -f -m -s sdir -- "$DAT_DIR_LOCAL"
        return 0
    }

    # create or update /etc/samba/smbpasswd
    ___mkpasswd() {
        local file='/etc/samba/smbpass.conf'
        if [ ! -e "$file" ] || ! system -q -c 'pdbedit' ; then
            warning "Missing samba config:" "$file" ; return
        fi
        message -a "Setting passwords for basic samba"
        system -e -p -- pdbedit -s "$file" -a -u 'smbtrust' -t <<<"$1"$'\n'"$1"
        system -e -p -- pdbedit -s "$file" -a -u 'smbworld' -t <<<"$2"$'\n'"$2"
    }

    # write a secrets file: <file> <user> <pasw> [<ddir>]
    ___usefile() {
        [ "${3:--}" ] && return                     # password, do nothing
        local data dest="${4:-$DAT_DIR_STATIC}"
        trace -a -c "secrets file" -- "$dest/$1"
        case "$1" in
        samba_*)    data=("username=$2" "password=$3") ;;
        rsync_*)    data=("RSYNC_PASSWORD='$3'") ;;
        ldap_*)     data=("$3") ;;
        esac
        create -t -v data -- "$dest/$1"
    }

    # load passwords from seed, make secrets files: <seed>
    ___useseed() {
        local padm ptru ppub prep psyn proo ploc
        do_passwords "$1"
        do_passwords proo 'root'
        do_passwords ploc 'local'
        do_passwords ptru 'smbtrust'
        do_passwords ppub 'smbworld'

        if ___mkstatic ; then
            message -a "Creating server side secrets files"
            do_default -s

            #___usefile 'ldap_samba_client.secret' - "$RANDOM" "$DAT_DIR_LOCAL"
            #___usefile 'ldap_samba_master.secret' - "$RANDOM" "$DAT_DIR_LOCAL"
            #___usefile 'ldap_root'     -            "$RANDOM" "$DAT_DIR_LOCAL"
            #___usefile 'ldap_trusted'  -            "$RANDOM" "$DAT_DIR_LOCAL"
            #___usefile 'ldap_public'   -            "$RANDOM"
            #___usefile 'ldap_other'    -            "$RANDOM"
        fi
        ___mkpasswd "$ptru" "$ppub"
    }

    case "$#" in
    0)      ___useldap ;;
    1)      ___useseed "$1" ;;
    *)      ___mkstatic
            ___usefile 'samba_trusted' 'smbtrust' "$1"
            ___usefile 'samba_prublic' 'smbworld' "$2"
            ___mkpasswd "$1" "$2"
    esac
}

# -----------------------------------------------------------------------------
# action server - the server side, run via inetd: -no arg-
#
# Client validation:  (1) check cookie, exit on failure
#                     (2) check machine-id, return fake secrets on failure
# If the machine folder contains a 'krb5.keytab' it is added to the secrets.
# ------------------------------------------------------------------------------
actionServer() {
    CEN_OPT_SYSLOG=2 ; JOURNAL_STREAM=          # do not garble tar stream
    local host cookie guid
    read host cookie guid
    if [ "$cookie" != "$DAT_COOKIE" ] ; then
        error "Client '${host:-<empty>}' with invalid cookie, got: ${cookie:-<empty>}"
        return
    fi

    # we have a machine dir (server-side staging repositories)
    if [ -d "$DAT_MACHINE_DIR" ] ; then

        local smid sdir sadd mdir="$DAT_MACHINE_DIR/$host"
        if [ -r "$mdir/machine-id" ] ; then
            smid=$(<"$mdir/machine-id")
            if [ "$smid" != "$guid" ] ; then
                error "Host sent bad secret:" "$host"
                mdir="$DAT_MACHINE_DIR/@other"
            fi
        else
            mdir="$DAT_MACHINE_DIR/@other"
            [ -d "$mdir" ] || folder -f -m "$mdir" 770 "root:wheel"
            warning "Host is not registered:" "$host"
        fi
        folder -c -f "$mdir"

        [ -f "krb5.keytab" ] && sadd="--add-file=./krb5.keytab "
        [ -f "repository.conf" ] && sadd+="--add-file=./repository.conf "

    # no machine dir (are we a guest server?)
    else
        local mdir sdir
        [ ! -d "$DAT_DIR_STATIC" ] &&
            invoke -e "Not a server and missing '%s' folder" "$DAT_DIR_STATIC"
    fi

    # create fake folder if needed
    if [ -d "$DAT_DIR_STATIC" -a "$mdir" != "$DAT_MACHINE_DIR/@other" ] ; then
        sdir="$DAT_DIR_STATIC"
    else
        warning "No server data, using fake"
        sdir="$DAT_DIR_FAKE" ; folder -f -m "$sdir"
        if ! matchpath -e -o -- "$sdir"/* ; then
            message "Populating fake data"
            do_default -f
        fi
    fi
    [ '/root/.ssh/id_rsa.pub' -nt "$sdir/ssh_server_key.pub" ] &&
        copy -u '/root/.ssh/id_rsa.pub' "$sdir/ssh_server_key.pub"
    tar -cz $sadd --directory="$sdir" .
    message "Sent secret data to: $host"
}

# -----------------------------------------------------------------------------
# action client - the client side: <host>
# ------------------------------------------------------------------------------
actionStart() {
    local host="$1"
    [ "$CEN_ACTION" = 'local' ] && host='-'     # switch to local mode
    do_client "$host"
}

# -----------------------------------------------------------------------------
# action status - list secrets files: -no args-
# ------------------------------------------------------------------------------
actionStatus() {
    local stat='-'                      # get status
    do_status && system -e -p -r -s stat -- date -r "$DAT_DIR_TEMP/$CEN_NAME" +'%Y-%m-%d %H:%M:%S'
    local data="$DAT_DIR_DOWNLOAD"
    is_static -r && prettypath -c -e -s data "$DAT_DIR_STATIC"
    local serv="${CEN_SECRETS_HOST:--none-}"
    do_server -m                        # get machine id only

    if [ "$CEN_VERB" -gt 1 -a "$EUID" = 0 ] ; then echo "
Files in '$data' ($CEN_SECRETS_MODE from $stat):

$([ -d "$data" ] && ls -ABC "$data" -I ".*" || echo "-no data folder-")

Server: '$serv'   Machine-ID: $DAT_MACHINE_ID
"
    else echo "
    Secrets time: $stat ($CEN_SECRETS_MODE)
            path: $data
          server: $serv
    Machine-ID  : $DAT_MACHINE_ID
"
    fi
}

# ------------------------------------------------------------------------------
# Option parsing
# ------------------------------------------------------------------------------
options() {
    case "$CEN_ACTION" in
    '')                                 # end of option parsing ...
        trace "main ${CEN_CMDOPTS[@]} ${CEN_CMDARGS[@]}"
        ;;
    -I|--int*)
        optarg 'interface'  -       -t ;;           # text
    -P|--pol*)
        optarg 'poll'       -       "ldap|ping|all" ;;
    --noh*)
        optarg 'nohook'     -       ;;              # flag
    esac
}

# ------------------------------------------------------------------------------
# Action parsing
# ------------------------------------------------------------------------------
actions() {
    case "$CEN_ACTION" in

    '') netconfig -f                                # get network config or die
        [ -z "$DAT_PORT_POLL" ] && DAT_PORT_POLL="$CEN_NET_PORT_ADNS"
        ;;

    # service commands
    start)
        invoke -        -               0 ;;
    stop)
        invoke -        actionInit      0 ;;
    sta*)
        invoke "status" -               0 ;;

    # mode switching
    aut*)
        invoke "auto"   -               0 ;;
    cli*)
        invoke "client" actionStart   0 1 ;;
    loc*)
        invoke 'local'  actionStart     0 ;;

    # other commands
    ini*)
        invoke "init"     -           0 1 ;;
    mac*)
        invoke "machines" -             0 ;;
    reg*)
        invoke "register" -           0 1 ;;
    lda|ldap)
        invoke "ldap"     actionSecrets   ;;
    sam*)
        invoke "samba"    actionSecrets 2 ;;
    sec*)
        invoke "secrets"  -             1 ;;
    ser*)
        invoke "server"   -             0 ;;
    esac
}

# ------------------------------------------------------------------------------
# Print usage info
# ------------------------------------------------------------------------------
usage() {
    do_names                            # get server name

    usageset \
       -o - \
       -o "-I --interface <ifn> interface for conditional state change" \
       -o "-P --poll     <meth> poll method, on of: ldap ping all" \
       -o "-N --nohook          do not notify centauriswitch"
    usageset \
       -s "start                Runs 'client'. Called on service start" \
       -s "stop                 Runs 'init'. Called on service stop" \
       -s "restart              Same as: stop -- start" \
       -s "status               Show status information"
    usageset \
       -a "ldap                 LDAP SAMBA: set the samba machine and ldap passwords" \
       -a "samba <trus> <wrld>  BASIC SAMBA: setup password files for shares" \
       -a "secrets  <seed>      init password files from seed file" \
       -a - \
       -a "machines             Server side update of machines keytabs" \
       -a "register [<server>]  Register this computer at server" \
       -a "server               Server secrets provider (called via inetd)" \
       -a - \
       -a "init     [drop]      Initilize and update links or drop secrets" \
       -a "auto                 Find an active server and download secrets." \
       -a "                     Does nothing if secrets and state are current" \
       -a "client   [<server>]  Find/check an active server and download secrets." \
       -a "                     The default server is: "${_do_names:--}"" \
       -a "                     No <server> arg: check if server is still valid" \
       -a "local                drop current secrets, init secrets to defaults" \

    usagecat << !EOF
$CEN_USE_HEADER This tool invokes
       centauriswitch to adjust the computer's network configuration.

$CEN_USE_OPTIONS

$CEN_USE_ACTIONS

Even though $CEN_NAME can be run as a service, it is tpyically run by
centauriswitch as a helper tool. centauriswitch disables the service start
of $CEN_NAME.

$CEN_NAME manages the "$DAT_DIR_SECRETS" folder which contains some
symlinks to files containing secrets. On a client the targets are downloaded
from the server, see "$DAT_DIR_DOWNLOAD" which is temporary.

Only a server should have a static secrets folder "$DAT_DIR_STATIC".
Servers can send this data to clients, by using the tools inetd, tar, zip and
"$CEN_NAME server", see "/etc/inetd.conf".

When no secrets can be downloaded the rules in "$DAT_DEFAULT"
are used to create local fake data, see "$DAT_DIR_FAKE".
The rules file is distributed to all clients via the repository and must not
contain any sensitive information.

The command "$CEN_NAME register" is used by "centaurikerberos client" to
register a client with the centauri repository, see "centaurimachines" and
"centauriconfig".

Finally basic samba (no AD/DC) is supported by "$CEN_NAME samba". This
is used on a server to initialize "/etc/samba/smbpasswd" and the "samba_xxxx"
secrets files.
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
