#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2019-2024; BSD License"
CEN_TITLE=$"Documentation generator for centauri-bash-lib and centauritools"

# Import the bash library, set name and version
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -i -r -t -y - '0.21:2' 0 || exit 2

# Data
CEN_OPT_ALL=                    # see --all
CEN_OPT_BROWSE=                 # see --browse
CEN_OPT_CONTENT=                # see --content
CEN_OPT_DELETE=                 # see --delete
CEN_OPT_FILE=                   # see --file
CEN_OPT_GENERATE=               # see --generate
CEN_OPT_HTML=                   # see --html
CEN_OPT_INDEX=                  # see --index
CEN_OPT_L10N=                   # see --l10n
CEN_OPT_LIBRARY=                # see --library
CEN_OPT_LINES=                  # see --lines
CEN_OPT_MODULES=                # see --modules
CEN_OPT_REFERENCE=              # see --refence
CEN_OPT_TOOLS=                  # see --tools
CEN_OPT_USE=                    # see --use

DAT_DOCO='-5 -i 0'              # xml_document options

DAT_FMT_MODE=                   # 0: text  1: deco  2:html
DAT_FMT_TYPE='plain'            # call suffix 'plain' or 'html'
DAT_FMT_PARSE='full'            # call suffix 'full' or 'mini' (parser)

DAT_FMT_ULIN=                   # ANSI underline
DAT_FMT_BOLD=                   # ANSI bold
DAT_FMT_ITAL=                   # ANSI italics
DAT_FMT_NORM=                   # ANSI normal mode

DAT_AUTOLIST=                   # set formatter()
DAT_AUTOTRIM=

DAT_SEP_ITEM=                   # separator line
DAT_OUT_OPTS=                   # options for output
DAT_LST_FILE=                   # input files, see run_files()
DAT_CNT_FILE=0                  # file count
DAT_CNT_ITEM=0                  # items ...
DAT_HDR_CACHE=                  # doc header cache, see run_cache()

DAT_INP_FILE=                   # from documentation worker
DAT_INP_LINE=                   # input file/line, see linesplit()
DAT_INP_NAME=                   # element name, see linesplit()
DAT_INP_FAST=                   # use body text without linesplit
DAT_OUT_FILE=                   # output file, see run_process()

DAT_MOD_VERS=                   # module version, see module()
DAT_MOD_MAINT=                  # maintenance tools flag

DAT_FLG_EBEG=                   # flags open section, see element_item_html
DAT_FLG_ECNT=                   # section counter, see ...

DAT_TAB_ROWS=()                 # used with xml_table to fill table

DAT_CHAR_MARKER='-+.,'          # format marker chars, set for []
DAT_CHAR_LABEL='-°[:word:]'     # chars allowed in label, set for []
                                # static links: [<name> [<file>]] ...
DAT_BOOKMARK=('library index' 'browse' 'applications tools' 'autoload' 'uglify' 'l10n-tool'
 'centauribuilder' 'centauricreate' 'centaurihelp' 'centaurilauncher' 'centaurinetcfg' 'centauripaths')
                                # utilities that are part of the library
DAT_UTILS=('library/autoload' 'library/uglify' 'locale/l10n-tool')

# --- serializable data ---

DAT_REF_FUNCTIONS=()    # list of functions, see reference()
DAT_REF_MODULES=()      # list of modules/topics/tools, ...
DAT_REF_TOPICS=()
DAT_REF_TOOLS=()

declare -A DAT_BMK_NAMES DAT_BMK_TOOLS      # bookmark: link/tools name lookup

DAT_SERIALIZE='DAT_REF_TOOLS DAT_REF_MODULES DAT_REF_TOPICS DAT_REF_FUNCTIONS'
DAT_SERIALIZE+=' DAT_BMK_NAMES DAT_BMK_TOOLS'

# --- filled from deserialized data ---

declare -A DAT_BMK_NEXT DAT_BMK_PREV

# ------------------------------------------------------------------------------
# includes - write default.js and default.css
# ------------------------------------------------------------------------------
includes() {
    local item
    for item in "js" "css" ; do
        if [ -d "$CEN_OPT_HTML" ] ; then
            file="$CEN_OPT_HTML/default.$item"
            [ "$BASH_SOURCE" -nt "$file" ] || continue
            dryrun "Creating: $file" && continue
            includes_$item "$file"
        else
            file="$CEN_OPT_HTML"
        fi
    done
}

# ------------------------------------------------------------------------------
includes_js() {
    create -t -c -- "$1" <<!EOF
/* ${1##*/} - autogenerated by $CEN_NAME - do not edit */

function initialize(page) {         // called from body onload
    var obj = document.firstElementChild;
    obj.setAttribute('onkeydown', 'keydown(event)');
}

function keydown(event) {
    switch(event.key) {
        case 'Backspace':
            history.back(); break;
        case 'q':
        case 'Escape':
            console.log("QUIT"); break;         // handled in qml code
        case 'a':
            window.location='tools.html'; break;
        case 'c':
            window.location='content.html'; break;
        case 'h':
            window.location='browse.html'; break;
        case 'i':
            window.location='index.html'; break;
        case 'l':
            window.location='index.html'; break;
        case 'm':
            window.location='module.html'; break;
        case 'r':
            window.location='reference.html'; break;
        case 't':
            window.location='tools.html'; break;
        case 'n':
        case 'ArrowRight':
            navigate('right'); break;
        case 'p':
        case 'ArrowLeft':
            navigate('left'); break;
        default:
            console.log("Key: ", event.key)
    }
}

function navigate(dest) {
    var elts = document.getElementsByClassName('nav-' + dest);
    if (elts.length < 1) return;
    var child=elts[0].firstChild; if (child == null) return;
    dest=child.getAttribute('href'); if (dest != null) window.location=dest;
}
!EOF
}

# ------------------------------------------------------------------------------
includes_css() {
#    local fbig='14pt' fmed='12pt' fsml='11pt'
    local fbig='13pt' fmed='11pt' fsml='10pt'
    create -t -c -- "$1" <<!EOF
/* ${1##*/} - autogenerated by $CEN_NAME - do not edit */

/* --- tag selectors --- */

a {
    font-family: monospace;
    text-decoration: none;
    color: inherit;
}

body {
    background-color: #eff6f8;
    margin-top: 0;
    margin-bottom: 0;
}

p {
    margin: 1em;
    text-align: justify;
    font-size: $fmed;
}

i, em, b {
    font-family: monospace;
}

pre {
    background-color: ivory;
    padding: 4pt;
    border: 2pt;
    border-style: dotted;
    border-color: burlywood;
    margin: 4pt 0 0 0;
    min-width: 50em;
    width: 50em;
}

/* --- headers --- */

h2, div.item-module {
    font-size: $fbig;
    background-color: lavender;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-script {
    font-size: $fbig;
    background-color: aquamarine;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-header {
    font-size: $fbig;
    background-color: beige;
    margin-top: 1em;
    margin-bottom: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-topic {
    font-size: $fbig;
    background-color: khaki;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

div.item-function {
    font-size: $fbig;
    background-color: wheat;
    margin-top: 1em;
    border-style: outset;
    border-width: thin;
    padding: 3pt;
}

/* --- definitions --- */

div.def-row {
    display: table-row;
}

div.def-label {
    display: table-cell;
    padding-top: 1em;
    min-width: 8em;
    font-weight: bold;
    font-size: $fsml;
}

div.def-empty {
    display: table-cell;
    width: 8em;
    font-size: $fsml;
}

div.def-text {
    display: table-cell;
    font-size: $fsml;
    font-family: monospace;
    white-space: pre;
}

div.def-block {
    display: table-cell;
    font-size: $fsml;
    font-family: monospace;
    text-align: justify;
}

div.def-break {
    height: 6pt;
}

/* ---- table for index etc. ---- */

table {
    font-size: $fsml;
    margin-left: 0.5em;
    border-spacing: 8pt 2pt;
}

td {
    font-weight: bold;
}

td.module, td:first-child {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 2pt 2pt 8pt;
    background-color: lavender;
    min-width: 14em;
}

td.topic {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 8pt 2pt 8pt;
    background-color: khaki;
}

td.function {
    font-family: monospace;
    font-weight: normal;
    border: 1pt solid black;
    padding: 2pt 8pt 2pt 8pt;
    background-color: wheat;
}

/* ---- navigator (table layout) ---- */

nav {
    font-size: $fsml;
    display: table;
    width: 100%;
    background-color: cadetblue;
    color: white;
    font-weight: bold;
    border-style: solid;
    border-width: thin;
    border-color: black;
    box-sizing: border-box;
}

div.nav-row {
    display: table-row;
}

div.nav-left {
    display: table-cell;
    width: 30%;
    text-align: left;
}

div.nav-right {
    display: table-cell;
    width: 30%;
    text-align: right;
}

div.nav-mid {
    display: table-cell;
    width: 20%;
    text-align: center;
}

/* ---- colorize anchors in defines ---- */

.def-block a {
    color: blueviolet;
}

.def-text a {
    color: blueviolet;
}

/* ---- join navigation with 1st section ---- */

#section-1 div {
    margin-top: 0;
}
!EOF
}

# ------------------------------------------------------------------------------
# parser - use regular expressions to parse text (return via BASH_REMATCH)
# ------------------------------------------------------------------------------
REX_apos="(.*)'(')'(.*)"            # '''       Literal apostroph
REX_litr="(.*)''(.*)''(.*)"         # ''xxx''   literals
REX_bold="(.*)\*\*(.*)\*\*(.*)"     # **xxx**   bold
REX_quot="(.*)(\".*\")(.*)"         # "xxx"     quoted
REX_ital="(.*)<<(.*)>>(.*)"         # <<xxx>>   italics
REX_link="(.*)\[\[(.*)\]\](.*)"     # [[xxx]]   link
REX_void="(.*)<()>(.*)"             # <>        placeholder

REX_hash="(.* |^)(# .*)"            # used by formatter()
REX_para="(.* )§ (.*)"              # used by formatter()
REX_vari="(.*)<([a-zA-Z][a-zA-Z|]*)>(.*)"       # varibale
REX_cons="(.*[^A-Z_]|^)([A-Z_]+_[A-Z_]*)(.*)"   # constant

REX_sopt="(.*[^-a-zA-Z]|^)(-[-a-zA-Z])([^-a-zA-Z].*|$)" # short option
REX_lopt="(.*)(--[a-z]*)(.*)"                           # long option
REX_plus="(.*[\[|])([-+])(\|.*|].*)"    # syntax notation

parser_full() {
    # bash globbing is used in a 1st step because bash regex is quite slow
    # The glob expression is only used to reduce the number of regex calls.

    [[ "$1" == *\'\'\'* ]]     && [[ "$1" =~ $REX_apos ]] && return 1
    [[ "$1" == *\'\'* ]]       && [[ "$1" =~ $REX_litr ]] && return 1
    [[ "$1" == *\*\** ]]       && [[ "$1" =~ $REX_bold ]] && return 3  # bold
    [[ "$1" == *\"*\"* ]]      && [[ "$1" =~ $REX_quot ]] && return 3  # bold
    [[ "$1" == *\[\[*\]\]* ]]  && [[ "$1" =~ $REX_link ]] && return 4  # ulin
    [[ "$1" == *\<\<*\>\>* ]]  && [[ "$1" =~ $REX_ital ]] && return 2  # ital
    [[ "$1" == *\<\>* ]]       && [[ "$1" =~ $REX_void ]] && return 5

    [ "$DAT_FMT_MODE" = "0" ] && return 0       # simple text formatting

    [[ "$1" == *-[a-zA-Z-]* ]]       && [[ "$1" =~ $REX_sopt ]] && return 3  # bold
    [[ "$1" == *--[a-zA-Z]* ]]       && [[ "$1" =~ $REX_lopt ]] && return 3  # bold
    [[ "$1" == *\<[a-zA-Z]*\>* ]]    && [[ "$1" =~ $REX_vari ]] && return 2
    [[ "$1" == *[A-Z]_[A-Z]* ]]      && [[ "$1" =~ $REX_cons ]] && return 3  # bold
    [[ "$1" == *[\[\|][-+][\]\|]* ]] && [[ "$1" =~ $REX_plus ]] && return 3  # bold

    [ -n "$DAT_INP_NAME" ] && [[ "$1" == *$DAT_INP_NAME* ]] &&
        [[ "$1" =~ (.* |^)($DAT_INP_NAME)([^a-z].*|$) ]] && return 3
    return 0
}

parser_mini() {
    [[ "$1" == *\'\'\'* ]]     && [[ "$1" =~ $REX_apos ]] && return 1
    [[ "$1" == *\'\'* ]]       && [[ "$1" =~ $REX_litr ]] && return 1
    [[ "$1" == *\*\** ]]       && [[ "$1" =~ $REX_bold ]] && return 3  # bold ???
    [[ "$1" == *\"*\"* ]]      && [[ "$1" =~ $REX_quot ]] && return 3  # bold

    [ "$DAT_FMT_MODE" = "0" ] && return 0       # simple text formatting

    [[ "$1" == *-[a-zA-Z-]* ]]       && [[ "$1" =~ $REX_sopt ]] && return 3  # bold
    [[ "$1" == *--[a-zA-Z]* ]]       && [[ "$1" =~ $REX_lopt ]] && return 3  # bold
    [[ "$1" == *[A-Z]_[A-Z]* ]]      && [[ "$1" =~ $REX_cons ]] && return 3  # bold

    [ -n "$DAT_INP_NAME" ] && [[ "$1" == *$DAT_INP_NAME* ]] &&
        [[ "$1" =~ (.* |^)($DAT_INP_NAME)([^a-z].*|$) ]] && return 3
    return 0
}

# ------------------------------------------------------------------------------
# text formatting: formatter <text>   # see DAT_FMT_MODE
# ------------------------------------------------------------------------------
# find symlin target (return: _temp)
formatter_deco_link() {
    _temp="${1,,}"
    case "$_temp" in
        index|content|module|reference|tools)
                    _temp+='.html' ; return 0 ;;
        _*_*_*)     _temp+='.html' ; return 0 ;;
        [a-z]*)     bookmark -c _temp "$_temp" && return 0 ;;
    esac
    return 1
}

# create decorated output: <mode> <left> <deco> <righ> (return: _temp)
formatter_deco_plain() {
    case "$1" in
        2)  _temp="$2$DAT_FMT_ITAL$3$DAT_FMT_NORM$4" ;;
        3)  _temp="$2$DAT_FMT_BOLD$3$DAT_FMT_NORM$4" ;;
        4)  _temp="$2$DAT_FMT_ULIN$3$DAT_FMT_NORM$4" ;;
        5)  [ "$DAT_FMT_MODE" = 0 ] && _temp="$2  $4"
            [ "$DAT_FMT_MODE" = 1 ] && _temp="$2$4" ;;
        *)  _temp="$2$3$4"
    esac
}

formatter_deco_html() {
    local _esc3 _eleb _elee
    case "$1" in
        2)  _eleb='<i>'  ; _elee='</i>' ;;
        3)  _eleb='<b>'  ; _elee='</b>' ;;
        4)  if formatter_deco_link "$3" ; then
                _eleb="<a href=\"$_temp\">" ; _elee='</a>'
            else
                _eleb='<em>' ; _elee='</em>'
            fi ;;
        5)  _temp="$2$4" ;  return ;;
    esac
    xml_text -v _esc3 -- "$3"
    _temp="$2$_eleb$_esc3$_elee$4"
}

# helper to recursively parser input: <text>
formatter_full() {
    local _mode
    parser_$DAT_FMT_PARSE "$1"
    case $? in
        1)  ;;
        2)  [ -z "$_mraw" ] && _mode=2 ;;
        3)  [ -z "$_mraw" ] && _mode=3 ;;
        4)  [ -z "$_mraw" ] && _mode=4 ;;
        5)  [ -z "$_mraw" ] && _mode=5 ;;
        *)  [ "$DAT_FMT_MODE" = 2 ] || return 1     # no change
            xml_text -v _temp -- "$1" ; return 0    # escape html
    esac

    local _tmp1="${BASH_REMATCH[1]}"
    local _tmp2="${BASH_REMATCH[2]}"
    local _tmp3="${BASH_REMATCH[3]}"

    # recurse only if not single char
    if [ "${#_tmp1}" -gt 1 ] ; then
        formatter_full "$_tmp1" && _tmp1="$_temp"
    elif  [ "$DAT_FMT_MODE" = 2 ] ; then
        xml_text -v _tmp1 -- "$_tmp1"
    fi
    if [ "${#_tmp3}" -gt 1 ] ; then
        formatter_full "$_tmp3" && _tmp3="$_temp"
    elif  [ "$DAT_FMT_MODE" = 2 ] ; then
        xml_text -v _tmp3 -- "$_tmp3"
    fi

    formatter_deco_$DAT_FMT_TYPE "$_mode" "$_tmp1" "$_tmp2" "$_tmp3"
    return 0
}

# format without decorating, return length difference in _diff
formatter_diff() {
    local _styp="$DAT_FMT_TYPE" _smod="$DAT_FMT_MODE"
    DAT_FMT_TYPE=plain ; DAT_FMT_MODE=1
    _mraw=1
    if formatter_full "$1" ; then           # changed something
        DAT_FMT_TYPE="$_styp" ; DAT_FMT_MODE="$_smod"
        _mraw= ; _diff=$((${#1} - ${#_temp}))
        [ "$_diff" -gt 0 ] ; return         # return status
    else                                    # nothing changed
        DAT_FMT_TYPE="$_styp" ; DAT_FMT_MODE="$_smod"
        _mraw= ; return 1
    fi
}

formatter() {
    local _temp _mraw _diff _mesg

    # --- setup ---

    if [ -z "$DAT_FMT_MODE" ] ; then
        if [ -n "$CEN_OPT_HTML" ] ; then
            DAT_FMT_MODE=2
        elif console ; then
            printf -v DAT_FMT_BOLD "$CEN_DECO_BOLD"
            printf -v DAT_FMT_ITAL "$CEN_DECO_ITAL"
            printf -v DAT_FMT_ULIN "$CEN_DECO_ULIN"
            printf -v DAT_FMT_NORM "$CEN_DECO_NORM"
            DAT_FMT_MODE=1
        else
            DAT_FMT_MODE=0
        fi
    fi

    # --- do the formatting ----

    local -n _varg="$1"
    local _mesg="${_varg//°/ }"                     # ° is an alias for space
    if [ "$_varg" != "$_mesg" ] ; then              # may be quoted: ''°''
        local _quot="${_varg//\'\'°\'\'/$'\a'}"
        if [ "$_varg" = "$_quot" ] ; then           # not quoted
            _varg="$_mesg"
        else
            _quot="${_quot//°/ }" ; _varg="${_quot//$'\a'/°}"
        fi
    fi
    if [ -z "${_varg// /}" ] ; then                 # empty line
        DAT_AUTOLIST= ; DAT_AUTOTRIM= ; return
    fi

    # keep indentation for inline comments
    if [[ "$_varg" == *\ #\ * ]] && [[ "$_varg" =~ $REX_hash ]] ; then
        local _tmp1="${BASH_REMATCH[1]}"            # left side
        local _tmp2="${BASH_REMATCH[2]}"            # the comment

        # do format the left side without decorations to get the
        # length difference of printable characters ...
        formatter_diff "$_tmp1" &&                  # changed, indent...
            printf -v _tmp1 "%s%${_diff}s" "$_tmp1" ""
        formatter_full "$_tmp1" && _tmp1="$_temp" # format left side
        [ -n "$CEN_OPT_HTML" ] && xml_text -v _tmp2 -- "$_tmp2"
        _varg="$_tmp1$_tmp2" ; DAT_AUTOLIST= ; DAT_AUTOTRIM=

    # keep indentation for § marker
    elif [[ "$_varg" == *\ §\ * ]] && [[ "$_varg" =~ $REX_para ]] ; then
        local _tmp1="${BASH_REMATCH[1]}"            # left side
        local _tmp2="${BASH_REMATCH[2]}"            # the remainder
        formatter_diff "$_tmp1" &&                  # changed, indent...
            printf -v _tmp1 "%s%${_diff}s" "$_tmp1" ""
        formatter_full "$_tmp1" && _tmp1="$_temp"   # format left side
        formatter_full "$_tmp2" && _tmp2="$_temp"   # format remainder
        _varg="$_tmp1$_tmp2" ; DAT_AUTOLIST= ; DAT_AUTOTRIM=

    # auto list mode - after normal output line only - if line is indented
    elif [ "$DAT_FMT_MODE" != "0" -a -n "$DAT_AUTOLIST" ] &&
         [ "${#_varg}" -gt 4 -a "${_varg::4}" = "    " ] ; then
        if [ -z "$DAT_AUTOTRIM" ] ; then            # not a follow-up line
            local _len1="${_varg%%[! ]*}" ; _len1="${#_len1}"
            local _left="${DAT_AUTOLIST::_len1}"
            formatter_diff "$_left" &&              # changed something...
                DAT_AUTOTRIM="$_diff"
        fi
        [ -n "$DAT_AUTOTRIM" ] && _varg="${_varg:$DAT_AUTOTRIM}"
        formatter_full "$_varg" && _varg="$_temp"

    # no inline comment
    else
        DAT_AUTOTRIM=
        if formatter_full "$_varg" ; then
            DAT_AUTOLIST="$_varg" ; _varg="$_temp"
        else
            DAT_AUTOLIST=
        fi
    fi
}

# ------------------------------------------------------------------------------
# Format a definition: [-b|-o] <labl> <line>...
#
#   -b      remark mode (HTML: justify)
#   -o      append mode (HTML: no vertical space)
#
# There are five processing modes:
#
# Mark: ' '  Simple : full decoration, auto formatting
#       '+'  Justify: full decoration, auto formatting    (HTML: justify)
#       ','  List   : full decoration, minimal formatting (HTML: preformatted)
#       '-'  Literal: minimal decoration, no formatting   (HTML: preformatted)
#       '.'  Example: minimal decoration, no formatting   (HTML: preformatted)
# ------------------------------------------------------------------------------
definition() {
    local oflg
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   oflg='-' ;;
      -o)   oflg="+" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    DAT_AUTOLIST=
    if [ "$#" = 0 ] ; then
        definition_$DAT_FMT_TYPE
    else
        definition_$DAT_FMT_TYPE "$oflg" "$@"
    fi
    DAT_FMT_PARSE=full                  # call suffix 'full' or 'mini' (parser)
}

# ------------------------------------------------------------------------------
# Format a definition: - <indent> <label> <line>...
# ------------------------------------------------------------------------------
DAT_DEF_OPEN=       # flags that HTML output needs <br>
DAT_DEF_IDNT=10     # input text: full margin (3 tabs of 4)
DAT_DEF_MODE=       # processing mode, see definition_split()

# handle label/message split: <line> [uses 'labl, mesg, lout']
definition_split() {
    # if the 1st text char was a space, it got removed by documentation()
    DAT_DEF_MODE="${mesg::1}"                   # text prefix
    case "$DAT_DEF_MODE" in
        .)  mesg="${mesg:1}" ; DAT_FMT_PARSE=mini ;;    # should become a box
        ,)  mesg="${mesg:1}" ;;                         # should become a list
        -)  mesg="${mesg:1}" ; DAT_FMT_PARSE=mini ;;    # justify
        +)  mesg="${mesg:1}" ;;                         # justify
        *)  DAT_DEF_MODE=
    esac

    local lmar="${mesg::DAT_DEF_IDNT}"
    if [ -z "${lmar// /}" ] ; then              # has full margin....
        mesg="${mesg:DAT_DEF_IDNT}"
    else                                        # just trim left...
        mesg="${mesg#"${mesg%%[![:space:]]*}"}"
    fi

    if [ -n "$labl" ] ; then                    # remove label
        local llen="${#labl}"
        # this works only if the label is not repeated
        if [ "$labl" = "${mesg::llen}" ] ; then
            mesg="${mesg:llen}"
        fi
        mesg="${mesg#"${mesg%%[![:space:]]*}"}"
        lout="${labl//°/ }" ; labl=             # ° are alias for space
    fi
}

definition_plain() {
    local idnt="$1" labl="$2" mesg pref lout ftrm fill ; shift 2
    [ "$idnt" = '-' -o "$idnt" = '+' ] && ftrm=1

    # empty definition (empty line)
    mesg="${1%*:-}"
    if [ -z "$labl" -a -z "$mesg" ] ; then
        echo ; return
    fi

    # print a definition line: pref lout mesg
    ___print() {
        if [ -z "$lout" ] ; then                # left side empty...
            if [ -z "$mesg" ] ; then
                echo "$pref"                    # empty line
            else
                printf "$pref           %s\n" "$mesg"
            fi
        else
            printf "$pref$CEN_DECO_BOLD%-11s$CEN_DECO_NORM%s\n" "$lout" "$mesg"
            lout=
        fi
    }

    # format output fragment: <vtext> <vleng>
    ___format() {
        local -n _ftxt="$1" _leng="$2"
        local _temp _mraw _diff                 # HACK variables for formatter_diff
        formatter_diff "$_ftxt"
        [ -n "$_diff" ] && ((_leng += _diff))
    }

    # loop over output lines
    while [ $# -gt 0 ] ; do
        if [ -n "$DAT_INP_FAST" ] ; then
            mesg="$1" ; shift
        else
            linesplit -b mesg - - pref "$1" ; shift
        fi
        definition_split                        # strip label

        [ -n "$ftrm" -a -z "$DAT_DEF_MODE" ] &&
            mesg="${mesg#"${mesg%%[![:space:]]*}"}"     # trim left

        if [ -n "$fill" ] ; then                # keep fill mode
            fill+=" $mesg" ; continue
        fi

        case "$DAT_DEF_MODE" in
        .)  mesg="┃ $mesg" ;;                   # box mode
        ,)  if [ "${mesg::2}" = "- " ] ; then   # list mode
                mesg="• ${mesg:2}"
            else
                mesg="  ${mesg#"${mesg%%[![:space:]]*}"}"
            fi ;;
        +)  if [ -z "$CEN_OPT_LINES" ] ; then
                fill+=" $mesg" ; continue
            fi
        esac

        formatter mesg                          # format right side
        ___print # pref lout mesg               # print line
    done
    [ -z "$fill" ] && return

    # format fill mode string
    local fwid="${CEN_COLS:-80}" ; ((fwid -= 11))
    while txtfold -f ___format -m "$fwid" -s mesg -i fill ; do
        formatter mesg                          # format right side
        ___print # pref lout mesg               # print line
    done
}

definition_html() {
    local idnt="$1" labl="$2" mesg mout lout fbox; shift 2
    local sepa=$'\n' mtxt="def-text"

    if [ "$idnt" = '-' ] ; then
        sepa=" " ; mtxt="def-block"
    elif [ "$idnt" = "+" ] ; then
        DAT_DEF_OPEN=
    fi

    # empty definition (empty line)
    mesg="${1%*:-}"
    if [ -z "$labl" ] ; then
        if [ -n "$DAT_DEF_OPEN" ] ; then
            xml_element 'div' -c "def-break" -n
            DAT_DEF_OPEN=
        fi
        [ -z "$mesg" ] && return
    fi

    # loop over output lines
    while [ $# -gt 0 ] ; do
        if [ -n "$DAT_INP_FAST" ] ; then
            mesg="$1" ; shift
        else
            linesplit -b mesg - - - "$1" ; shift
        fi
        definition_split                        # strip label

        if [ -n "$DAT_DEF_MODE" ] ; then        # display in box
            if [ -z "$fbox" ] ; then
                sepa=$'\n'
                if [ "$DAT_DEF_MODE" = "." ] ; then
                    mout+="<pre>" ; fbox=1
                elif [ "$DAT_DEF_MODE" = '-' ] ; then
                    mout+="<pre>" ; fbox=2
                elif [ "$DAT_DEF_MODE" = "," ] ; then
                    mtxt="def-text" ; fbox=3
                elif [ "$DAT_DEF_MODE" = "+" ] ; then
                    mtxt="def-block" ; sepa=" "
                fi
            fi
        fi

        [ "$sepa" = " " ] && mesg="${mesg#"${mesg%%[![:space:]]*}"}"
        [ "$fbox" = "3" -a "${mesg::2}" = '- ' ] && mesg="•${mesg:1}"
        formatter mesg                          # format right side

        if [ -n "$mout" ] ; then                # continuation line
            if [ "$fbox" = 1 ] ; then
                mout+="$mesg" ; fbox=2
            elif [ "$fbox" = "3" ] ; then
                mout+="$sepa  $mesg"
            else
                mout+="$sepa$mesg"
            fi
        else                                    # 1st line
            if [ "$fbox" = "3" ] ; then
                mout="  $mesg"
            else
                mout="$mesg"
            fi
        fi
    done
    [ -n "$fbox" -a "$DAT_DEF_MODE" = "." ] && mout+="</pre>" ; fbox=

    xml_element 'div' -b -n -i -c "def-row"
    if [ -n "$lout" ] ; then
        xml_element 'div' -c "def-label" -n -t -- "$lout"
    else
        xml_element 'div' -c "def-empty" -n
    fi
    xml_element 'div' -n -c "$mtxt" -- "$mout"
    xml_element 'div' -e -n -u
    DAT_DEF_OPEN=1
}

# ------------------------------------------------------------------------------
# Bookmark management
#
# Call:     bookmark -a <name> <kind> <file> <text>
#           bookmark -c <rslt> <item> <file> <line>
#           bookmark -m
#           bookmark -n|-p <rslt> <current>
#           bookmark -r <rslt> <name> [<file>]
#           bookmark -x <name> [<file>]
#
# Options:  -a  add to dictionary
#           -c  check against dict, return href
#           -m  init module prev/next
#           -n  next module
#           -p  previous module
#           -r  create href or ID
#           -x  add external reference to dictionary
# ------------------------------------------------------------------------------
bookmark() {
    local oadd ochk omak onxt oref oext snam href
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   oadd=1 ;;
      -c)   ochk=1 ; shift ; snam="$1" ;;
      -m)   omak=1 ;;
      -n)   onxt=1 ; shift ; snam="$1" ;;
      -p)   onxt=2 ; shift ; snam="$1" ;;
      -r)   oref=1 ; shift ; snam="$1" ;;
      -x)   oext=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    local name="${1,,}" kind file text sepa=$'\a' afld skey prev
    local -n _dict _mods
    if [ -z "$CEN_OPT_TOOLS" ] ; then
        _dict=DAT_BMK_NAMES ; _mods=DAT_REF_MODULES
    else
        _dict=DAT_BMK_TOOLS ; _mods=DAT_REF_TOOLS
    fi

    # add entry to bookmark dictionary
    if [ -n "$oadd" ] ; then
        kind="$2" file="${3##*/}" text="$4"

        if [ "$kind" = "F" ] ; then
            # extra entry for function with annotation
            if [ "${name/ (*)/}" != "$name" ] ; then
                skey="${name% (*}()"
                [ -z "${_dict["$skey"]}" ] &&
                    _dict["$skey"]="$file$sepa$name()$sepa$kind$sepa$text"
            fi

            # decorate key of function with ()
            _dict["$name()"]="$file$sepa$name$sepa$kind$sepa$text"
        fi
        [ -z "${name// /}" ] && warning "Empty reference: $DAT_INP_LINE"
        _dict["${name:--}"]="$file$sepa$name$sepa$kind$sepa$text"
        return 0
    elif [ -n "$oext" ] ; then
        _dict["$name"]="${2:-$1}"
        return 0
    fi

    # make prev/next dictionaries
    if [ -n "$omak" ] ; then
        if [ -z "$CEN_OPT_TOOLS" ] ; then
            DAT_BMK_NEXT=([index]="browse"   [browse]="module"   # forward refences
                          [module]="content" [content]="reference")
            DAT_BMK_PREV=([browse]="index"   [module]="browse"   # backward references
                          [content]="module" [reference]="content")
            prev="reference"
        else
            DAT_BMK_NEXT=() ; DAT_BMK_PREV=()
            prev="tools"
        fi
        for item in "${_mods[@]}" ; do
            item="${item%%$'\a'*}" ; item="${item##*/}"
            DAT_BMK_PREV["${item:--}"]="$prev"
            DAT_BMK_NEXT["${prev:--}"]="$item"
            prev="$item"
        done
        return 0
    fi

    if [ -n "$ochk" ] ; then
        text="${_dict["$name"]}"
        if [ -z "$text" ] ; then
            warning -a -p $"Link target '%s' not defined: %s" "$name" "$DAT_INP_LINE"
            return 1
        fi
        splitjoin -s afld -d "\a" "$text"
        file="${afld[0]}" ; name="${afld[1]}"

    elif [ "$onxt" = 1 ] ; then
        file="${DAT_BMK_NEXT["$name"]}" ; name=
    elif [ "$onxt" = 2 ] ; then
        file="${DAT_BMK_PREV["$name"]}" ; name=

    elif [ -n "$oref" ] ; then
        file="$2"
    fi

    # format refence and save it
    if [ "${snam:--}" != '-' ] ; then       # save result
        file="${file##*/}"                  # no path
        if [ -z "$name" ] ; then
            [ -n "$file" ] && href="$file.html"
        elif [ -z "$file" ] ; then
            href="#${name//[ ()]/}"
        elif [ "$file.html" = "${DAT_OUT_FILE##*/}" ] ; then
            href="#${name//[ ()]/}"
        else
            href="$file.html#${name//[ ()]/}"
        fi
        printf -v "$snam" "%s" "$href"
    fi
    [ -n "$href" ]                          # return status
}

# ------------------------------------------------------------------------------
# label part of a text line: <vlbl> <text>
# ------------------------------------------------------------------------------
labelsplit() {
    [ "${2/:/}" = "$2" ] && return 1                    # no colon
    local -n _vlbl="$1"
    _vlbl="${2%%:*}:"
    [ "${_vlbl//[$DAT_CHAR_LABEL]/}" = ':' ] && return 0  # valid label
    _vlbl= ; return 1                                   # not a label
}

# ------------------------------------------------------------------------------
# Split doc line: [-b] <var_text>|- <var_name|-> <var_kind>|- <var_nlin>|- <line>
# ------------------------------------------------------------------------------
linesplit() {
    #if true ; then
    if [ "$1" = '-b' ] ; then
        shift
        local _lnum="${5%%:*}" _tspl="${5#*:}"
        local _kspl="${_tspl::1}" ; _tspl="${_tspl:1}"
        if [ "$_kspl" != '-' ] ; then    # option -b
            error -m $"Expected a body entry:" "${DAT_INP_FILE}[${5%%:*}]:" "$5"
            return 1
        fi
    else
        local _lnum="${5%%:*}" _tspl="${5#*:}"
        local _kspl="${_tspl::1}" ; _tspl="${_tspl:1}"
    fi
    #else
    #if [ "$1" = '-b' ] ; then
    #    shift
    #    if ! [[ "$5" =~ ([0-9]*):(-)(.*) ]] ; then
    #        error -m $"Expected a body entry:" "$DAT_INP_FILE[${5%%:*}]:" "\n$5"
    #        return 1
    #    fi
    #elif ! [[ "$5" =~ ([0-9]*):([A-Z])(.*) ]] ; then
    #    error -m $"Invalid header entry:" "$DAT_INP_FILE[${5%%:*}]:" "\n$5"
    #    return 1
    #fi
    #local _lnum="${BASH_REMATCH[1]}" _kspl="${BASH_REMATCH[2]}" _tspl="${BASH_REMATCH[3]}"
    #fi

    [ "${2:--}" = '-' ] ||                              # want name ...
        { printf -v "$2" '%s' "${_tspl%%:*}" ; _tspl="${_tspl#*:}" ; }
    [ "${1:--}" = '-' ] || printf -v "$1" '%s' "$_tspl"
    [ "${3:--}" = '-' ] || printf -v "$3" '%s' "$_kspl"
    [ "${4:--}" = '-' ] && return 0

    DAT_INP_LINE="${DAT_INP_FILE}[$_lnum]"
    [ -n "$CEN_OPT_LINES" ] && printf -v $4 '%6s  ' "$_lnum"
    [ -n "$CEN_OPT_FILE"  ] && printf -v $4 '%12s:%6s  ' "$DAT_INP_FILE" "$_lnum"
    return 0
}

# ------------------------------------------------------------------------------
# print a article header, create HTML doc:
#
# Call:    article -t <mind> <mesg>                 # plain text header
#
#          article -b <file> [<mesg>]               # html document+header
#          article -h [<mesg> [<book>]]             # html header
#          article -n <curr>                        # html navigation
#          article -e <curr>                        # html footer+close doc
# ------------------------------------------------------------------------------
article() {
    local fbeg fend fnav mind="$1" file mesg book tool
    [ -z "$CEN_OPT_TOOLS" ] && tool='centauri-bash-lib' || tool='Centauri-Tools'
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   fbeg=1 ; shift ; file="$1" ;;
      -h)   fbeg=2 ; shift ; mesg="$1" ; book="$2" ;;
      -e)   fend=1 ;;
      -n)   fnav=1 ;;
      -t)   shift ; mind="$1" ; mesg="$2 - $tool" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # html article
    if [ "$fbeg" = 1 ] ; then
        local mhdr="$CEN_NAME ─ ${mesg// - / ─ }"
        if [ -z "$mesg" ] ; then
            file="${DAT_OUT_FILE##*/}" ; mhdr+="${file%.*}"
        fi
        xml_document $DAT_DOCO -b -s 'default.js' -c 'default.css' -t "$mhdr" \
                     -o "$DAT_OUT_FILE" -- "onload='initialize(\"${file%.*}\")'" || quit
        xml_element 'article#top' -b -n -i
        if [ -n "$mesg" ] ; then
            xml_element 'div#item-header' -b -t -- "$mesg - "
            xml_anchor -u 'index.html' "$tool"
            xml_element 'div' -e -n
        fi
        DAT_ART_CURR="$book"

    # new article in same document
    elif [ -n "$fbeg" ] ; then
        xml_element 'article' -e -u -n
        xml_element 'article' -b -i
        if [ -n "$mesg" ] ; then
            xml_element "div${book:+#}$book" -c "item-header" -t -- "$mesg"
        fi
    elif [ -n "$fend" ] ; then
        xml_element 'article' -e -n -u
        DAT_ART_CURR=1 ; article -n -- "$@" ; DAT_ART_CURR=
        xml_document -e
    elif [ -n "$fnav" ] ; then
        ___anchor() {
            local clas="$1" ; shift
            xml_element 'div' -c "$clas" -b
            [ -n "$2" ] && xml_anchor "$@"
            xml_element 'div' -e -n
        }
        [ -n "$DAT_ART_CURR" ] && xml_element 'div' -c "def-break" -n
        local npre nnxt
        if [ "$1" != '-' ] ; then                   # skip for /dev/stdout
            bookmark -p npre "$1" ; bookmark -n nnxt "$1"
        fi
        xml_element "nav" -b ; xml_element 'div' -c "nav-row" -b -n -i
            ___anchor "nav-left"  -u "$npre" "[<< previous]"
            if [ -z "$CEN_OPT_TOOLS" ] ; then
                if [ -n "$DAT_ART_CURR" ] ; then
                    ___anchor "nav-mid" -m "top" "[Top of Page]"
                else
                    ___anchor "nav-mid" -u "content.html#top" "[Content]"
                fi
                ___anchor "nav-mid"   -u "reference.html#top" "[Reference]"
            else
                if [ -n "$DAT_ART_CURR" ] ; then
                    ___anchor "nav-mid" -m "top" "[Top of Page]"
                else
                    ___anchor "nav-mid" -u "index.html#top" "[Library]"
                fi
                ___anchor "nav-mid" -u "tools.html#top" "[Tools]"
            fi
            ___anchor "nav-right" -u "$nnxt" "[next >>]"
        xml_element 'div' -e ; xml_element "nav" -e -n -u

    # plain text article
    else
        local mlen="${#mesg}"
        [ -n "$CEN_OPT_LINES" ] && ((mind += 8))
        [ -n "$CEN_OPT_FILE"  ] && ((mind += 19))

        output -l
        output -i "$mind" -l -d one  -x "$mlen" .
        output -i "$mind" -l -d bold -- "$mesg"
        output -i "$mind" -l -d one  -x "$mlen" .
        output -l
    fi
}

# ------------------------------------------------------------------------------
# table of content
# ------------------------------------------------------------------------------
content() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name
    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        M)    content_item_$DAT_FMT_TYPE "$nlin" - "$kind" "$name" "$text" ;;
        F|T)  documentation -t "$name" "${CEN_CMDARGS[@]}" || continue
              content_item_$DAT_FMT_TYPE "$nlin" - "$kind" "$name" "$text" ;;

        A)    content_head_$DAT_FMT_TYPE ;;
        B)    content_begin_$DAT_FMT_TYPE ;;
        E)    content_end_$DAT_FMT_TYPE ;;
        Z)    content_foot_$DAT_FMT_TYPE ;;

        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# ------------------------------------------------------------------------------
# table of content - plain
# ------------------------------------------------------------------------------
content_head_plain() {
    # print indented title
    article -t 23 "Table of Content"

    # print table header
    local mesg oind=36
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg -- " line# |"
    [ -n "$CEN_OPT_FILE"  ] && { ((oind += 19)) ; output -v mesg -x 19 -- "file name" ; }
    [ -n "$CEN_OPT_LINES" ] && { ((oind +=  8)) ; output -v mesg       -- " line# |" ; }
    DAT_OUT_OPTS="-b $oind:6 -p"

    output -v mesg -x 22 -- "item name"
    output -v mesg -x 13 -- "|kind"
    output -v mesg       -- "|description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"
    DAT_CNT_ITEM=0
}

content_foot_plain() {
    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "$DAT_CNT_ITEM" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two
}

content_begin_plain() {
    [ "$DAT_CNT_ITEM" != "0" ] && output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
}

content_end_plain() { : ; }

content_item_plain() {
    local nlin="$1" kind="$3" name="$4" text="$5" deco="ital"
    case "$kind" in
        M)    kind="Module"   ; deco="bold" ; ((++DAT_CNT_ITEM)) ;;
        F)    kind="Function" ;;
        *)    kind="Topic"    ;;
    esac
    tabulator : "${nlin% }" 22:$deco "$name" 12 "$kind" : "$text"
}

# ------------------------------------------------------------------------------
# table of content - html
# ------------------------------------------------------------------------------

# worker for index, recursive: [-w|-a] ...
content_work() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "index"
    if [ "$arg1" = '-w' ] ; then
        element -a "content_work -a" -f "content" -- "$@"   # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then

        ___rows() {
            local item afld kind html mark
            xml_text -v item -- "${DAT_TAB_ROWS[$2]}"
            splitjoin -s afld -d "\n" -- "$item"
            [ -z "$afld" ] && return 1

            case "${afld[1]}" in
                M)    kind="Module"   ; mark="${afld[2]}.html" ;;
                F)    kind="Function" ; bookmark -c mark "${afld[2]}()" ;;
                *)    kind="Topic"    ; bookmark -c mark "${afld[2]}" ;;
            esac

            xml_anchor -v item -u "$mark" -- "${afld[2]}"
            CEN_XML_ATTR[0]="class='${kind,,}'"
            CEN_XML_ARGS=("$item" "$kind" "${afld[3]}")
            return 0
        }

        article -h "List of documentation items grouped by module"
        xml_table -l -n -r ___rows
        DAT_TAB_ROWS=()
    fi
}

content_head_html() {
    DAT_TAB_ROWS=()
}

content_foot_html() {
    documentation "content_work -w" "$BASH_SOURCE"
}

content_begin_html() { : ; }
content_end_html() { : ; }

content_item_html() {
    local sepa=$'\n'
    DAT_TAB_ROWS+=("$2$sepa$3$sepa$4$sepa$5")
}

# ------------------------------------------------------------------------------
# callback for element listing
#
# Call:     element [-a <auto>] [-f <filter>] <file> <entry>...
# ------------------------------------------------------------------------------
element() {
    local line nlin text kind name head=0 auto filt
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   shift ; auto="$1" ; DAT_FLG_ECNT=0 ;;
      -f)   shift ; filt="$1" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    local curr ; DAT_INP_FILE="$1" ; shift

    # --- process header ---

    while [ $# -gt 0 ] ; do
        line="$1" ; shift
        linesplit text name kind nlin "$line" || return 1
        name="${name##*/}"                              # strip path

        case "$kind" in
        M|F|S|T)
              # filter element by name (see documentation -q)
              if [ -n "$filt" ] ; then
                  [ "${name,,}" = "${filt,,}" ] || continue
              # must handle kind filtering here, documentation -t cannot do this
              elif [ -n "$CEN_CMDARGS" ] && [ -z "${CEN_CMDARGS//[-+=]/}" ] ; then
                    local ksel curr="$CEN_CMDARGS"
                    [ "${curr//-/}" != "$curr" ] && ksel+='F'
                    [ "${curr//+/}" != "$curr" ] && ksel+='T'
                    [ "${curr//=/}" != "$curr" ] && ksel+='M'
                    [ "${ksel/$kind/}" = "$ksel" ] && continue
                    documentation -t "$name" "${CEN_CMDARGS[@]:1}" || continue
              elif ! documentation -t "$name" "${CEN_CMDARGS[@]}" ; then
                  continue
              fi
              # process this element ...
              DAT_INP_NAME="$name" ; ((++DAT_FLG_ECNT)) ; ((++head))
              element_item_$DAT_FMT_TYPE "$nlin" "$kind" "$name" "$text"
              ;;
        A)    DAT_FLG_EBEG= ; DAT_FLG_ECNT=0 ;;
        B)    [ "$name" = 1 ] && DAT_FLG_ECNT=0
              element_begin_$DAT_FMT_TYPE "$name" ;;
        E)    element_end_$DAT_FMT_TYPE ; DAT_INP_NAME= ;;
        Z)    ;;

        *)    fatal -t $"Unexpected doc item:" "$DAT_INP_LINE: $kind"

        esac
    done
    [ "$head" = 0 ] && return 0                         # no filter match
    element_item_$DAT_FMT_TYPE "$nlin" "$kind"          # flush header

    # --- process body ---

    local nrem=1

    # process text block: <ngrp> <indx> <entry>...
    ___block() {
        local texl ttmp next
        text="${CEN_DOC_BLOCK[$2]}"                     # get 1st text
        next=$(($2 + $# - 1))                           # start of next block
        DAT_INP_LINE="${DAT_INP_FILE}[$((CEN_DOC_BLOCK + $2))]"

        # text mode: separate groups by empty line
        [ "$1" -gt 0 -a "$DAT_FMT_MODE" != 2 ] && definition

        # handle <auto> callback
        case "$text" in
        *###autogenerated###*)
                [ -n "$auto" ] && $auto "$text" ; return ;;
        *###legal###*)
                text="${text/\###legal###/$CEN_LEGAL}"
                set -- "$1" "$2" "$text" ; CEN_DOC_BLOCK[$2]="$text" ;;
        esac
        shift 2

        # handle definition entry
        texl="${text#[$DAT_CHAR_MARKER]}"               # remove format marker
        if labelsplit ttmp "$texl" ; then               # get label (if any)
            nrem=
            definition -- "$ttmp" "$@"

        # continue a definition
        elif [ -z "$nrem" ] && [ "${texl::3}" = '   '  ] ; then
            definition '' "$@"

        # no definition, no continuation -> remarks entry
        else
            # nrem - 0: continuation   1: "Remark"   2: "Remarks"
            if [ -z "$nrem" ] ; then                    # 1 remark paragraph
                nrem=1
                texl="${CEN_DOC_BLOCK[next]}"
                texl="${texl#[$DAT_CHAR_MARKER]}"       # remove format marker
                labelsplit ttmp "$texl" || nrem=2       # test for label
            else
                nrem=0 ; [ "$DAT_FMT_MODE" = 2 ] && definition
            fi
            local labl
            if [ -n "$CEN_OPT_L10N" ] ; then
                [ "$nrem" = 1 ] && labl=$"Remark:"
                [ "$nrem" = 2 ] && labl=$"Remarks:"
            else
                [ "$nrem" = 1 ] && labl="Remark:"
                [ "$nrem" = 2 ] && labl="Remarks:"
            fi
            definition -b "$labl" "$@"
        fi
    }

    if [ -n "$DAT_INP_FAST" ] ; then
        documentation -b - ___block                     # get paragraphs
    else
        documentation -b + ___block                     # get paragraphs with deco
    fi
    [ "$DAT_FMT_MODE" != 2 ] && definition            # empty line
    [ -z "$filt" ]                                      # false if filter was set
    documentation -t                                    # return query status
}

# ------------------------------------------------------------------------------
# element listing - plain
# ------------------------------------------------------------------------------
element_begin_plain() { : ; }
element_end_plain() { : ; }

element_item_plain() {
    [ "$DAT_INP_FILE" = "/dev/stdin" ] && return    # no header for usage()
    local nlin="$1" kind="$2" name="$3" text="$4" head="${5:-1}" deco="one"
    case "$kind" in
        M)    kind="Module"   ; deco="two" ;;
        T)    kind="Topic"    ;;
        F)    kind="Function" ;;
        S)    kind="Script"   ;;
        *)    kind="Other"    ;;
    esac
    [ "$head" = 1 ] && output -l -x "$CEN_COLS" . -d "$deco"
    [ -n "$name" ] && tabulator : "${nlin% }" :bold "$kind - $name -" :bold "$text"
}

# ------------------------------------------------------------------------------
# element listing - html
# ------------------------------------------------------------------------------
element_begin_html() {
    if [ "$1" = 1 ] ; then
        article -b "$DAT_INP_FILE"
        local book="${DAT_OUT_FILE##*/}"
        article -n -- "${book%.html}"
    fi
    [ -n "$DAT_FLG_EBEG" ] && xml_element "section" -e -n -u
    DAT_FLG_EBEG=
}

element_end_html() {
    [ -n "$DAT_FLG_EBEG" ] && xml_element "section" -e -n -u
    DAT_FLG_EBEG=
    # get bookmark from output for index, content etc
    local book="${DAT_OUT_FILE##*/}"
    article -e -- "${book%.html}"
}

element_item_html() {
    local kind="$2" name="$3" text="$4" book
    if [ -z "$DAT_FLG_EBEG" ] ; then
        xml_element "section#section-$DAT_FLG_ECNT" -b -n -i
        DAT_FLG_EBEG=1
    fi

    case "$kind" in
        M)    kind="Module"   ;;
        T)    kind="Topic"    ;;
        F)    kind="Function" ;;
        S)    kind="Script"   ;;
        *)    kind="Other"    ;;
    esac

    if [ -n "$name" ] ; then
        bookmark -r book "$name"
        xml_element "div$book" -b -n -i -c "item-${kind,,}"
        xml_text -v text -- "$text"

       # book="<a href=\"index.html\">Centauri Bash Library</a>"
       # text="${text/Centauri Bash Library/$book}"

        book="<a href=\"index.html\">centauri-bash-lib</a>"
        text="${text/centauri-bash-lib/$book}"
        name="${name/centauri-bash-lib/$book}"
        xml_element "span" -- "$kind" " - " "$name" " - " "$text"
        xml_element 'div' -e -n -u
    fi
    xml_flush
}

# ------------------------------------------------------------------------------
# html browse page
# ------------------------------------------------------------------------------
browse() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name
    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        A)    documentation "browse_work -w" "$BASH_SOURCE" ; return 1 ;;
        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

browse_work() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "index"
    if [ "$arg1" = '-w' ] ; then
        element -f "browse" -- "$@"   # return status
    fi
}

# ------------------------------------------------------------------------------
# html index page
# ------------------------------------------------------------------------------
index() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name
    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        A)    documentation "index_work -w" "$BASH_SOURCE" ; return 1 ;;
        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# worker for index, recursive: [-w|-a] ...
index_work() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "index"
    if [ "$arg1" = '-w' ] ; then
        element -a "index_work -a" -f "index" -- "$@"   # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        DAT_TAB_ROWS=("Modules")
        documentation -l -m -s "index_work"
        DAT_TAB_ROWS=()

    # level 2: callback for autogenerated doc entries
    else
        local text kind name
        linesplit text name kind - "$1"
        [ "$kind" = "M" ] || return 0
        printf -v name "%-24s " "[[$name]]"
        definition -o "$DAT_TAB_ROWS" "$name$text"
        DAT_TAB_ROWS=()
    fi
}

# ------------------------------------------------------------------------------
# list of modules
# ------------------------------------------------------------------------------
module() {
    DAT_INP_FILE="${1##*/}" ; shift
    local line nlin text kind name desc
    for line in "$@" ; do
        linesplit text - kind nlin "$line"
        name="${text%%:*}" ; desc="${text#*:}"

        case "$kind" in
        A)    DAT_MOD_VERS="unknown" ; DAT_REF_TOOLS=()
              DAT_MOD_MAINT= ; module_head_$DAT_FMT_TYPE ;;
        M|S)  if [ -z "$DAT_MOD_MAINT" -a "${name::1}" = '/' ] ; then
                  DAT_MOD_MAINT=1 ; module_maint_$DAT_FMT_TYPE
              fi
              module_item_$DAT_FMT_TYPE "$nlin" "$DAT_MOD_VERS" "$name" "$desc"
              [ "$kind" = "S" ] && DAT_REF_TOOLS+=("$name$nlin") ;;
        V)    DAT_MOD_VERS="$text" ;;
        Z)    if [ -n "$CEN_OPT_TOOLS" ] ; then
                  if [ "$CEN_OPT_MODULES" != 1 ] ; then
                      bookmark -m                   # create prev/next dictionaries
                      [ -z "$CEN_OPT_USE" ] && serialize -w $DAT_SERIALIZE
                      [ "$CEN_OPT_MODULES" = 2 ] && return 0
                  fi
              fi
              module_foot_$DAT_FMT_TYPE
              ;;
        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

# ------------------------------------------------------------------------------
# list of modules - plain
# ------------------------------------------------------------------------------
module_head_plain() {
    local mesg name

    # print indented title
    if [ -z "$CEN_OPT_TOOLS" ] ; then
        article -t 23 "List of Modules" ; name="module name"
    else
        article -t 23 "List of Applications" ; name="application name"
    fi

    # print table header
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg -- " line# |"
    output -v mesg -x 22 -- "$name"
    output -v mesg -x 13 -- "|version"
    output -v mesg       -- "|description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

}

module_foot_plain() {
    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "$DAT_CNT_ITEM" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two ; output -l
}

module_maint_plain() {
    output -l -x "$CEN_COLS" . -d one
}

module_item_plain() {
    local nlin="$1" vers="$2" name="${3##*/}" text="$4"
    ((++DAT_CNT_ITEM))
    tabulator : "${nlin% }" 22:bold "$name" 12 "$vers" : "$text"
}

# ------------------------------------------------------------------------------
# list of modules - html
# ------------------------------------------------------------------------------

# worker for index, recursive: [-w|-a] ...
module_work() {
    local _styp arg1="$1" ; shift
    [ -z "$CEN_OPT_TOOLS" ] && _styp="modules" || _styp="tools"

    # level 0: generate doc element for "index" or "tools"
    if [ "$arg1" = '-w' ] ; then
        element -a "module_work -a" -f "$_styp" -- "$@"     # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        ___rows() {
            if [ "${DAT_TAB_ROWS[$2]}" = '-' ] ; then
                xml_text -l -n "</table><div class='item-header'>Library maintenance</div><table>"
                return 0
            fi
            splitjoin -s CEN_XML_ARGS -d "\n" "${DAT_TAB_ROWS[$2]}"
            [ -n "$CEN_XML_ARGS" ]
        }

        article -h $"List of ""${_styp^}"$" and Versions"
        xml_table -l -r ___rows
        DAT_TAB_ROWS=()
    fi
}

module_head_html() {
    DAT_TAB_ROWS=()
}

module_foot_html() {
    documentation -s "module_work -w" "$BASH_SOURCE"
}

module_maint_html() {
    DAT_TAB_ROWS+=('-')
}

module_item_html() {
    local vers="$2" name="${3##*/}" text="$4" sepa=$'\n'
    ((++DAT_CNT_ITEM))
    DAT_TAB_ROWS+=("<a href=\"$name.html\">$name</a>${sepa}$vers${sepa}$text")
}

# ------------------------------------------------------------------------------
# reference tables
# ------------------------------------------------------------------------------
reference() {
    DAT_INP_FILE="$1" ; shift
    local line nlin text kind name what

    for line in "$@" ; do
        linesplit text name kind nlin "$line"

        case "$kind" in
        M|F|T)
              bookmark -a "$name" "$kind" "$DAT_INP_FILE" "$text"
              reference_item "$nlin" "$kind" "$name" "$text" ;;
        A)    for what in "modules" "topics" "functions" ; do
                  bookmark -a "$what" "T" "reference" "Reference Table - $what"
              done
              reference_head ;;
        B|E)  ;;
        Z)    reference_foot ;;

        *)    fatal -t $"Unexpected header entry:" "$DAT_INP_LINE: $kind"
        esac
    done
    return 0
}

reference_head() {
    DAT_REF_FUNCTIONS=() ; DAT_REF_MODULES=() ; DAT_REF_TOPICS=()
}

reference_foot() {
    if [ "$CEN_OPT_REFERENCE" != 1 ] ; then
        extsort -a DAT_REF_MODULES -- "${DAT_REF_MODULES[@]}"
        extsort -a DAT_REF_FUNCTIONS -- "${DAT_REF_FUNCTIONS[@]}"
        [ -z "$CEN_OPT_USE" ] && serialize -w $DAT_SERIALIZE
        [ "$CEN_OPT_REFERENCE" = 2 ] && return
    fi
    documentation "reference_work_$DAT_FMT_TYPE -w" "$BASH_SOURCE"
}

reference_item() {
    local nlin="$1" kind="$2" name="$3" text="$4" sepa=$'\a'
    case "$kind" in
        M)  DAT_REF_MODULES+=("$name$sepa$nlin$sepa$text") ;;
        F)  documentation -t "$name" "${CEN_CMDARGS[@]}" &&
                DAT_REF_FUNCTIONS+=("$name$sepa$nlin$sepa$DAT_INP_FILE$sepa$text") ;;
        *)  documentation -t "$name" "${CEN_CMDARGS[@]}" &&
                DAT_REF_TOPICS+=("$name$sepa$nlin$sepa$DAT_INP_FILE$sepa$text") ;;
    esac
}

# ------------------------------------------------------------------------------
# references tables - plain worker, recursive: [-w|-a] ...
# ------------------------------------------------------------------------------
reference_work_plain() {
    local arg1="$1" kind="${3#*:}" oind=45 mesg item afld=()
    [ "$arg1" = '-w' ] || return
    [ "${kind::1}" = "E" ] || return
    DAT_OUT_OPTS="-b $oind:6 -p"

    # --- Topics ---

    if [ -n "$DAT_REF_TOPICS" ] ; then
        article -t 24 "Reference Table - Topics"
        [ -n "$CEN_OPT_FILE"  ] && { ((oind += 19)) ; output -v mesg -x 19 -- "file name" ; }
        [ -n "$CEN_OPT_LINES" ] && { ((oind +=  8)) ; output -v mesg       -- " line# |" ; }
        output -v mesg -x 23 -- "Topic Name"
        output -v mesg -x 21 -- "|Module"
        output -v mesg       -- "|Description"
        output -l -- "${mesg//|/ }"
        mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
        output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

        for item in "${DAT_REF_TOPICS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            tabulator : "${afld[1]% }" 23:ital "${afld[0]}" 20:bold "${afld[2]}" : "${afld[3]}"
        done

        if [ -n "$CEN_OPT_LINES" ] ; then
            output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
            [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
            output -p "%6s  %s\n" "${#DAT_REF_TOPICS[@]}" "[topics]"
        fi
        output -l -x "$CEN_COLS" . -d two
    fi

    # --- Modules ---

    article -t 22 "Reference Table - Modules"
    mesg=
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg       -- " line# |"
    output -v mesg -x 21 -- "Module"
    output -v mesg       -- "|Description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

    for item in "${DAT_REF_MODULES[@]}" ; do
        splitjoin -s afld -d "\a" -- "$item"
        tabulator : "${afld[1]% }" 21:bold "${afld[0]}" : "${afld[2]}"
    done

    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "${#DAT_REF_MODULES[@]}" "[modules]"
    fi
    output -l -x "$CEN_COLS" . -d two

    # --- Functions ---

    article -t 24 "Reference Table - Functions"
    mesg=
    [ -n "$CEN_OPT_FILE"  ] && output -v mesg -x 19 -- "file name"
    [ -n "$CEN_OPT_LINES" ] && output -v mesg       -- " line# |"
    output -v mesg -x 23 -- "Item Name"
    output -v mesg -x 21 -- "|Module"
    output -v mesg       -- "|Description"
    output -l -- "${mesg//|/ }"
    mesg="${mesg//[!|]/.}" ; DAT_SEP_ITEM="${mesg//|/ }"
    output -l -x "$CEN_COLS" . -d two -- "$DAT_SEP_ITEM"

    for item in "${DAT_REF_FUNCTIONS[@]}" ; do
        splitjoin -s afld -d "\a" -- "$item"
        tabulator : "${afld[1]% }" 23:ital "${afld[0]}" 20:bold "${afld[2]}" : "${afld[3]}"
    done

    if [ -n "$CEN_OPT_LINES" ] ; then
        output -l -x "$CEN_COLS" . -d one -- "$DAT_SEP_ITEM"
        [ -n "$CEN_OPT_FILE" ] && output -x 19 -- "$DAT_CNT_FILE  [files]"
        output -p "%6s  %s\n" "${#DAT_REF_FUNCTIONS[@]}" "[functions]"
    fi
    output -l -x "$CEN_COLS" . -d two
}

# ------------------------------------------------------------------------------
# references tables - html worker, recursive: [-w|-a] ...
# ------------------------------------------------------------------------------
reference_work_html() {
    local arg1="$1" ; shift

    # level 0: generate doc element for "refence"
    if [ "$arg1" = '-w' ] ; then
        bookmark -m                         # create prev/next dictionaries
        element -a "reference_work_html -a" -f "reference" -- "$@"  # return status

    # level 1: callback for '###autogenerated###' tag
    elif [ "$arg1" = "-a" ] ; then
        local item afld=() name file text book sepa=$'\n'
        ___rows() {
            local afld
            splitjoin -s afld -d "\n" "${DAT_TAB_ROWS[$2]}"
            [ -z "$afld" ] && return 1
            xml_element "tr" -b -i
                xml_element "td" -c "$1" -- "${afld[0]}"
                xml_element "td" -- "${afld[1]}"
                [ -n "${afld[2]}" ] && xml_element "td" -- "${afld[2]}"
            xml_element "tr" -e -u -n
            CEN_XML_ARGS=()
            return 0
        }

        # --- Topics ---

        article -h "Reference Table - Topics" "topics"

        for item in "${DAT_REF_TOPICS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line file text
            bookmark -r book "${afld[0]}" "${afld[2]}"
            xml_text -v name -- "${afld[0]}"
            xml_text -v file -- "${afld[2]}"
            xml_text -v text -- "${afld[3]}"
            DAT_TAB_ROWS+=("<a href=\"$book\">$name</a>${sepa}$file${sepa}$text")
        done
        xml_table -t "topic" -l -r ___rows

        # --- Modules ---

        article -h "Reference Table - Modules" "modules"

        DAT_TAB_ROWS=()
        for item in "${DAT_REF_MODULES[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line text
            xml_text -v name -- "${afld[0]}"
            xml_text -v text -- "${afld[2]}"
            DAT_TAB_ROWS+=("<a href=\"${afld[0]}.html\">$name</a>${sepa}$text")
        done
        xml_table -t "module" -l -r ___rows

        # --- Functions ---

        article -h "Reference Table - Functions" "functions"

        DAT_TAB_ROWS=()
        for item in "${DAT_REF_FUNCTIONS[@]}" ; do
            splitjoin -s afld -d "\a" -- "$item"
            # name line file text
            bookmark -r book "${afld[0]}" "${afld[2]}"
            xml_text -v name -- "${afld[0]}"
            xml_text -v file -- "${afld[2]}"
            xml_text -v text -- "${afld[3]}"
            DAT_TAB_ROWS+=("<a href=\"$book\">$name</a>${sepa}$file${sepa}$text")
        done
        xml_table -t "function" -l -r ___rows
        DAT_TAB_ROWS=()
    fi
}

# ------------------------------------------------------------------------------
# run helper: run html viewer and quit                               (no return)
# ------------------------------------------------------------------------------
run_browse() {
    local elem="${CEN_OPT_HTML:-$CEN_ROOT/html}"
    local item cfil
    [ -n "$CEN_OPT_CONTENT" ]   && item='content'
    [ -n "$CEN_OPT_MODULES" ]   && item='module'
    [ -n "$CEN_OPT_REFERENCE" ] && item='reference'

    if [ "$#" = 1 -a "$1" = '-' ] ; then
        [ -z "$CEN_OPT_TOOLS" ] && item='index' || item='tools'
    elif [ "$#" = 0 ] ; then
        if [ -z "$item" ] && windows -i 1 ; then
            confirm -u -p - $"Enter search a string or leave empty to show index:"
            case $? in
            1)  [ -z "$CEN_OPT_TOOLS" ] && item='index' || item='tools' ;;
            2)  quit ;;
            *)  set -f ; set -- $CEN_CONFIRM ; set +f
            esac
        else
            [ -n "$CEN_OPT_TOOLS" ] && item='tools'
            [ -z "$item" ] && item='index'
        fi
    elif [ -n "$item" ] ; then
        fatal $"No argument expected:" "$*"
    fi || :
    if [ -z "$item" ] ; then
        [ -n "$CEN_OPT_TOOLS" ] && cfil='tools' || cfil='library'
        cfil="$elem/$CEN_NAME.$cfil.cache"
        [ -s "$cfil" ] || fatal -p $"Cannot load cache: %s\nPlease run '%s'" \
                                "$cfil" "$CEN_NAME --generate=all"
        documentation -s -e "$cfil" || fatal $"Failed to init cache:" "$cfil"
        documentation -f -q -- "$@"
        windows -f -i 1
        local text mdat=() info name kind file deli=$'\a'
        for item in "${CEN_DOC_FILTER[@]}" ; do
            file="${item%%:*}" ; item="${item#*:}"
            linesplit info name kind - "$item"
            mdat+=("$kind$deli${name,,}$deli$info$deli$file")
        done
        if [ "${#mdat[@]}" = 0 ] ; then
            error $"No documentation item found:" "$@" ; quit
        fi

        # uses: item mdat item
        ___mkurl() {
            splitjoin -s mdat -d "$deli" -- "$1"
            if [ ${mdat[0]} = 'M' ] ; then
                item="${mdat[3]}"
            else
                item="${mdat[1]//[ ()]/}"
                item="${mdat[3]}.html#${item,,}"
            fi
        }

        if [ "${#mdat[@]}" = 1 ] ; then
            ___mkurl "${mdat[0]}"
        else
            txtsort -a mdat -i mdat
            for item in "${mdat[@]}" ; do
                ___mkurl "$item"
                case "$mdat" in
                F)  mlis+=("$item:"$"Function"": ${mdat[1]} - ${mdat[2]}") ;;
                M)  mlis+=("$item:"$"Module"": ${mdat[1]} - ${mdat[2]}") ;;
                T)  mlis+=("$item:"$"Topic"": ${mdat[1]} - ${mdat[2]}") ;;
                S)  mlis+=("$item:${mdat[1]} - ${mdat[2]}")
                esac
            done
            while : ; do
                printf -v text "<b>%-90s" $"Multiple search results, please select one ..."
                windialog -s item -- "${text// /\&nbsp;}" 1 "${mlis[@]}" || quit
                embed -v centaurilauncher --mode=0 viewer "$elem/$item"
            done
        fi
    fi || :
    suffixpath -d -s item 'html' "$item"
    embed -x -v centaurilauncher --mode=2 viewer "$elem/index.html" "$elem/$item"
    quit
}

# ------------------------------------------------------------------------------
# run helper: delete or generate cache: -i|-x
# ------------------------------------------------------------------------------
run_cache() {

if [ -n "$CEN_OPT_USE" ] ; then
    return 1
fi
    if [ "$1" = '-i' ] ; then
        [ -z "$CEN_OPT_TOOLS" ] && DAT_HDR_CACHE="$CEN_NAME.library.cache" \
                                || DAT_HDR_CACHE="$CEN_NAME.tools.cache"
        if [ -z "$CEN_OPT_DELETE" ] ; then
            serialize                               # get file name only
            [ "$CEN_LIBRARY/_centauri_bash_lib" -nt "$CEN_SERIALIZE" ] && CEN_OPT_DELETE=1
        fi
        if [ -n "$CEN_OPT_DELETE" ] ; then
            message -a $"Cached data will be renewed"
            # default cache: .dat - update in module_foot and reference_foot
            serialize -s -d
            # flags for api change - see documentation() and CEN_DOC_APICHANGE
            serialize -s -d -n "$CEN_NAME.stat"
            # header caches - completely managed by documentation()
            documentation -s -d "$CEN_NAME.library.cache"
            documentation -s -d "$CEN_NAME.tools.cache"
        else
            serialize -s -r -q                          # load default cache
            local bmrk=$((${#DAT_BMK_NAMES[@]} + ${#DAT_BMK_TOOLS[@]}))
            trace -a -c -p $"index bookmarks" $"%s modules, %s tools, %s bookmarks" \
                  "${#DAT_REF_MODULES[@]}" "${#DAT_REF_TOOLS[@]}" "$bmrk"
        fi

    else
        local fail xtra apic
        [ -n "$CEN_OPT_TOOLS" ] && xtra='-p usageparser'

        # try to load existing header cache data
        if [ -z "$CEN_OPT_DELETE" ] ; then
            documentation -s -e "$DAT_HDR_CACHE" $xtra || fail=1
        fi

        # (re)create header cache
        if [ -z "$CEN_DOC_CLIST" -a -z "$fail" ] ; then
            run_files                                   # get file list
            trace -a -p $"Creating index data (%s items)" "${#DAT_LST_FILE[@]}"
            documentation -s -f -- "${DAT_LST_FILE[@]}" # register files for indexing
            documentation -s -e "$DAT_HDR_CACHE" $xtra || fail=1
        fi
        [ -n "$fail" ] && fatal $"Failed to init cache:" "$DAT_HDR_CACHE"
        trace -a -c -p $"index cache" $"%s header entries" "${#CEN_DOC_CLIST[@]}"

        # handle api change detected by document functions (lib files only)
        if [ -z "$CEN_OPT_TOOLS" ] ; then
            if [ "${CEN_DOC_APICHANGE:-0}" -gt 1 ] ; then
                apic="$CEN_DOC_MD5SUM"
                trace -a -p $"Must update html index files (stat %s)" "$CEN_DOC_APICHANGE"
            fi

            if [ -d "$CEN_OPT_HTML" ] ; then            # creating lib html output ...
                if [ -n "$apic" ] ; then                # save CEN_DOC_APICHANGE
                    CEN_OPT_DELETE=2
                    serialize -w -n "$CEN_NAME.stat" CEN_DOC_MD5SUM
                else
                    apic="$CEN_DOC_MD5SUM" ; CEN_DOC_MD5SUM=0
                    serialize -q -r -n "$CEN_NAME.stat"
                    if [ "$apic" != "$CEN_DOC_MD5SUM" ] ; then
                        trace -a $"Updating api md5sum, must update html index files"
                        CEN_OPT_DELETE=2
                        CEN_DOC_MD5SUM="$apic"
                        serialize -w -n "$CEN_NAME.stat" CEN_DOC_MD5SUM
                    fi
                fi
            fi
        fi
    fi
    return 0
}

# ------------------------------------------------------------------------------
# run helper: create file list              (sets DAT_LST_FILE and DAT_CNT_FILE)
# ------------------------------------------------------------------------------
run_files() {
    if [ -n "$CEN_OPT_USE" ] ; then             # --use option
        DAT_LST_FILE=("$CEN_OPT_USE")
        DAT_CNT_FILE=1 ; return 0
    fi

    local item
    DAT_LST_FILE=() ; DAT_CNT_FILE=0
    if [ -n "$CEN_OPT_TOOLS" ] ; then           # --tools option
        DAT_LST_FILE=(centauri*)
        # add utilities that are part of the library
        for item in "${DAT_UTILS[@]}" ; do
            [ -e "$CEN_ROOT/$item" ] && DAT_LST_FILE+=("$CEN_ROOT/$item")
        done
    else                                        # library files
        for item in _centauri_bash_??? _*_*_usr ; do
            [ -e "$item" ] && DAT_LST_FILE+=("$item")
        done
    fi

    DAT_CNT_FILE="${#DAT_LST_FILE[@]}"
    [ "$DAT_CNT_FILE" -gt 0 ] && return 0
    message $"No input module found" ; return 1
}

# ------------------------------------------------------------------------------
# run helper: make html and quit                                     (no return)
# ------------------------------------------------------------------------------
run_generate() {
    # helper to create a redirect file: <dest> <file>
    ___redirect() {
        [ -z "$1" ] && { xml_element meta -n -a "$___redirect_meta" ; return ; }
        [ -h "$2" ] && remove -f "$2"
        local ___redirect_meta="http-equiv='refresh' content='0; url=file://$1'"
        xml_document $DAT_DOCO -t $"Redirection" -o "$2" -h ___redirect
    }
    ___dummytxt() {
        local mesg ; splitjoin -d "\n" -j mesg \
            $"To generate Html documentation please type (as a user with sufficient rights):" \
            "" "    $CEN_NAME --delete --generate=all" "" \
            $"If you want only centauritools or centauri-bash-lib documentation, replace" \
            $"the option value 'all' by 'tools' or 'library'."
        xml_document $DAT_DOCO -t $"Generating Html Documentation" -o "$2" -b
        xml_element pre -- "$mesg" ; xml_document -e
    }

    local copt="${CEN_OPT_GENERATE::1}" dopt fopt
    local item="${CEN_OPT_HTML:-$CEN_ROOT/html}"
    [ -n "$CEN_OPT_DELETE" ] && dopt='-D'
    [ -n "$CEN_OPT_FORCE" ] && fopt='-f'
    confirm -a $"Generate Html documentation at:" "$item" || quit
    folder -f -m -- "$item"

    # 'lib' depends on --delete, must be generated 1st
    CEN_AUTOIND=1
    if [ "$copt" = 'a' -o "$copt" = 'l' ] ; then
        embed    -t -v -y -- "$BASH_SOURCE" -R -H "$item" $dopt $fopt - # for bookmarks
        embed -i -t -v -y -- "$BASH_SOURCE" -A -H "$item" $fopt
    fi
    if [ "$copt" = 'a' -o "$copt" = 't' ] ; then
        embed    -t -v -y -- "$BASH_SOURCE" -T -H "$item" $fopt -       # for bookmarks
        embed -i -t -v -y -- "$BASH_SOURCE" -T -H "$item" $fopt
    fi
    error -t || quit

    if [ "$copt" = 'd' ] ; then
        ___dummytxt - "$CEN_LIBRARY/README.html"
        ___dummytxt - "$CEN_TOOLS/README.html"
        ___dummytxt - "$item/index.html"
        ___dummytxt - "$item/tools.html"
    else
        ___redirect "$item/tools.html" "$CEN_TOOLS/README.html"
        ___redirect "$item/index.html" "$CEN_LIBRARY/README.html"
    fi
    quit $"Done."
}

# ------------------------------------------------------------------------------
# run helper: read input files, call parser: -i|-m|-c|-r|-e
# ------------------------------------------------------------------------------
run_process() {
    local popt="$1" ; shift
    local file dopt work last name

    case "$popt" in
        -b)     dopt=' '  ; work='browse' ;;    # dopt must be emtpy
        -c)     dopt='-c' ; work='content' ;;
        -e)                 work='element' ;;
        -i)     dopt='-m' ; work='index' ;;
        -m)     dopt='-m' ; work='module' ; [ -n "$CEN_OPT_TOOLS" ] &&  name='tools' ;;
        -r)     dopt='-c' ; work='reference' ;;
    esac
    [ -z "$work" ] && _cen_abort - "$*"

    # file callback: <count> <file>
    ___file() {
        filter -- "$2" || return 1              # -i/-x options
        [ -z "$CEN_OPT_HTML" ] && return 0      # ok, generate text output
        if [ ! -d "$CEN_OPT_HTML" ] ; then
            DAT_OUT_FILE='-' ; return 0
        fi

        local html file="$2"
        [ "$popt" = '-e' ] && html="${file##*/}.html" || html="${name:-$work}.html"
        DAT_OUT_FILE="$CEN_OPT_HTML/$html"

        if [ "$popt" = '-e' ] ; then
#            if [ "$file" -nt "$DAT_OUT_FILE" -o "$BASH_SOURCE" -nt "$DAT_OUT_FILE" ] ; then
            if [ -n "$CEN_OPT_FORCE" -o "$file" -nt "$DAT_OUT_FILE" ] ; then
                message -a -c $"Generating" -- "$html"
            else
                trace -a -c $"Current" -- "$html" ; return 1
            fi
        elif [ -n "$dopt" -a "$last" != "$DAT_OUT_FILE" ] ; then
            [ "$CEN_OPT_MODULES" = 2 -a "$html" = 'tools.html' ] && html=$"tools (index)"
            [ "$CEN_OPT_REFERENCE" = 2 -a "$html" = 'reference.html' ] && html=$"reference (index)"
            message -a -c $"Generating" -- "$html"
            last="$DAT_OUT_FILE"
        fi

        return 0
    }

    [ -n "$CEN_OPT_TOOLS" ] && dopt+=' -p usageparser'
    documentation -s -l $dopt "$work" ___file || return 1   # run list

    if [ "$popt" = '-m' ] && [ -d "$CEN_OPT_HTML" ] ; then  # copy header cache
        serialize -n "$DAT_HDR_CACHE"
        html="$CEN_OPT_HTML/${DAT_HDR_CACHE##*/}"
        if [ -n "$CEN_OPT_FORCE" -o "$CEN_SERIALIZE" -nt "$html" ] ; then
            copy -- "$CEN_SERIALIZE" "$html" || return 1
        fi
    fi
    return 0
}

# ------------------------------------------------------------------------------
# The one and only action
# ------------------------------------------------------------------------------
run() {
    local copt item elem

    [ -n "$CEN_OPT_BROWSE" ] && run_browse "$@" # run html viewer, no return
    [ -n "$CEN_OPT_GENERATE" ] && run_generate  # make html and quit, no return

    # option dependencies
    [ -n "$CEN_OPT_LIBRARY" -a $# = 0 -a "${#CEN_OPT_INCLEXCL[@]}" = 0 ] && CEN_OPT_REFERENCE=1
    [ -n "$CEN_OPT_TOOLS" -a $# = 0 ] && CEN_OPT_MODULES=1
    [ -z "$CEN_OPT_CONTENT$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_REFERENCE" ] && elem=1
    [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES"  ] && copt='-c -m'
    [ -n "$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] && copt='-c'

#serialize() { fatal -t serialize ; }
    # special case: --tools <pipe>
    if [ "$1" = '<pipe>' -a -n "$CEN_OPT_TOOLS" ] ; then
        syspager documentation -p usageparser element '/dev/stdin'
        return
    fi

    if [ $# = 0 ] && [ "${#CEN_OPT_INCLEXCL[@]}" = 0 ] && [ -z "$CEN_OPT_USE" ] &&
                     [ -n "$elem" -a -z "$CEN_OPT_HTML" -a -z "$CEN_OPT_ALL" ] ; then
        [ -n "$CEN_OPT_DELETE" ] && quit
        embed -m '_centauri_bash_use' -u        # show usage and quit
    fi

    run_cache -i                                # init/delete cache data

    # alias references to index.html and tools.html and known tools
    splitjoin -x 'eval bookmark -x' -i DAT_BOOKMARK

    # init html output
    if [ -n "$CEN_OPT_HTML" ] ; then
        DAT_FMT_TYPE=html ; elem=1
        includes                                    # create js and css
        [ -z "$CEN_OPT_REFERENCE" ] && bookmark -m  # create prev/next dictionaries

    # init plain text output
    else
        console -m 3 -c 0 || :
        local cols=94                           # output width
        [ -n "$CEN_OPT_LINES" ] && ((cols += 8))
        [ -n "$CEN_OPT_FILE"  ] && ((cols += 19))
        [ "${CEN_COLS:-0}" = 0 -o "${CEN_COLS:-0}" -gt "$cols" ] && CEN_COLS="$cols"
    fi

    # special case: single '-'
    if [ $# = 1 ] && [ "$1" = '-' ] ; then      # index only
            elem= ; set --
    fi

    # set source folder, set options for html
    if [ -n "$CEN_OPT_TOOLS" ] ; then           # --tools option
        folder -f -c "$CEN_TOOLS"
    else                                        # library files
        folder -f -c "$CEN_LIBRARY"
        if [ -n "$CEN_OPT_ALL" ] ; then
            if [ -n "$CEN_OPT_HTML" ] ; then
                if [ -n "$CEN_OPT_FORCE" -o -n "$CEN_OPT_DELETE" ] ; then
                    CEN_OPT_INDEX=1 ; CEN_OPT_MODULES=1 ; CEN_OPT_CONTENT=1; CEN_OPT_REFERENCE=1
                else
                    [ -e "$CEN_OPT_HTML/index.html"     ] || CEN_OPT_INDEX=1
                    [ -e "$CEN_OPT_HTML/module.html"    ] || CEN_OPT_MODULES=1
                    [ -e "$CEN_OPT_HTML/content.html"   ] || CEN_OPT_CONTENT=1
                    [ -e "$CEN_OPT_HTML/reference.html" ] || CEN_OPT_REFERENCE=1
                fi
            else
                CEN_OPT_MODULES=1 ; CEN_OPT_CONTENT=1; CEN_OPT_REFERENCE=1
            fi
        fi
    fi

    # generate bookmark cache data, suppress output generation
    if [ -n "$CEN_OPT_TOOLS" ] ; then       # module() writes cache data
         if [ -z "$DAT_REF_TOOLS" -o -n "$CEN_OPT_DELETE" ] ; then
            [ -z "$CEN_OPT_MODULES" ] && CEN_OPT_MODULES=2 || CEN_OPT_MODULES=3
         fi
    else                                    # refence() writes ...
         if [ -z "$DAT_REF_MODULES" -o -n "$CEN_OPT_DELETE" ] ; then
            [ -z "$CEN_OPT_REFERENCE" ] && CEN_OPT_REFERENCE=2 || CEN_OPT_REFERENCE=3
         fi
    fi

    # search elements in cache and output
    if [ -z "$CEN_OPT_HTML" -a $# -gt 0 ] &&
       [ -z "$CEN_OPT_MODULES$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] ; then
        if run_cache -x ; then                  # can use cache ...
            documentation -q -- "$@" || :
            [ -z "$CEN_DOC_FILTER" ] && quit $"No documentation item found:" "$@"
            # set file list and process
            documentation -f -- "${CEN_DOC_FILTER[@]}" || :
            syspager run_process -e ; quit
        fi
    fi

    # --- generate output ---

    run_files || return
    trace -a -p $"Processing %s module(s)" "$DAT_CNT_FILE"


    # helper for paging output, loop over files
    ___docs() {
        documentation -s -f $copt -- "${DAT_LST_FILE[@]}" ||    # set file list
            return
        if [ -n "$CEN_OPT_TOOLS" ] ; then
            DAT_BMK_NEXT[tools]="${DAT_LST_FILE##*/}"           # for fwd link of tools.htnl
            [ -n "$CEN_OPT_MODULES" -o $# -gt 0 ] && run_cache -x
        elif [ -n "$CEN_OPT_ALL" ] ||
             [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] ; then
            run_cache -x
            # must rebuild all html index files after api change
            if [ "$CEN_OPT_DELETE" = 2 ] ; then
                CEN_OPT_INDEX=1 ; CEN_OPT_MODULES=1; CEN_OPT_CONTENT=1
                CEN_OPT_REFERENCE=3
            fi
        fi

        [ -n "$CEN_OPT_REFERENCE" ] && run_process -r   # must be 1st
        [ -n "$CEN_OPT_INDEX"     ] && { run_process -b ; run_process -i ; }
        [ -n "$CEN_OPT_MODULES"   ] && run_process -m
        [ -n "$CEN_OPT_CONTENT"   ] && run_process -c

        if [ -n "$elem" ] ; then
            [ $# -gt 0 ] && documentation -s -q -- "$@" # element filter
            run_process -e                              # generate output
        fi
        #documentation -s -x                            # clear list
    }
    syspager ___docs "$@"                               # output (via pager)
}

# ------------------------------------------------------------------------------
# option parsing: <option> <argument>
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    --help) # input completion
        if [ "$2" = 'verb' ] && serialize -r ; then
           [ "$3" = '--tools' -o "$3" = "-T" ] && \
                set -- "${DAT_REF_TOOLS[@]}" || set -- "${DAT_REF_FUNCTIONS[@]}"
            local item
            for item in "$@" ; do
                item="${item%%$'\a'*}" ; echo "${item%% *}"
            done
        fi ;;

    '') # end of option processing
        optarg "$CEN_OPT_LIBRARY$CEN_OPT_TOOLS" - -m '--tools --library'
        if [ -n "$CEN_OPT_INDEX$CEN_OPT_MODULES$CEN_OPT_CONTENT$CEN_OPT_REFERENCE" ] ; then
            [ -n "$CEN_OPT_USE" ] &&
                optarg - - -m '--use (--index|--modules|--content|--reference)'
            [ -n "$CEN_OPT_TOOLS" ] &&
                optarg - - -m '--tools (--index|--modules|--content|--reference)'
            CEN_OPT_LIBRARY=
        fi
        if [ -n "$CEN_OPT_INDEX" -a -z "$CEN_OPT_HTML" ] ; then
            CEN_OPT_INDEX= ; CEN_OPT_MODULES=1
        fi
        optarg "$CEN_OPT_TOOLS$CEN_OPT_ALL" - -m '--tools --all'
        if [ -n "$CEN_OPT_HTML" ] ; then
            CEN_OPT_PAGER='no'
            [ -n "$CEN_OPT_LINES$CEN_OPT_FILE" ] && optarg - - -m '--html (--lines|--file)'
        fi
        [ -n "$CEN_OPT_FILE" ] && CEN_OPT_LINES=1
        [ -z "$CEN_OPT_FILE" -a -z "$CEN_OPT_LINES" ] && DAT_INP_FAST=1
        if [ "$CEN_OPT_USE" = '.' ] ; then
            CEN_OPT_USE="$BASH_SOURCE"
        elif [ -n "$CEN_OPT_USE" ] ; then
            inpfile -c -s CEN_OPT_USE -- "$CEN_OPT_USE"
        fi
        ;;

    -A|--all*)
        optarg 'all'        - ;;
    -B|--bro*)
        optarg 'browse'     - ;;
    -C|--con*)
        optarg 'content'    - ;;
    -D|--del*)
        optarg 'delete'     - ;;
    --fil|--file)
        optarg 'file'       - ;;        # show file names
    -G|--gen*)
        optarg 'generate'   - 'all|too.*|lib.*|dum.*' ;;
    -H|--htm|--html)
        optarg 'html'       - -d ;;     # folder
    -I|--ind*)
        optarg 'index'      - ;;
    --l10n)
        optarg 'l10n'       - ;;
    --lin*)
        optarg 'lines'      - ;;        # show line numbers
    -L|--lib*)
        optarg 'library'    - ;;
    -M|--mod*)
        optarg 'modules'    - ;;
    -R|--ref*)
        optarg 'reference'  - ;;
    -T|--too*)
        optarg 'tools'      - ;;
    -U|--use)
        optarg 'use'        - -t ;;     # text
    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    usageset \
        -u "$CEN_NAME [-A] [-C] [-I] [-M] [-R] [-H <folder>] [-N] [-U <file>] ..." \
        -u "$CEN_NAME -T [-H <folder>] [-N] [-U <file>] ..." \
        -u "$CEN_NAME -G <what> [-H <folder>] ..." \
        -u "$CEN_NAME -D ..." \
        -u - \
        -u "$CEN_TITLE." \
        -u - \
        -u $"This tool can generate documentation in HTML format or can be used at" \
        -u $"the command line in text mode (like the linux \"man\" program)."
    usageset \
        -o - \
        -o "-D --delete          "$"delete caches" \
        -o "-G --generate <what> "$"generate HTML documentation" \
        -o "-H --html   <folder> "$"create HTML output in folder     (implies --all)" \
        -o "   --file            "$"text only: output file names     (implies --lines)" \
        -o "   --lines           "$"text only: output line numbers" \
        -o "-L --library         "$"process library documentation (default)" \
        -o "-T --tools           "$"process the usage output of tools" \
        -o "-U --use      <file> "$"process a single file, \"-U .\" for '$CEN_NAME'" \
        -o - \
        -o "-A --all             "$"(re)create missing index/modules/content/reference" \
        -o "-C --content         "$"produce table-of-content" \
        -o "-I --index           "$"html only: create 'index.html'" \
        -o "-M --modules         "$"produce table of modules" \
        -o "-R --reference       "$"produce function/topic reference"
    usageset \
        -l $"arguments" \
        -t "<what>       "$"selection"": all | tools | library | dummy" \
        -t "<folder>     "$"output folder (- for /dev/stdout, + to prompt)" \
        -t "<file>       "$"any tool or library file" \
        -t "" \
        -l $"filters" \
        -t $"All extra command line arguments work as output filters. Any number of" \
        -t $"filters can be used and are cumulative. Tree selectors are provided to" \
        -t $"restrict output to functions '-' or topics '+' or modules '='."
    usageset \
        -l $"examples" \
        -t "# "$"select generated output" \
        -t "$CEN_NAME --content   # output table-of-content" \
        -t "$CEN_NAME --all       # also output index/modules/content/reference" \
        -t "$CEN_NAME -i ext      # only output _centauri_bash_ext documentation" \
        -t "$CEN_NAME folder att  # filter for '*folder*' or '*att*'" \
        -t "$CEN_NAME -M move     # in which module is 'move'" \
        -t "$CEN_NAME -C -i _sys  # what is in module _centauri_bash_sys" \
        -t "$CEN_NAME - sys       # restrict output to functions" \
        -t "" \
        -t "# "$"create the documentation as HTML ('doc' is the destination folder)" \
        -t "$CEN_NAME --delete --all --html doc" \
        -t "" \
        -t "# "$"create/view the documentation as file (--force enables ANSI escapes)" \
        -t "$CEN_NAME --all --force > doc.txt" \
        -t "less -FRX doc.txt" \
        -t "" \
        -t "# "$"generate HTML documentation" \
        -t "$CEN_NAME --generate=tools -H mydir      # tool docs to custom location" \
        -t "$CEN_NAME --delete --generate=all        # clear cache, docs to default"
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# ------------------------------------------------------------------------------
# Index + Bash Script Library Documentation - centauri-bash-lib
#
#+General:  The **centauri-bash-lib** library was written to simplify the creation
# of bash scripts that look like standard linux (command line) apps with options,
# usage help and solid error handling.
#
#+It is split into modules (bash source files). The main module file is [[_centauri_bash_lib]].
# The documentation is organized into **module**, **topic** and **function** entries.
#
# Content:  [[Help]]                 How to use the centauri-bash-lib documentation
#           [[Browse]]               Browsing the HTML documentation
#           [[Introduction]]         General information about centauri-bash-lib
#           [[Module]]               List of modules and versions
#           [[Content]]              Documentation content by module
#           [[Reference]]            [[Topics]]/[[modules]]/[[functions]] reference by name
#           [[Applications]]         Tools using centauri-bash-lib and maintenance
#
# Modules:  ###autogenerated###
#
# ###legal###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Modules + Name and Version Reference - centauri-bash-lib
#
#+Versioning: Each tool or module has a version and a minimum api-level. These are
# specified as:
#
#           °       ''<version>:<api-level>''
#
#The ''<api-level>'' field of module [[_centauri_bash_lib]] defines the library
# api-level. See [[versioning]] for details.
#
# ###legal###
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Content + Documentation content by module - centauri-bash-lib
#
#+General:  The library documentation is structured into **modules**, **functions**
# and **topics**. Each **module** is a bash script, and **functions** are always
# contained in **modules**. **Topics** have no executable code.
#
#+The main module [[_centauri_bash_lib]] (or it's proxy) must be sourced by the user
# script, see [[Initialization]]. Other library modules can be loaded dynamically.
#
# ###legal###
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Reference + Function Reference by Name - centauri-bash-lib
#
#+Summary:  The documentation is organized in [[modules]], [[functions]] and [[topics]].
#           Tools that are using centauri-bash-lib are documented at [[Applications]].
#
# ###legal###
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Tools + Name and Version Reference - centauritools
#
#+Versioning: Each tool or module has a version and a minimum api-level. These are
#           specified as ''<version>:<api-level>''. The ''<api-level>'' field of module
#           [[_centauri_bash_lib]] defines the library api-level.
#
# ###legal###
#
# ###autogenerated###
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Browse + Browsing the HTML documentation
#
# Call:     centaurihelp --browse [<opt>]... [<page>]
#           clh -B [<opt>]... <key>...                        # 'centaurihelp -L' alias
#           cth -B [<opt>]...] [[**-**|**+**|**=**] <key>]... # 'centaurihelp -T' alias
#
# Arguments:<key>       function/topic/module to be shown
#           <opt>       any **centaurihelp** option
#           <page>      a page name
#
#+Once you have generated the HTML documentation (via ''"''[[centaurihelp]]°--gen=all''"''),
# these commands launch the qml viewer (or a web  if qml is not installed).
# See also [[help]] for more information.
#
# Keyboard: Some keys are pre-defined to simplify the navigation:
#
#,          - **h**            § This page                  ([[browse]].html)
#,          - **i** or **l**   § Documentation start page   ([[index]].html)
#,          - **c**            § Table of content           ([[content]].html)
#,          - **m**            § List of library modules    ([[module]].html)
#,          - **r**            § Documentation reference    ([[reference]].html)
#,          - **a** or **t**   § Tools and applications     ([[tools]].html)
#,
#,          - <<Backspace>>    § (backspace key) Go back in history
#,          - **p** or **←**   § (arrow left)    Previous page
#,          - **n** or **→**   § (arrow right)   Next page
#,          - **q** or <<ESC>> § (escape key)    Quit viewer (wan't quit a browser)
#
#+Viewer:   This mode uses ''"''[[centaurilauncher]]°viewer''"'' to run the qml viewer.
#           If qml is not installed it tries to run a web browser. On a debian system
#           run the following command to install qml and it's browser component:
#
#.          apt install qml libqt5webview5      # for a debian-like system
#
# ###legal###
# ------------------------------------------------------------------------------

# the end
