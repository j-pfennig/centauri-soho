#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2013-2025; BSD License"
CEN_TITLE="Manage network configuration files, resolv.conf and routing"

# Import the bash library, set name and version
PATH+=":${0%/*}" . _centauri_bash_lib -a -d - '0.66:6' || exit 2

# Import the net library, don't read config
embed -m _centauri_bash_net -n

# Data
                            # invalid host (reject route)
CEN_NET_REJECT_HOST=(bad-host 10.255.255.1)
DAT_CONFIG_LINES=           # lines in config file
DAT_LIST=                   # see 'validate list'
                            # helper lookup tables
declare -A DAT_MAP_ALLOW
                            # maps for IP-Addr Mac-Addr Host-Name
declare -A DAT_MAP_IP DAT_MAP_MAC DAT_MAP_NAME

DAT_OVER_RESOLV=            # see do_override() ...
DAT_OVER_GATEWAY=

# Data for extra options
CEN_OPT_CONFIG="$CEN_DEFAULT/$CEN_NAME"
CEN_OPT_NOREST=             # see --norestart
CEN_OPT_OUTPUT=             # see --output, '-' for stdout or an existing folder
CEN_OPT_ROUTER=             # see --router
CEN_OPT_SERVER=             # see --server

export CEN_SVC_SYSLOG       # actual logging mode (environment import)

# private ports, see load_ports()
DAT_PORT_SECR=
DAT_PORT_ADNS=
DAT_PORT_HTTP=
DAT_PORT_HTTPS=

DAT_UNMANAGED='not-at-home' # config flag

declare -A DAT_MAP_OPTS     # option cache, see has_option

# set umask to give all created files 0644 protection
umask 022

# ------------------------------------------------------------------------------
# test if dnsmasq is used: <host>
# ------------------------------------------------------------------------------
has_nameserv() {
    local name="${1:-$HOSTNAME}"
    has_option 'dns' "$name" || return 1            # no dns configured

    # do not run dnsmasq if computer was booted as 'switch'
    nettemp -s 'centauriswitch' || return 1         # source state file
    [ "$DAT_SWITCH_MODE" = 'switch' ] && return 1
    # mode 'router' uses dnsmasq
    [ "$DAT_SWITCH_MODE" = 'router' ] && return 0

    netquery CLIENT && return 1                     # clients never run DNS
    netquery MASTER && return 0                     # master must run DNS
    netquery SLAVE  && return 1                     # slave never runs DNS
    return 0
}

# ------------------------------------------------------------------------------
# Option caching:   <opt> <host>
# ------------------------------------------------------------------------------
has_option() {
    local rslt keys="$1:$2"
    rslt="${DAT_MAP_OPTS["$keys"]}"
    [ -n "$rslt" ] && return "$rslt"
    if netoption "$1" "$2" ; then
        DAT_MAP_OPTS["$keys"]=0 ; return 0
    fi
    DAT_MAP_OPTS["$keys"]=1 ; return 1
}

# ------------------------------------------------------------------------------
# Config tests
# ------------------------------------------------------------------------------
# Test if host name is a server: <host>
is_server() {
    local name
    for name in "${CEN_NET_SERVERS[@]}" ; do
        [ "$1" = "$name" ] && return 0
    done
    return 1
}

# Test if host name is a router: <host>
is_router() {
    local name
    for name in "${CEN_NET_ROUTERS[@]}" ; do
        [ "$1" = "$name" ] && return 0
    done
    return 1
}

# ------------------------------------------------------------------------------
# Get list of IP4 addresses for a host: <host>
# ------------------------------------------------------------------------------
addr_list() {
    local host="${1%[-_][0-9]}" addr
    CEN_NET_ADDR_IPLIST=()
    if [ "$1" != "$host" ] ; then
        warning -p "Hostname '%s' should be '%s' [no interface suffix]" "$1" "$host"
        return 1
    fi

    # hostname should have the logical address
    nethost -- "$host" || return 1
    CEN_NET_ADDR_IPLIST+=("$_nethost_ip")

    # add interface addresses
    for addr in "${CEN_NET_HOSTS[@]}" ; do
        set -- $addr ; shift
        addr="${2%%.*}"
        [ "$addr" = "$host" ] && continue
        addr="${2%[-_][0-9]}"
        [ "$addr" = "$host" ] && CEN_NET_ADDR_IPLIST+=("$1")
    done

    [ "$_nethost_mac" != '-' -a -n "${CEN_NET_ADDR_IPLIST[1]}" ] &&
        warning -p "The logical '%s' address should not have a MAC value" "$host"
}

# ------------------------------------------------------------------------------
# get private port via getent: <name> <vari> [<dflt>]
# ------------------------------------------------------------------------------
load_port() {
    local -n _vdns="$2"
    [ -n "$_vdns" ] && return
    local _aprt
    system -q -r -s _aprt -- getent services "$1"
    if [ -z "$_aprt" ] ; then
        [ -z "$3" ] && return
        _vdns="$3"
        warning "Could not retrieve '$1' port, using port" "$_vdns"
    else
        _vdns="${_aprt##* }" ; _vdns="${_vdns//[!0-9]*/}"
    fi
}

# ------------------------------------------------------------------------------
# Write config cache file: [<domain>]
# ------------------------------------------------------------------------------
do_coca() {
    local domn="${1:-$CEN_NET_DOMAIN}"
    [ "$domn" = '-' ] && return
    [ "$domn" = "$CEN_NET_DOMAIN" ] || \
        warning -a "Overriding domain: '$CEN_NET_DOMAIN'  =>  '$domn'"

    local radr data
    [ -n "$CEN_NET_ROUTER_DEF" ] && radr="${DAT_MAP_IP[$CEN_NET_ROUTER_DEF]}"

    load_port 'centauriadns'    DAT_PORT_ADNS  5354
    load_port 'centaurisecrets' DAT_PORT_SECR    95
    load_port 'centaurihttp'    DAT_PORT_HTTP  3128
    load_port 'centaurihttps'   DAT_PORT_HTTPS "$DAT_PORT_HTTPS"

    if [ -z "$CEN_NET_PREFIX_IP6" ] ; then
        CEN_NET_PREFIX_IP6="${CEN_NET_PREFIX_IP6_DFLT%/*}/$((128 - $CEN_NET_NETBITS))"
        trace -a -c "ipv6 prefix" "$CEN_NET_PREFIX_IP6"
    fi
    data=("CEN_NET_CONFIG='${CEN_NET_CONFIG:-${domn%%.*}}'"
          "CEN_NET_DOMAIN='$domn'"
          "CEN_NET_WIRELESS='$CEN_NET_WIRELESS'"
          "CEN_NET_PUBLIC='$CEN_NET_PUBLIC'" ''
          "CEN_NET_REJECT_HOST=(${CEN_NET_REJECT_HOST[*]@Q})" ''
          "CEN_NET_SERVER_GEN='$CEN_NET_SERVER_GEN'" ''
          "CEN_NET_ROUTER_GEN='$CEN_NET_ROUTER_GEN'"
          "CEN_NET_ROUTER_DEF='$CEN_NET_ROUTER_DEF'"
          "CEN_NET_ROUTER_IP4='$radr'" ''
          "CEN_NET_PREFIX_IP6='$CEN_NET_PREFIX_IP6'" ''
          "CEN_NET_NETMASK='$CEN_NET_NETMASK'"
          "CEN_NET_NETBITS='$CEN_NET_NETBITS'" ''
          "CEN_NET_EXTERNAL='$CEN_NET_EXTERNAL'" ''
          "CEN_NET_ADDR_IPLIST=(${CEN_NET_ADDR_IPLIST[*]@Q})"
          "CEN_NET_ADDR_METHOD='$CEN_NET_ADDR_METHOD'" ''
          "CEN_NET_NETWORKS=(${CEN_NET_NETWORKS[*]@Q})"
          "CEN_NET_SERVERS=(${CEN_NET_SERVERS[*]@Q})"
          "CEN_NET_ROUTERS=(${CEN_NET_ROUTERS[*]@Q})"
          "CEN_NET_FILTERS=(${CEN_NET_FILTERS[*]@Q})" ''
          "CEN_NET_OPTIONS=(${CEN_NET_OPTIONS[*]@Q})" ''
          "CEN_NET_HOMEDNS=(${CEN_NET_HOMEDNS[*]@Q})" ''
          "CEN_NET_HOSTS=(${CEN_NET_HOSTS[*]@Q})"
          "CEN_NET_IFACES=(${CEN_NET_IFACES[*]@Q})" ''
          "CEN_NET_FAKES=(${CEN_NET_FAKES[*]@Q})" ''
          "CEN_NET_PORT_SECR=$DAT_PORT_SECR"
          "CEN_NET_PORT_ADNS=$DAT_PORT_ADNS"
          "CEN_NET_PORT_HTTP=$DAT_PORT_HTTP"
          "CEN_NET_PORT_HTTPS=$DAT_PORT_HTTPS"
    )
    netfile -a -h -v data -- "$CEN_NET_FILE_CONF"
}

# ------------------------------------------------------------------------------
# Parse configuration file: [-c|-v|-u] [<hostname> [<domain>]]
# ------------------------------------------------------------------------------
do_config() {
    # options parsing
    local optc optu optv
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -c)   optc=1 ;;                       # create cache file
      -u)   optu=1 ;;                       # update cache file if needed
      -v)   optv=1 ;;                       # validate, force config parsing
      *)    fatal "Bad 'do_config' argument:" "$1"
      esac ; shift
    done
    if [ -n "$optu" ] ; then
        if ! [ "$CEN_OPT_CONFIG" -nt "$CEN_NET_FILE_CONF" ] ; then
            netconfig && return 0
        fi ; optc=1
    fi
    if [ -n "$DAT_CONFIG_LINES" -a -z "$optv" ] ; then  # already parsed
        [ -n "$optc" ] && do_coca "$domn"               # write config file
        return 0
    fi

    netconfig -u                            # must reset config

    # setup vars
    local host="${1:-$HOSTNAME}" domn="$2"
    local keyw args curr hdns=()
    DAT_CONFIG_LINES=0
    # reserved host names
    DAT_MAP_IP=([local]=+ [guest]=+ [client]=+ [master]=+ [slave]=+)
    DAT_MAP_MAC=() ; DAT_MAP_NAME=() ; DAT_MAP_ALLOW=()
    # maps for filter and options
    local -A mflt mopt

    [ -r "$CEN_OPT_CONFIG" ] || fatal "Cannot read configuration: $CEN_OPT_CONFIG"
    CEN_NET_PREFIX_IP6=

    # --------------------------------------------------------------------------
    # local helpers
    # --------------------------------------------------------------------------

    ___error() {
        error "$* [line $DAT_CONFIG_LINES]"
        message -i "$keyw $args" ; return 1
    }

    ___message() {
        [ -z "$DAT_LIST" ] && return 0
        local frmt="    $1\n" ; shift
        printf "$frmt" "$@"
    }

    # check for valid address (not netmask bits)
    ___arg_address() {
        netmask -- "$CEN_NET_NETWORKS" "$1" && return 0
        [ -n "$CEN_NET_EXTERNAL" ] && netmask -- "$CEN_NET_EXTERNAL" "$1" && return 0
        _netparse_addr='0.0.0.0' ; _netparse_bits=0 ; _netparse_mask=
        ___error "Invalid ip address: $1" ; return 1
    }

    # check for valid network (need netmask bits): <indx> <nnam> <addr>
    ___arg_network() {
        local indx="$1" nnam="$2" addr="$3" emsg # aopt
        if [ -z "$indx" ] ; then
            emsg="Invalid network name:"
        else
            netmask -- "$addr"                  # also sets _netparse_addr amd bits
            case $? in
            0)  netconv -d -- "$_netmask_mask"  # need to convert to dec -> dotted
                _netparse_mask="$_netconv"
                return 0 ;;
            1)  emsg="Invalid sub-net syntax:" ;;
            *)  emsg="Invalid sub-net specification:"
            esac
        fi
        _netparse_addr='0.0.0.0' ; _netparse_bits=0 ; _netparse_mask='0.0.0.0'
        ___error "$emsg" "$addr" ; return 1
    }

    # check arg count range: <cnt> <min> <max> <name>
    ___arg_rng_chk() {
        if   [ "$1" -lt "$2" ] ; then
            ___error "Not enough arguments: got $1 (min $2): $4"
        elif [ "$1" -gt "$3" ] ; then
            ___error "Too many arguments: got $1 (max $2): $4"
        fi
    }

    ___arg_min_chk() {
        [ "$1" -ge "$2" ] && return 0
        ___error "Not enough arguments: got $1 (min $2): $3"
    }

    ___arg_max_chk() {
        [ "$1" -le "$2" ] && return 0
        ___error "Too many arguments: got $1 (max $2): $3"
    }

    # remove '-' args: <vstr> <args>...
    ___arg_rm_void() {
        local _vstr="$1" _list ; shift
        while [ $# -gt 0 ] ; do
            [ "${1::1}" = '-' ] || _list+=" $1"
            shift
        done
        [ -z "$_list" ] && return 1
        printf -v "$_vstr" '%s' "${_list:1}"
    }

    ___filter_chk_port() {
        case "$1" in
        '')     return 0 ;;
        +|++)   return 0 ;;
        +:++)   return 0 ;;
        *:|:*)  ;;
        *)      case "${1//[0-9]/}" in
                '')     return 0 ;;
                :)      return 0 ;;
                +:)     return 0 ;;
                :++)    return 0 ;;
                esac
        esac
        ___error "Invalid $2 port: $1" ; return 1
    }

    ___filter_chk_addr() {
        [ -z "$1" ] && return 0
        [ "${1//[0-9]}" = '...' -o "${1//[0-9]}" = '.../' ] && return 0
        ___error "Invalid destination address: $1" ; return 1
    }

    # Check filter syntax: <dport>[|<sport>[|<daddr>]]
    ___filter_chk() {
        local apar npar
        splitjoin -s apar -d '|' -- "$1"
        #$CEN_TRACE2 "filter chk: $1 ${apar[0]}|${apar[1]}|${apar[2]}|${apar[3]}"
        if [ "${#apar[@]}" -gt 4 ] ; then
            ___error "Too many fields: $1 (dport|sport|daddr|saddr)"
        else
            ___filter_chk_port "${apar[0]}" 'destination' &&
            ___filter_chk_port "${apar[1]}" 'source' &&
            ___filter_chk_addr "${apar[2]}" 'destination' &&
            ___filter_chk_addr "${apar[3]}" 'source' && return 0
        fi
        return 1
    }

    # Register a host-name: <name> [<ip>|-|+]  # no arg: reserve name
    ___mapname() {
        local snam="${name%%.*}" sdom="${name#*.}"
        [ "$name" = "$sdom" ] && sdom=
        if [ -n "${snam//[-_a-zA-Z0-9]/}" ] ; then
            ___error "Host name is invalid: $1"
        elif [ "$sdom" = "${CEN_NET_DOMAIN:--}" ] ; then
            ___error "Host must not specify local domain: $1"
        elif [  "$2" = '+' ] ; then
            DAT_MAP_IP[$1]= ; return
        elif [ "${DAT_MAP_IP[$1]}" = '=' ] ; then
            ___error "Reserved host name: $1"
        elif [ -n "${DAT_MAP_IP[$1]}" ] ; then
            ___error "Duplicated host name: $1"
        else
            DAT_MAP_IP[$1]="${2:-=}"
        fi
    }

    # Register an ip address: <name> <mac>|- [<ip>|-]
    ___mapaddr() {
        # check mac address
        if [ "${2:--}" = '-' ] ; then
            :
        elif [ "${2//[0-9a-fA-F]/}" != ":::::" ] ; then
            ___error "MAC address not valid"
        elif [ -z "${DAT_MAP_MAC[$2]}" ] ; then
            DAT_MAP_MAC[$2]="$1"
        else
            ___error "MAC address is used by:" "${DAT_MAP_MAC[$2]}"
        fi

        # check ip address
        [ "${3:--}" = '-' ] && return
        if [ -z "${DAT_MAP_NAME[$3]}" ] ; then
            DAT_MAP_NAME[$3]="$1" ; return
        fi
        ___error "IP address is used by:" "${DAT_MAP_NAME[$3]}"
    }

    ___config_allow() {
        ___arg_min_chk $# 2 'allow' || return 1
        local what="$1" ; shift
        local curr="${DAT_MAP_ALLOW[$what]} $*"
        DAT_MAP_ALLOW[$what]="${curr# }"
        ___message "%-10s %s %s" 'allow' "$what" "$*"
    }

    ___config_config() {
        ___arg_rng_chk $# 1 1 'config' || return 1
        [ "$1" = '-' ] && CEN_NET_CONFIG="$DAT_UNMANAGED" || CEN_NET_CONFIG="$1"
        ___message "%-10s %s" 'config' "$1"
    }

    ___config_fake() {
        ___arg_rng_chk $# 1 1 'fake' || return 1
        CEN_NET_FAKES+=("$@")
    }

    ___config_filter() {
        ___arg_min_chk $# 2 'filter' || return 1
        local addr what="$1" ; shift
        ___message "%-10s %-7s %s" 'filter' "$what" "$*"

        case "$what" in
        bypass|deny)
            ;;
        accept|drop|trusted|player|thing|friend|trash)
            local nidx list=()
            for addr in "$@" ; do
                if [ -z "${addr//[a-z0-9\[\]\?\*-]/}" ] ; then
                    list+=("$addr") ; continue
                elif netindex -s nidx -- "${addr//[<>]/}" ; then
                    if [ -z "$nidx" ] ; then
                        message -a -p "Sub-net not configured: %s [line %s]" \
                                      "filter $what $*" "$DAT_CONFIG_LINES"
                        continue
                    fi
                fi
                ___arg_address "$addr" ; list+=("$_netparse_addr/$_netparse_bits")
            done
            set -- "${list[@]}"
            ;;
        lit)
            ;;
        tcp|udp)
            what+=" $1" ; shift
            for addr in "$@" ; do
                ___filter_chk "$addr" || return 1
                mflt["$what"]+="$addr "
            done ; return 0
            ;;
        *)
            ___error "Unknown keyword:" "$what"
        esac
        CEN_NET_FILTERS+=("$what $*")
    }

    ___config_homedns() {
        ___arg_rng_chk $# 2 3 'homedns' || return 1
        hdns+=("$1 $2 ${3:-$2}")
        ___message "%-10s %s %s %s" 'homedns' "$1" "$2" "${3:-$2}"
    }

    # statement: host <mac>|-|+ <addr>|+|- <name> [<alias>]...
    ___config_host() {
        ___arg_min_chk $# 3 'host' || return 1
        local maca="$1" ; shift
        local ip4a="$1" ; shift
        local name="${1:--}" ; [ "$name" = '-' ] && return 0

        if [ "$ip4a" = '+' ] ; then
            ip4a="${_netparse_addr##*.}" ; ((ip4a += 1))
            ip4a="${_netparse_addr%.*}.$ip4a"
            _netparse_addr="$ip4a"
        elif [ "$ip4a" != '-' ] ; then
            ___arg_address "$ip4a" ; ip4a="$_netparse_addr"
        fi

        if [ "$name" = "$CEN_NET_SERVER_GEN" ] ; then
            ___mapname "$name" +                    # unlock
            [ $# = 1 ] || ___error "Generic server name cannot be aliased"
            maca='-'
        fi

        if [ "$maca" = '+' ] ; then             # allow duplicated host entry
            if [ -n "${DAT_MAP_IP[$name]}" ] || [ -n "${DAT_MAP_NAME[$ip4a]}" ] ; then
                ___message "%-10s %-18s %-18s %s   # ignored " 'host' "$maca" "$ip4a" "$name"
                return
            fi
            maca='-'
        fi

        for name in "$@" ; do                       # loop over list of names...
            ___mapname "$name" "$ip4a"
        done
        ___message "%-10s %-18s %-18s %s" 'host' "$maca" "$ip4a" "$*"
        CEN_NET_HOSTS+=("$maca $ip4a $*") ; ___mapaddr "$1" "$maca" "$ip4a"
    }

    ___config_iface() {
        ___arg_rng_chk $# 3 3 'iface' || return 1
        case "$1" in
        eth[01]|wlan[01])   ;;
        *)      ___error "Invalid interface name:" "$1"
        esac
        case "$3" in
        -)          ;;                              # stop search
        en*|wl*)    ;;                              # ethernet/wlan
        ??:??:??:??:??:??)  ;;                      # mac address
        *)     [ -n ${3//[a-z0-9-]/} ] && ___error "Invalid interface mapping:" "$3"
        esac
        CEN_NET_IFACES+=("$*")
        ___message "%-10s %s" 'iface' "$*"
    }

    ___config_network() {
        ___arg_rng_chk $# 2 2 'network' || return 1
        [ "$2" = '-' ] && return 0
        [ "$1" = '-' ] && set -- "$CEN_NET_CONFIG.home" "$2"

        local indx
        case "$1" in
        *.*)        indx=0 ; CEN_NET_DOMAIN="$1" ;;
        external)   indx=8 ;;
        *)          netindex "$1" && indx="$_netindex"
        esac
        ___arg_network "$indx" "$1" "$2" || quit -e

        if [ "$indx" = 0 ] ; then                   # domain network
            CEN_NET_NETWORKS=("$_netparse_addr/$_netparse_bits")
            CEN_NET_NETMASK="$_netparse_mask"
            CEN_NET_NETBITS="$_netparse_bits"
        elif [ "$indx" = 8 ] ; then                 # external network
               if [ "$_netparse_bits" -lt "$CEN_NET_NETBITS" ] ; then
                    CEN_NET_NETBITS="$_netparse_bits"
                    CEN_NET_NETMASK="$_netparse_mask"
               fi
               local over=0
               CEN_NET_EXTERNAL="$_netparse_addr/$_netparse_bits"
               netmask "$CEN_NET_NETWORKS" "$CEN_NET_EXTERNAL" && ((over += 1))
               netmask "$CEN_NET_EXTERNAL" "$CEN_NET_NETWORKS" && ((over += 2))
               #[ "$CEN_ACTION" != 'validate' ] &&
               case "$over" in
               1)   message -p $"External network '%s' is sub-net of base '%s'" \
                               "$CEN_NET_EXTERNAL" "$CEN_NET_NETWORKS" ;;
               2)   message -p $"Base network '%s' is sub-net of external '%s'" \
                               "$CEN_NET_NETWORKS" "$CEN_NET_EXTERNAL" ;;
               3)   ___error $"Base and external are the same network" ;;
               *)   ___error $"Base and external network must overlap completely"
               esac
               #CEN_NET_NETWORKS[7]="$CEN_NET_EXTERNAL"
        elif [ -z "$CEN_NET_NETWORKS" ] ; then
             ___error "No base network defined:" "$1" || quit -e
        elif [ -n "${CEN_NET_NETWORKS[indx]}" ] ; then
            ___error "Network already defined:" "$1"
        elif ___subnetchk "$indx" "$2" ; then
            CEN_NET_NETWORKS[indx]="$_netparse_addr/$_netparse_bits"
        fi
        ___message "%-10s %-16s %s" 'network' "$1" "$2"
        return
    }

    ___config_option() {
        ___arg_min_chk $# 2 'option' || return 1
        local what="$1" list ; shift
        ___arg_rm_void list "$@" || return 0
        mopt["$what"]+="$list"
        ___message "%-10s %s %s" 'option' "$what" "$list"
    }

    ___config_prefix() {
        ___arg_rng_chk $# 1 1 'prefix' || return 1
        CEN_NET_PREFIX_IP6="$1"
        ___message "%-10s %s" 'prefix' "$1"
    }

    ___config_public() {
        ___arg_rng_chk $# 0 1 'public' || return 1
        CEN_NET_PUBLIC="${1:--}"
        ___message "%-10s %s" 'public' "$CEN_NET_PUBLIC"
    }

    ___config_reject() {
        ___arg_rng_chk $# 2 2 'reject' || return 1
       if netparse -a -- "$2" ; then
           CEN_NET_REJECT_HOST=($1 $2)
       else
           ___error "Invalid ip address:" "$2"
       fi
        ___message "%-10s %s %s" 'reject' "$1" "$2"
    }

    ___config_router() {
        ___arg_rng_chk $# 2 5 'router' || return 1
        CEN_NET_ROUTER_GEN="$1" ; ___mapname "$1" ; shift
        CEN_NET_ROUTER_DEF="$1"
        CEN_NET_ROUTERS=("$@")
        ___message "%-10s %s %s" 'router' "$CEN_NET_ROUTER_GEN" "$*"
    }

    ___config_server() {
        ___arg_rng_chk $# 2 3 'server' || return 1
        CEN_NET_SERVER_GEN="$1" ; ___mapname "$1" ; shift
        if [ "${2:--}" = '-' -a "${3:--}" = '-' ] ; then
            shift ; shift ; shift
        elif [ "${1:--}" = '-' ] ; then
            ___error $"Generic server name missing"
        fi
        CFG_SERVER_DEF="$1"
        CEN_NET_SERVERS=("$@")
        ___message "%-10s %s %s" 'server' "$CEN_NET_SERVER_GEN" "$*"
    }

    ___config_wireless() {
        ___arg_rng_chk $# 0 2 'wireless' || return 1
        CEN_NET_WIRELESS="${1:--} ${2:--}"
        ___message "%-10s %s" 'wireless' "$CEN_NET_WIRELESS"
    }

    # assert that net is a subnet of domain or external: <name> <addr>
    ___subnetchk() {
        netmask -- "$CEN_NET_NETWORKS" "$2" && return 0
        if [ "$indx" != 7 ] ; then
            ___error "Sub-net not in base network:" "$1"
            return 1
        # <other> net can also be a sub-net of external ...
        elif [ -z "$CEN_NET_EXTERNAL" ] ; then
            ___error "Sub-net not in base network (no external network):" "$1"
        elif netmask -- "$CEN_NET_EXTERNAL" "$2" ; then
            return 0
        fi
        ___error "Sub-net neither in base nor external network:" "$1"
        return 1
    }

    # --------------------------------------------------------------------------
    # parsing
    # --------------------------------------------------------------------------

    ___reader() {
        DAT_CONFIG_LINES="${CEN_CONFIGFILE[2]}"
        args="${1%%#*}" ; keyw="${args%%[[:space:]]*}"
        [ "$keyw" = "$args" ] && args= || args="${args#*[[:space:]]}"
        set -f ; set -- $args ; set +f
        [ "$curr" != "$keyw" ] && ___message ' ' ; curr="$keyw"
        case "$keyw" in
            '#'*|"")    continue ;;
            allow)      ___config_allow   "$@" ;;
            config)     ___config_config  "$@" ;;
            fake)       ___config_fake    "$@" ;;
            filter)     ___config_filter  "$@" ;;
            homedns)    ___config_homedns "$@" ;;
            host)       ___config_host    "$@" ;;
            iface)      ___config_iface   "$@" ;;
            network)    ___config_network "$@" ;;
            option)     ___config_option  "$@" ;;
            prefix)     ___config_prefix  "$@" ;;
            public)     ___config_public  "$@" ;;
            reject)     ___config_reject  "$@" ;;
            router)     ___config_router  "$@" ;;
            server)     ___config_server  "$@" ;;
            wireless)   ___config_wireless "$@" ;;
            *)          ___error "Invalid configuration entry" ;;
        esac
    }
    configfile -n "$CEN_OPT_CONFIG" -r ___reader
    error -t || return

    # general checks ...
    [ -n "$CEN_NET_DOMAIN" ] || error "Missing 'network' statements"
    [ -n "$CEN_NET_HOSTS" ]  || error "Got no 'host' statement"
    [ -n "$CEN_NET_CONFIG" ] || error "Got no 'config' statement"
    if [ "$CEN_NET_CONFIG" != "$DAT_UNMANAGED" ] ; then
        [ -n "$CEN_NET_ROUTERS" ] || warning "No 'router' statement"
        [ -n "$CEN_NET_SERVERS" ] || warning "No 'server' statement"
    fi
    error -t || return
#    # sub-network 'other' defaults to 'external' ...
#    [ -z "$CEN_NET_NETWORKS[7]" ] && CEN_NET_NETWORKS[7]="$CEN_NET_EXTERNAL"

    local name stat
    # check router ....
    for name in "${CEN_NET_ROUTERS[@]}" ; do
        [ -n "${DAT_MAP_IP[$name]}" ] || error "Router '$name' has no host statement"
    done

    # check server ....
    for name in "${CEN_NET_SERVERS[@]}" ; do
        [ -n "${DAT_MAP_IP[$name]}" ] || error "Server '$name' has no host statement"
    done

    # handle --server and --router options
    if [ -n "$CEN_OPT_ROUTER" ] ; then
        is_router "$CEN_OPT_ROUTER" || error "Option --router: not a router: $CEN_OPT_ROUTER"
        CEN_NET_ROUTER_DEF="$CEN_OPT_ROUTER"
    fi
    if   [ "$CEN_OPT_SERVER" = '-' ] ; then
        CFG_SERVER_DEF=
    elif [ -n "$CEN_OPT_SERVER" ] ; then
        is_server "$CEN_OPT_SERVER" || error "Option --server: not a server: $CEN_OPT_SERVER"
        CFG_SERVER_DEF="$CEN_OPT_SERVER"
    fi

    # fixup homdns
    local ndef hdef opts ohst
    CEN_NET_HOMEDNS=()
    for args in "${hdns[@]}" ; do
        set -f ; set -- $args ; set +f
        name="${3%%.*}"

        # handle nameserver argument
        if [ "${2//[0-9]/}" = '...' ] ; then    # ip4 address
            args="$2"
        elif [ "$2" != '-' ] ; then
            args="${DAT_MAP_IP[${2%%.*}]}"
            if [ -z "$args" ] ; then
                error "homedns $*: '$2' is not a host"
                continue
            fi
        fi

        # handle server argument and add config entry
        if nethost "$name" ; then
            name="$_nethost_name"
        elif [ "${name%%.*}" != "$CEN_NET_SERVER_GEN" ] ; then
            warning "homedns $*: '$3' is no configured host"
        fi
        if [ "$1" = "$CEN_NET_DOMAIN" ] ; then
            [ "${name%%.*}" = "$CEN_NET_SERVER_GEN"   ] && ndef=1
            [ "${name%%.*}" = "${CEN_NET_SERVERS[0]}" ] && ndef=1
            [ "${name%%.*}" = "${CEN_NET_SERVERS[1]}" ] && ndef=1
        fi
        [ "${name%%.*}" = "$name" ] && name+=".$CEN_NET_DOMAIN"
        CEN_NET_HOMEDNS+=("$1 $args $name")
    done

    # add firewall rules to filters
    for name in "${!mflt[@]}" ; do
        CEN_NET_FILTERS+=("$name ${mflt[$name]% }")
    done

    # imply option 'dns' and 'dhcp' for 'repeater' or 'router'
    CEN_NET_OPTIONS=()                              # temporarily set options...
    for name in 'repeater' 'router' 'dns' 'dhcp' ; do
        CEN_NET_OPTIONS+=("$name ${mopt[$name]% }")
    done
    local adns=() adhc=()
    for name in "${!DAT_MAP_IP[@]}" ; do            # loop over hosts...
        [ "$name" = "${name%-[0-9]}" ] || continue
        if has_option 'repeater' "$name" || has_option 'router' "$name" ; then
            has_option 'dns' "$name" || adns+=("$name")
            has_option 'dhcp' "$name" || adhc+=("$name")
        fi
    done
    if [ -n "$adns" ] ; then
        trace -a -c -y "Implicit DNS" -- "${adns[*]}"
        mopt['dns']="${mopt['dns']% } ${adns[*]}"
    fi
    if [ -n "$adhc" ] ; then
        trace -a -c -y "Implicit DHCP" -- "${adhc[*]}"
        mopt['dhcp']="${mopt['dhcp']% } ${adhc[*]}"
    fi

    # collect options, imply 'option other ...'
    CEN_NET_OPTIONS=()
    for name in "${!mopt[@]}" ; do
        CEN_NET_OPTIONS+=("$name ${mopt[$name]% }")
    done
    if [ -n "$CEN_NET_EXTERNAL" ]  ; then
        netoption 'other' || CEN_NET_OPTIONS+=('other *')
    fi

    # homedns default rules
    if [ -z "$ndef" ] ; then
        hdef=()
        for name in "${CEN_NET_SERVERS[@]}" - ; do
            if [ "${name:--}" = '-' ] ; then        # end of list ...
                name="$CEN_NET_ROUTER_DEF"
                [ -z "$name" ] && continue
            else
                has_option 'dns' "$name" || continue
            fi
            args="${DAT_MAP_IP[$name]}"
            [ -n "$args" ] &&
                hdef+=("$CEN_NET_DOMAIN $args $CEN_NET_SERVER_GEN.$CEN_NET_DOMAIN")
        done
        CEN_NET_HOMEDNS=("${hdef[@]}" "${CEN_NET_HOMEDNS[@]}")
    fi

    # write config cache
    [ -z "$optv" ] && error -q                  # config errors are fatal
    netquery 'connect' "$host"
    trace -a -c "Connect method" "$CEN_NET_ADDR_METHOD"
    addr_list "$host"
    [ -n "$optc" ] && do_coca "$domn"           # write config file
}

# ------------------------------------------------------------------------------
# Link /etc/hosts: [-f] <target>|-
#
# Options:  -f      force nameservice restart (implied if link changes)
# ------------------------------------------------------------------------------
do_linkhosts() {
    [ "$CEN_OPT_OUTPUT" = '-' ] && return

    local nscd base='/etc/hosts'
    if [ "$1" = '-f' ] ; then
        nscd=1 ; shift
    fi
    [ "${1:--}" = '-' ] && set 'local'

    if netlink -m -k "$base" '_' "$1" ; then
        [ -n "$_netlink" ] && message "Hosts config switched to: $1"
    else
        netlink -m -k "$base" '_' 'local'
        warning "Hosts config switched to: local ('$1' not found)"
    fi

    [ -n "$_netlink" ] && nscd=1
    [ -z "$CEN_OPT_OUTPUT" -a -n "$nscd" ] && do_restart -c 'dnsmasq'
}

# ------------------------------------------------------------------------------
# Write the /etc/hosts_xxxx file: servers/routers/hosts <hostname> <mode>
# ------------------------------------------------------------------------------
do_hosts() {
    local igen host="${1:-$HOSTNAME}" ; shift
    nethost "$CEN_NET_SERVER_GEN"
    [ "${_nethost_ip:--}" != '-' ] && igen="$_nethost_ip"

    local self nov6
    [ -n "${DAT_MAP_IP[$host]}" ] || self=" $host"
    has_option 'ipv6' "$host" || nov6='#'

    local lnam                                  # to insert separator lines
    local smas='master' sslv='slave'

    # write a host entry: <ip> <name>...
    ___hosts_writer() {
        [ "${1:--}" = '-' -o -z "$2" ] && return    # need at least ip and one name
        local name entr temp
        printf -v entr '%-25s ' "$1" ; shift
        for name in "$@" ; do
            [ -z "$name" ] && continue
            if [ "${name#*.}" = "$name" ] ; then
                printf -v temp '%-24s %-10s ' "$name.$CEN_NET_DOMAIN" "$name"
            else
                printf -v temp '%-24s ' "$name"
            fi
            entr+="$temp"
        done
        dtmp+=("$entr")
    }

    # generate host entry: <mac> <ipv4> <host> [<alias>...]
    ___hosts_entry() {
        local maca="$1" ; shift
        local ip4a="$1" ; shift
        local bnam="${1%-[0-9]}"                 # base name, strip suffix

        if [ "$maca" = '-' ] && has_option 'mdns' "$1" ; then
            printf -v maca '#%-23s %-24s # %s' "$ip4a" "$bnam" $"(using mdns)"
            dtmp+=("$maca") ; return
        fi

        # the host has ip6v
        if has_option 'ipv6' "$1" ; then
            if [ "$bnam" != "$lnam" ] && [ -n "$bnam" ] ; then
                lnam="$bnam" ; dtmp+=('')
            fi
            ___hosts_writer "$ip4a" "$@"
            netconv -u -- "$ip4a" && ___hosts_writer "$_netconv" "$@"

        # is ipv4 only
        else
            [ "$lnam" != '-' ] && dtmp+=('') ; lnam='-'
            ___hosts_writer "$ip4a" "$@"
        fi
    }

    local drtr dsvr dhst dfak drej dtmp data=()

    # Generate a filtered host list: servers|routers|hosts
    ___hosts_hostlist() {
        local what="$1" serv="$2"
        local addr maca defr defs defm

        if [ "$what" = 'servers' ] ; then
            # fake line for 'local' mode
            if [ "$serv" = 'local' -a -n "$CEN_NET_SERVER_GEN" ] ; then
                dtmp+=('' "# Fake: local mode, no valid server")
                ___hosts_writer "${CEN_NET_REJECT_HOST[1]}" "$CEN_NET_SERVER_GEN" $smas $sslv

            # ip entry for generic host
            elif [ -n "$igen" ] ; then
                ___hosts_entry - "$igen" "$CEN_NET_SERVER_GEN"
            fi
        fi

        for addr in "${CEN_NET_HOSTS[@]}" ; do
            set -- $addr ; maca="$1" ; shift                # pop ip4 and mac addr
            [ "$1" = '-' ] && continue                      # no ip4 addr
            addr="$1" ; shift                               # ip4 addr
            if is_server "$1" ; then                        # select by group ...
                [ "$what" = 'servers' ] || continue
                [ "$1" = "$serv" ] && defs="$CEN_NET_SERVER_GEN"
                if [ "$serv" != 'local' ] ; then
                    [ "$1" = "$serv" ] && defm="$smas" || defm="$sslv"
                fi
            elif is_router "$1" ; then
                [ "$what" = 'routers' ] || continue
                [ "$1" = "$CEN_NET_ROUTER_DEF" ] && defr="$CEN_NET_ROUTER_GEN"
            else
                [ "$what" = 'hosts' ] || continue
            fi

            # use generic server with own ip
            if [ -n "$igen" ] ; then
                [ "$addr" = "$igen" ] && continue    # no entry for generic
                defs=
            fi

            ___hosts_entry "$maca" "$addr" "$@" $defr $defs $defm
            defr= ; defs= ; defm=
        done
    }

    dtmp=() ; ___hosts_hostlist routers      ; drtr=("${dtmp[@]}")
    dtmp=() ; ___hosts_hostlist servers "$1" ; dsvr=("${dtmp[@]}")
    dtmp=() ; ___hosts_hostlist hosts        ; dhst=("${dtmp[@]}")

    # Generate the fake list
    local name reje="${CEN_NET_REJECT_HOST[1]}"
    for name in "${CEN_NET_FAKES[@]}" ; do
        dfak+=("$reje       $name")
    done

    printf -v drej '%-25s %-24s %s\n' "${CEN_NET_REJECT_HOST[1]}" \
                   "${CEN_NET_REJECT_HOST[0]}.$CEN_NET_DOMAIN" "${CEN_NET_REJECT_HOST[0]}"
    data=("127.0.0.1       localhost.localdomain   localhost$self" ''
          "${nov6}# The following lines are desirable for IPv6 capable hosts"
          "${nov6}::1     localhost ip6-localhost ip6-loopback"
          "${nov6}ff02::1 ip6-allnodes"
          "${nov6}ff02::2 ip6-allrouters" ''
          "# Routers ..." "${drtr[@]}" ''
          "# Servers ..." "${dsvr[@]}" ''
          "# Address that cannot be reached" "${drej[@]}"
          "# Computers ..." "${dhst[@]}" ''
          "# Fake entries point to badhost ..." "${dfak[@]}"
    )
    netfile -h -v data -- "/etc/hosts_$1"
}

# ------------------------------------------------------------------------------
# Write the /etc/dnsmasq.d/xxx_dnsserv drop-in: [/dev/<iface>] <server>|+|-...
# ------------------------------------------------------------------------------
# This routine is used to:
#       write a '/etc/dnsmasq.d.<mode>/<domn>_dnsserv' file
#       restart dnsmasq
#
#
#
#   centaurikerberos server     TODO:  centaurinetgen - centaurinetcfg - centaurifilter
#   centautirouter open         # router mode only
#   centauri-master.target      # via centauriswitch, see /etc/default/centauriswitch
#
# dnsmasq configuration are only relevant for the following network modes:
#
#   master      -> dnsmasq.d.local (!)      # use AD/DC + router
#   slave       -> dnsmasq.d.slave          # use master + router
#   repeater    -> dnsmasq.d.repeater       # use resolv.conf (dhcp)
#   router      -> dnsmasq.d.router         # use resolv.conf (dhcp)
#
# By default these files a empty, e.g. dnsmasq will use '/etc/resolv.conf' to
# upstream DNS queries.
#
# Only a master server should disable '/etc/resolv.conf' and use localhost via
# loopback.
#
# Fall back to resolv.conf if 1st arg is 'none'.  There can be up to 3 <server>
# arguments, default is '-'.  If <server> is '-' a configured server is used
# (primary, sencodary, router).  If <server> is '+' an entry is pulled from the
# current resolv.conf
# ------------------------------------------------------------------------------
do_dnsmasq() {
    local ifce base serv rslv=1 nook
    if [ "${1::5}" = '/dev/' ] ; then               # eat interace argument
        ifce="@${1:5}" ; shift
    fi
    local mode="${1:--}"

    # no mode specified, autodetect master/slave/local
    if [ "$mode" = '-' ] ; then
        netoption 'dns' "$name" || return 2             # no dns configured

        if netquery MASTER ; then
            mode='master'
        elif netquery SLAVE ; then
            mode='slave'
        else
            mode='local'
        fi
    fi

### TODO and mode switch or route
    # do not run dnsmasq if computer was booted as 'switch'
  #  nettemp -s 'centauriswitch' || return 1             # source state file
  #  [ "$DAT_SWITCH_MODE" = 'switch' ] && return 1
  #      # mode 'router' uses dnsmasq
  #      [ "$DAT_SWITCH_MODE" = 'router' ] && return 0
  #          mode='local'
    trace -a -c 'dnsmasq mode' "$mode"

    case "$mode" in
    loc*)   base='.local' ; nook=1 ;;   # ok if not running
    mas*)   base='.local' ; rslv= ;;
    sla*)   base='.slave' ; rslv= ;;
    rep*)   base='.repeater' ;;
    rou*)   base='.router' ;;
    non*)   return ;;
    *)      invoke -e "Invalid 1st argument:" "$1" ; return 1
    esac

    # get an output folder (true for stdout and debug)
    if ! netpath -d "/etc/dnsmasq.d$base" ; then
        [ -n "$nook" ] && return 0
        invoke -e "No configuration folder:" "dnsmasq.d$base" ; return 1
    fi

    netconfig -f

    local xtxt xout="$_netpath/${CEN_NET_DOMAIN%%.*}_dnsserv"
    if [ -z "$_netpath" ] ; then
        xout=
    elif [ -f "${xout%_*}_static" ] ; then
        [ "$mode" = 'local' ] && return 0
        invoke -w "Static configuration:" "$xout" ; return
    fi

    ### using resolv.conf (no server arguments, not master) ###

    if [ -n "$rslv" -a $# -le 1 ] ; then
        xtxt="### using /etc/resolv.conf ###"
        netfile -h -v xtxt -- "$xout"
        return 1
        fi

    ### using localhost or server(s) ###

    if [ $# -le 1 ] ; then                          # got no server argument...
        local prim scnd
        # get names of master and slave ...
        if netquery -s prim MASTER ; then
            netquery -s scnd SLAVE
        elif netquery -s prim SLAVE ; then
            netquery -s scnd MASTER
        else
            prim='127.0.0.1' ; ifce=
        fi
        set -- - "$prim" "$scnd" "${CEN_NET_ROUTERS[@]}"
    fi

    local nuse=0 nrdy=0
    while [ $# -gt 1 ] ; do                         # generate dnsmasq opts...
        shift ; [ "${1:--}" = '-' ] && continue
        if [ "${1//[0-9]/}" = '...' ] ; then
            _nethost_ip="$1"
        else
            nethost -e -- "$1" || continue
        fi
        ((nrdy += 1))
        # do not include addresses of this host ...
        listsearch -i CEN_NET_ADDR_IPLIST -- "$_nethost_ip" && continue
        # limit to 3 nameservers
        [ "$nuse" -ge 3 ] && continue ; ((nuse += 1))
        serv+=$'\n'"server=$_nethost_ip$ifce"
    done

    if [ -z "$serv" ] ; then
        invoke -w "Got no name server"
        serv="# No known server"
    else
        message -a -p "Using %s of %s nameservers" "$nuse" "$nrdy"
    fi
    xtxt=('### (1) ignore /etc/resolv.conf ###' ''
          'no-resolv' ''
          '### (2) DNS server(s) to use ###' ''
          "$serv")
    netfile -h -v xtxt "$xout"
    [ -z "$CEN_OPT_OUTPUT" ] && do_restart -c 'dnsmasq' # (re)start if avtive
}

# ------------------------------------------------------------------------------
# block generic server name: <server>
# ------------------------------------------------------------------------------
do_notgen() {
    [ "${1%%.*}" = "$CEN_NET_SERVER_GEN" ] || return 0
    invoke -e $"Cannot use generic server name" ; return 1
}

# ------------------------------------------------------------------------------
# get override data, returns: DAT_OVER_RESOLV and DAT_OVER_GATEWAY
# ------------------------------------------------------------------------------
do_override() {
    [ -n "$CEN_OPT_FORCE" ] && return 1
    local args stat=0
    override -r - args || return 1
    set -f ; set -- $args ; set +f
    while [ $# -gt 0 ] ; do
        case "$stat-$1" in
        ?---)   stat=0 ;;
        0-res*) stat=1 ; DAT_OVER_RESOLV=() ;;
        1-*)    DAT_OVER_RESOLV+=("$1") ;;
        0-rou*) stat=2 ; DAT_OVER_GATEWAY=() ;;
        2-*)    DAT_OVER_GATEWAY+=("$1") ;;
        0-*)    warning "Invalid override command:" "$1"
                stat=9 ;;
        9-*)    ;;
        *)      _cen_abort "bad state:" "$stat"
        esac ; shift
    done
}

# ------------------------------------------------------------------------------
# helper to restart a service: [-c|-e] <name>
#
# Option:   -c      restart only if active
#           -e      restart only if enabled
# ------------------------------------------------------------------------------
do_restart() {
    if [ -n "$CEN_OPT_NOREST" ] ; then
        message -a "Service: $2 [restart disabled]"
        return 0
    fi

    local _rest _stat=0
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -c)   _rest='status' ;;
      -e)   _rest='enabled' ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    if [ -n "$_rest" ] && ! runservice "$_rest" "$1" ; then
        [ -z "$CEN_RUNSERVICE" ] && return 0
    else
        runservice restart "$1" ; _stat=$?
    fi
    message -a -c "Service restart" "$1 ${CEN_RUNSERVICE:-[not available]}"
    return $_stat
}

# ------------------------------------------------------------------------------
# Setup files: [<hostname> [<domain>]]
# ------------------------------------------------------------------------------
do_setup() {
    local allowed_nets="127.0.0.0/24 [::1] $CEN_NET_NETWORKS $CEN_NET_EXTERNAL [fe80::]/16"

    ___setup_allow() {
        local name args entr
        for name in "${!DAT_MAP_ALLOW[@]}" ; do
            args="${DAT_MAP_ALLOW[$name]}"
            if [ "$name" = '*' ] ; then
                entr='ALL:'
            else
                port=
                load_port "$name" port
                if [ -z "$port" ] ; then
                    message "Unknown service:" "allow $name $args"
                    continue
                fi
                entr="$port:"
            fi
            set -f
            for args in $args ; do
                if [ "$args" = '*' ] ; then
                    entr+=" $allowed_nets"
                else
                    entr+=" $args"
                fi
            done
            set +f
            echo "$entr"
        done
    }

    # create files ...

    netfile <<!EOF -h '/etc/hosts.allow'
$(___setup_allow)
!EOF

    netfile <<!EOF -h '/etc/hosts.deny'
# Disallow everything by default
ALL: ALL
!EOF

    local nets="$allowed_nets ${DAT_MAP_ALLOW['*']}"
    nets="${nets//\[/}" ; nets="${nets//\]/}"       # no brackets for samba
    netfile <<!EOF -h '/etc/samba/networks.conf'
# Disallow everything by default
hosts deny  = 0.0.0.0/0 ::0

# Grant access for configured networks
hosts allow = ${nets// \* / }
!EOF

    local hcfg host="${1:--}" domn="${2:-$CEN_NET_DOMAIN}"
    [ "$host" = '-' ] && fatal -t - "$host"
    hcfg=("kernel.domainname=$domn" "kernel.hostname=$host")
    netfile -h -v hcfg -- '/etc/sysctl.d/host+domain.conf'
    HOSTNAME="$host"                    # TODO ugly!

    local ipv4='#' ipv6='#'
    has_option 'ipv6' "$host" && ipv6= || ipv4=
    local ipf6="$ipv6"
    is_server "$host" || ipf6='#'
    netfile <<!EOF -h '/etc/sysctl.d/ipv4+ipv6.conf'
net.ipv4.ip_local_port_range=10000 65535

# 0:=disable  1:=allow  2:=prefer
${ipv6}net.ipv6.conf.all.use_tempaddr = 1
${ipv6}net.ipv6.conf.default.use_tempaddr = 1

# 0:= disable  1:=allow with forwarding off  2:=allow always
${ipv6}net.ipv6.conf.all.accept_ra = 2
${ipv6}net.ipv6.conf.default.accept_ra = 2

# set to one for radvd or if being a server
${ipf6}net.ipv6.conf.all.forwarding = 1

${ipv4}net.ipv6.conf.all.disable_ipv6 = 1
${ipv4}net.ipv6.conf.default.disable_ipv6 = 1
!EOF

    # do a full setup if a hostname is given

    [ -z "$1" ] && return
    [ -n "${DAT_MAP_IP[$host]}" ] || warning "No host statement for <hostname>:" "$host"

    netfile -v host -- '/etc/hostname'
    hcfg=("$host.$domn")
    netfile -v hcfg -- '/etc/mailname'

    if [ -z "$CEN_OPT_OUTPUT" ] ; then                  # real setup
        # migrate, fix things ...
        netlink -m -k -s '/etc/hosts' '_'

        message -c "Network setup" \
                "server='$CFG_SERVER_DEF'  router='$CEN_NET_ROUTER_DEF'  hostname='$host'"
        embed -i -v 'centaurinetgen' -H "$host" create  # interfaces, wpa, hostapd, dnsmasq.d
        do_linkhosts -f "${CFG_SERVER_DEF:-local}"

### TODO should this run after netgen (if at all)
### TODO does centaurisecrets do this if it finds a server?
        if has_nameserv "$host" ; then                      # setup for dnsmasq
            netresolv "$domn" - '127.0.0.1'
            do_dnsmasq - "${CEN_NET_SERVERS[@]}" "${CEN_NET_ROUTERS[@]}"
        fi

    elif [ "$CEN_OPT_OUTPUT" = '.' ] ; then             # clone, force full setup
        message -c "Name setup" \
                "server='$CFG_SERVER_DEF'  router='$CEN_NET_ROUTER_DEF'  hostname='$host'"
### TODO don't use -nm, centaurinetgen should check centauriswitch-setup-override
        embed -v 'centaurinetgen' -O . -H "$host" --nm=0 create
    else                                                # create real files
        embed -v 'centaurinetgen' -O "$CEN_OPT_OUTPUT" -H "$host" create
    fi
}

# ------------------------------------------------------------------------------
# action "config" - create server status: <role> <mode> <master>
# ------------------------------------------------------------------------------
actionConfig() {
    netconfig -f                # cannot run without config
    netserver -w "$@"
}

# ------------------------------------------------------------------------------
# action "dnsmasq" - set active DNS provider config: [<iface>] <mode> <addr>...
# ------------------------------------------------------------------------------
# Arguments:
#   <iface>     limit interface (kernel name), format is: /dev/<name>
#   <mode>      router|repeater|master|slave|local|none
#   <addr>      optional upstream DNS
#
# There is only one external to this action for modem dial-up. This action does
# not modify resolv.conf or switch any symlinks. Anyhow is restart a running
# instance of dnsmasq.service.
# ------------------------------------------------------------------------------
actionDnsmasq() {
    do_dnsmasq "$@"
    [ "$?" = 2 ] && error "DNS not enabled (see 'option dns ...')"
}

# ------------------------------------------------------------------------------
# action "edit" - run editor, validate and setup
# ------------------------------------------------------------------------------
actionEdit() {
    local errs cbak="$CEN_OPT_CONFIG.bak"
    copy -a -f -- "$CEN_OPT_CONFIG" "$cbak"
    while : ; do
        system -e -- editor "$CEN_OPT_CONFIG" || return
        if [ -z "$errs" ] && system -e -p -g 1 -- cmp "$CEN_OPT_CONFIG" "$cbak" ; then
            message "No changes made, no action taken"
            remove -- "$CEN_OPT_CONFIG.bak" ; return
        fi
        if embed "$CEN_NAME" validate nocache ; then
            actionSetup -
            error -t && return                      # no errors, done!
            errs=1                                  # need setup after undo
        fi
        confirm -n "Undo changes and quit" && break # exit edit loop
        error -c ; errs=1
    done
    move -f "$CEN_OPT_CONFIG.bak" "$CEN_OPT_CONFIG"
    error -c
    [ -n "$errs" ] && actionSetup -
}

# ------------------------------------------------------------------------------
# action "gateway" - set default route: [<gateway>|- [<iface>]]]
# ------------------------------------------------------------------------------
actionGateway() {
    do_config -u                # get/update config
    error -t || return

    # replace command arguments if there is an override file
    if do_override && [ -n "$DAT_OVER_GATEWAY" ] ; then
        warning "From override file:" "gateway ${DAT_OVER_GATEWAY[*]}"
        set -- "${DAT_OVER_GATEWAY[@]}"
    fi
    embed -v centauriroute -t gateway "${1:--}" "${2:--}"
}

# ------------------------------------------------------------------------------
# action "option" - list options: [<host>|-]
# ------------------------------------------------------------------------------
actionOptions() {
    local host="${1:--}" opts name desc list=()
    [ "$host" = '-' ] && host="$HOSTNAME"
    netconfig -f                                    # cannot run without config
    if ! nethost "$host" ; then
        invoke -e "Host unknown:" "$host" ; return
    fi
    for opts in "${CEN_NET_OPTIONS[@]}" ; do        # loop over options
        name="${opts%% *}"
        has_option "$name" "$host" || continue

#### option  hotplug       ether-* wlan-*

        case "$name" in
        addc)   desc="provides AD/DC service" ;;
        alien)  desc="firewall: blocked device" ;;
        apoint) desc="network: enable access point config" ;;
        auto)   desc="use 'smart' mode with nm or 'simple' otherwise" ;;
        coun*)  desc="WLAN: ISO country must be set" ;;
        dhcp)   desc="provides DHCP service" ;;
        dns)    desc="provides DNS service" ;;
        ether)  desc="interfaces: interface is ethernet (cable)" ;;
        exte*)  desc="network: enable extender config" ;;
     #   hotp*)  desc="" ;;
        friend) desc="firewall: friendly host" ;;
        ipv6)   desc="enable IPv6 protocol" ;;
        ldap)   desc="provides LDAP service" ;;
        manual) desc="not managed by centaurinetcfg/centauriswitch" ;;
        mdns)   desc="" ;;
        metr*)  desc="interface IP metric priority" ;;
        mobile) desc="mobile device, notebook" ;;
        nm)     desc="use NetwokManager" ;;
        nofir*) desc="firewall: disable" ;;
        nomac)  desc="firewall: don't check MAC addresses" ;;
        ntp)    desc="provides NTP time service" ;;
        other)  desc="sub-net <other> is external" ;;
        phone)  desc="mobile phone or tablet" ;;
        player) desc="media player, tv" ;;
        proxy)  desc="provides HTTP proxy service" ;;
        radv)   desc="does IPv6 router advertisments" ;;
        repea*) desc="network: enable repeater mode" ;;
        router) desc="network: enable router mode" ;;
        simple) desc="network: enable simple mode" ;;
        smtp)   desc="provides SMTP service" ;;
        static) desc="network: enable static mode" ;;
        switch) desc="network: enable switch mode" ;;
        sysdn*) desc="network: use systemd interface naming" ;;
        smtp)   desc="provides Samba basic service" ;;
        thing)  desc="firewall: IOT device" ;;
        track*) desc="firewall: use connection tracking" ;;
        trust*) desc="firewall: make this host trusted" ;;
        wlan)   desc="interfaces: interface is wlan (wifi)" ;;
        wol)    desc="interfaces: enable Wake-On-LAN" ;;
        *)      desc=
        esac
        printf -v desc '    %-13s %s' "'$name'" "$desc"
        list+=("$desc")
        #message -a " $name"
    done
    message -c "Network options" "$host"
    txtsort -i list -a list
    outdata -a -o list
    netquery -s desc 'connect' "$host"
    message -i -c "Connection mode" "$desc"
    netquery -s desc 'class' "$host"
    message -i -c "Computer class" "$desc"
}

# ------------------------------------------------------------------------------
# action "resolv" - update '/etc/resolv.conf'
# ------------------------------------------------------------------------------
# call  (1) none                                # create empty resolv.conf
#       (2) default                             # create default resolv.conf
#       (3) local                               # create resolv.conf for localhost
#       (4) <domain>    [<serv>|-]...           # pass arguments to netresolv()
#       (5) status                              # show file content
#       (6) domain                              # set domainname from resolv.conf
#
# args: <ifce>      interface name (like 'wlan0') or path (like '/dev/wlan0')
#
# By default dnsmasq is expected as DNS server. It polls '/etc/resolv.conf' by
# default, so no restart is required after updates.
#
# actionResolv: does DNS resolver configuration
# actionSwitch: does DNS provider configuration
# ------------------------------------------------------------------------------
actionResolv() {
    # helper to show status
    ___resolv_cat() {
        local line emty=$"# file is empty"
        message "$1:"
        if [ ! -r "$1" ] ; then
            message -i $"# cannot be read" ; return
        fi
        while read line ; do
            [ -z "$line" -o "${line::1}" = '#' ] && continue
            message -i -- "$line" ; emty=
        done <"$1"
        [ -n "$emty" ] && message -i "$emty"
    }

    case "$1" in
    *.*)    ;;
    dom*)   # set domainname from resolv.conf
            if [ -z "$2" ] && netresolv -r ; then
                set -- "$1" "$_netresolv"
            fi
            if [ "${2:--}" = '-' ] ; then
                error $"Domain name is unknown" ; return
            fi
            message -a $"Seting domain name:" "$2"
            writeline -e -o '/proc/sys/kernel/domainname' -t -- "$2"
            return ;;
    sta*)   # display status
            netconfig -f
            ___resolv_cat '/etc/resolv.conf'
            ___resolv_cat "/etc/dnsmasq.d/${CEN_NET_DOMAIN%%.*}_dnsserv"
            return
    esac

    # replace command arguments if there is an override file
    if do_override && [ -n "$DAT_OVER_RESOLV" ] ; then
        warning $"From override file:" "resolv ${DAT_OVER_RESOLV[*]}"
        set -- "${DAT_OVER_RESOLV[@]}"
    fi

    case "$1" in
    *.*)        netresolv "$@" ;;                   # custom config
    loc*)       netresolv - - '127.0.0.1' ;;        # local DNS server
    non*)       netresolv ;;                        # empty resolv.conf
    def*)       netresolv - - ;;                    # default resolv.conf
    *)          invoke -e - "$*"
    esac
}

# ------------------------------------------------------------------------------
# action "setup" - create host files: [<hostname>]
#
#   mode 1: have argument or --output
#           full update
#   mode 2: no "$CEN_PERSISTENT/centaurinetcfg"
#           update cache only (unless argument given)
#   mode 3: valid cache, no argument
#           do nothing
# ------------------------------------------------------------------------------
actionSetup() {
    if [ -n "$1" -o -n "$CEN_OPT_OUTPUT" ] ; then
        :
    elif [ ! -e "$CEN_NET_FILE_CONF" ] ; then
        actionValidate cache ; return
    elif [ "$CEN_NET_FILE_CONF" -nt "$CEN_DEFAULT/centaurinetcfg" ] ; then
        message $"No update (cache is current)" ; return
    fi

    local domn host="${1:--}" md5x md5y
    [ "$host" = '-' ] && host="$HOSTNAME"
    domn="${host#*.}" ; [ "$domn" = "$host" ] && domn=
    host="${host%%.*}"

    do_config -c "$host" "$domn"        # create new config cache
    do_notgen "$host"                   # disallow generic server name
    error -t || return

    # on MASTER check hosts file to run dns update if needed
    if netquery MASTER && netoption 'addc' "$HOSTNAME" ; then
        [ -e '/etc/hosts_local' ] && sysrun -e -p -s md5x -- md5sum '/etc/hosts_local'
        trace -a "Current hosts file md5sum:" "${md5x:--}"
    fi

    # create hosts files
    local name md5x md5y
    for name in 'local' "${CEN_NET_SERVERS[@]}" ; do
        do_hosts "$host" "$name"
    done

    # setup (full if hostname is given)
    do_setup "$host" "$domn"

    # upd dns if hosts file changed
    if [ -n "$md5x" ] ; then
        sysrun -e -p -s md5y -- md5sum '/etc/hosts_local'
        if [ "$md5x" != "$md5y" ] ; then
            message -- $"Updating Samba DNS (can be slow) ..."
            embed -i -v centaurinetdns -y
        fi
    fi
}

# ------------------------------------------------------------------------------
# action "status"
# ------------------------------------------------------------------------------
actionStatus() {
    netconfig -f                        # cannot run without config
    local svrn svra
    if [ -n "$CEN_NET_SERVER_GEN" ] ; then
        set -- $(getent hosts $CEN_NET_SERVER_GEN)
        svra="$1" ; svrn="${2%%.*}"
        [ "$svrn" = "$CEN_NET_SERVER_GEN" ] && svrn='-'
    fi

    ___status_print() {
        local idnt
        [ "$1" = '-i' ] && idnt="\n                            " && shift
        printf "$idnt%-15s %-15s %-15s %-15s" "$@"
    }

    ___status_server() {
        local name
        for name in "${CEN_NET_SERVERS[@]}" ; do
            nethost "$name"
            ___status_print -i "$name" "$_nethost_ip"
        done
    }

    ___status_router() {
        local name
        for name in "${CEN_NET_ROUTERS[@]}" ; do
            nethost "$name"
            ___status_print -i "$name" "$_nethost_ip"
        done
    }

    ___status_homedns() {
        local name opti
        for name in "${CEN_NET_HOMEDNS[@]}" ; do
            ___status_print $opti $name ; opti='-i'
        done
    }

    create -c <<!EOF

    Data from $CEN_NET_FILE_CONF:

        CEN_NET_DOMAIN      $(___status_print $CEN_NET_DOMAIN "[${#CEN_NET_HOSTS[@]} hosts]" \
                              "$CEN_NET_NETMASK ($CEN_NET_NETBITS)")
        CEN_NET_SERVER_...  $(___status_print $CEN_NET_SERVER_GEN  [$svrn])$(___status_server)
        CEN_NET_ROUTER_...  $(___status_print $CEN_NET_ROUTER_GEN [$CEN_NET_ROUTER_DEF])$(___status_router)
        CEN_NET_HOMEDNS...  $(___status_homedns)
        CEN_NET_ADDR_METHOD $(___status_print ${CEN_NET_ADDR_METHOD:-<unknown>} "[$HOSTNAME]")
        CEN_NET_ADDR_IPLIST $(___status_print ${CEN_NET_ADDR_IPLIST[@]})

!EOF
    if [ -n "$CEN_NET_NETWORKS" ] ; then
        local inet iext
        netmask "$CEN_NET_NETWORKS" "${CEN_NET_EXTERNAL%/*}" && iext="(subnet)"
        netmask "$CEN_NET_EXTERNAL" "${CEN_NET_NETWORKS%/*}" && inet="(subnet)"
        create -c <<!EOF
        CEN_NET_NETWORKS    $(___status_print "$CEN_NET_NETWORKS" "$inet")
        CEN_NET_EXTERNAL    $(___status_print "$CEN_NET_EXTERNAL" "$iext")

!EOF
    fi

    if ! netserver ; then
        echo -e "    No network status file: $CEN_NET_FILE_STAT\n"
        return
    fi
    create -c <<!EOF
    Data from $CEN_NET_FILE_STAT:

        CEN_NET_ROLE        $CEN_NET_ROLE
        CEN_NET_MODE        $CEN_NET_MODE
        CEN_NET_SERVER      $CEN_NET_SERVER
        CEN_NET_MASTER      $CEN_NET_MASTER

!EOF
}

# ------------------------------------------------------------------------------
# action "switch" - set active host name service config: [@<server>|local]
# ------------------------------------------------------------------------------
# This action configures /etc/dnsmasq.d/xxx_dnsserv, symlinks /etc/hosts and
# updates ... It does not alter '/etc/resolv.conf', see actionResolv().
#
#   like actions dnsmasq and resolv combined
#
#       @<serv>             # server name
#       local
#       status
#
# ------------------------------------------------------------------------------
actionSwitch() {
    netconfig -f                                    # get config or die
    local host
    case "$1" in
    @*)     host="${1:1}" ; shift
            ;;
    *.*)    host="$1" ; shift                       # IPv4 of fqdn
            ;;
    loc*)   set -- 'local' ;;

    sta*)   netpath -r '/etc/hosts' ; resolve -m -- "$_netpath"
            local fsta ; [ -e "$CEN_RESOLVE" ] && fsta=$"OK" || fsta=$"missing"
            message -a -c -p $"Hosts file" '%-39s (%s)' "$CEN_RESOLVE" "$fsta"

            netpath -r '/etc/dnsmasq.d' ; resolve -m -- "$_netpath"
            [ -e "$CEN_RESOLVE" ] && fsta=$"OK" || fsta=$"missing"
            message -a -c -p $"DNS config" '%-39s (%s)' "$CEN_RESOLVE" "$fsta"

            runservice status 'dnsmasq'
            message -a -c $"Service dnsmasq" "${CEN_RUNSERVICE:-[not available]}"

            netresolv -r nameserver
            message -a -c $"Nameserver" "${_netresolv[1]}"
            return
            ;;
    *)      invoke -e - "$1"
    esac

    if [ -n "$host" ] ; then
        nethost -e -- "$host" ; host="$_nethost_name"
        set -- "$host"
        do_notgen "$host"                           # disallow generic server name
    fi
    error -t || return

    if [ -z "$host" ] ; then
        netresolv - - "${CEN_NET_ROUTERS[@]}"
    elif [ "$host" = "${CEN_NET_SERVERS[0]}" ] ||
         [ "$host" = "${CEN_NET_SERVERS[1]}" ] ; then
        netresolv -d "$host" - "${CEN_NET_SERVERS[@]}" - "${CEN_NET_ROUTERS[@]}"
    else
        netresolv - "$host" - "${CEN_NET_ROUTERS[@]}"
    fi

   do_linkhosts -f "$host"
   do_dnsmasq -                                    # handle config and restart
}

# ------------------------------------------------------------------------------
# validate the config file: [cache|nocache|list]
# ------------------------------------------------------------------------------
actionValidate() {
    local coca args='OK'
    case "${1:-noc}" in
    cac*)   coca=1 ;;
    lis*)   DAT_LIST=1 ;;
    noc*)   ;;
    *)      invoke -a 'cache|nocache|list' ; return
    esac
    do_config -v
    [ -n "$DAT_LIST" ] && return

    error -t || args="Error(s) found"
    message "File '$CEN_OPT_CONFIG' [$DAT_CONFIG_LINES lines]: $args"
    error -t || return

    if [ "$CEN_NET_CONFIG" = "$DAT_UNMANAGED" ] ; then
        message -i "This configuration is not managed (no server/router)"
    else
        local name="'${CFG_SERVER_DEF}.$CEN_NET_DOMAIN'"
        [ -n "$CFG_SERVER_DEF" ] || name="(none)"
        message -i -p "Server %-10s =>  %s" "'$CEN_NET_SERVER_GEN'" "$name"
        message -i -p "Router %-10s =>  '%s'" "'$CEN_NET_ROUTER_GEN'" \
                      "${CEN_NET_ROUTER_DEF}.$CEN_NET_DOMAIN"
    fi
    [ -n "$coca" ] && do_coca
}

# ------------------------------------------------------------------------------
# Option parsing
# ------------------------------------------------------------------------------
options() {
    case "$CEN_ACTION" in
    '') [ "${CEN_SVC_SYSLOG:-0}" != 0 ] && embed -m '_centauri_bash_svc'
        [ "${CEN_OPT_OUTPUT:-/}" != '/' ] && syssetup -o "$CEN_OPT_OUTPUT"
        ;;

    -l|--sys*)
        optarg 'syslog'  CEN_SVC_SYSLOG  '[012]' ;;

    -C|--con*)
        optarg 'config'  -           -t ;;                  # any text
    -N|--nor*)
        optarg 'norest'  -              ;;                  # simple flag
    -O|--out*)
        optarg 'output'  -           -t ;;                  # any text
    -R|--rou*)
        optarg 'router'  -           -t ;;                  # any text
    -S|--ser*)
        optarg 'server'  -           -t ;;                  # any text
    esac
}

# ------------------------------------------------------------------------------
# Action parsing
# ------------------------------------------------------------------------------
actions() {
    case "$CEN_ACTION" in

    con*)
        invoke -r 'config'   -         0 3 ;;               # 0...3 args
    dns*)
        invoke -r 'dnsmasq'  -         1 + ;;               # at least 1 arg
    edi*)
        invoke -s 'edit'     -         0   ;;               # no arg
    gat*)
        invoke -r 'gateway'  -         0 2 ;;               # 0...2 args
    opt*)
        invoke    'options'  -         0 1 ;;               # one optional arg
    res*)
        invoke -r 'resolv'   -         1 + ;;               # at least 1 arg
    set*)
        invoke -r 'setup'    -         0 1 ;;               # one optional arg
    sta*)
        invoke    'status'   -         0 ;;                 # no arg
    swi*)
        invoke -r 'switch'   -         1 ;;                 # one arg
    val*)
        invoke    'validate' -         0 1 ;;               # one optional arg
    esac
}

# ------------------------------------------------------------------------------
# Print usage info
# ------------------------------------------------------------------------------
usage() {
    usageset \
        -o '-l --syslog  [012]'   $"control output to syslog (0:no 1:also 2:only)" \
        -o - \
        -o '-C --config  <file>'  $"configuration  (default $CEN_OPT_CONFIG)" \
        -o '-N --norestart'       $"do not restart nscd/dnsmasq" \
        -o '-O --output  <fldr>'  $"modify output locations                 (default: /)" \
        -o '-R --router <router> '$"router name       (default is 1st configured router)" \
        -o '-S --server <server> '$"server name       (default is 1st configured server)" \

    usageset \
        -a 'config  [<role>|- [<mode> [<master>|-]]]' \
        -a -                      $"write status files in $CEN_TRANSIENT" \
        -a 'dnsmasq [/dev/<iface>] router|repeater|master|slave|local|none [<addr>...]' \
        -a -                      $"write dnsmasq upstream provider configuration file" \
        -a 'edit'                 $"edit configuration, run 'validate' and 'setup'" \
        -a 'gateway [<gateway>|-[<iface>]]]' \
        -a -                      $"set/remove the default gateway" \
        -a 'options [<host>]'     $"show configuration options" \
        -a 'resolv  <fqdn> ...'   $"pass arguments to function netresolv()" \
        -a 'resolv  default|local|none' \
        -a -                      $"update dnsmasq dns server config, restart dnsmasq" \
        -a 'resolv  domain [<name>]' \
        -a -                      $"set domain name, use '/etc/resolv.conf' for default" \
        -a 'resolv  status'       $"show '/etc/resolv.conf' and dnsmasq config" \
        -a 'setup   [<hostname>] '$"create config files, full setup with <hostname>" \
        -a 'status'               $"show the current status" \
        -a 'switch  @<server>'    $"switch '/etc/hosts' and write '/etc/resolv.conf'" \
        -a 'switch  local'        $"switch '/etc/hosts' and write '/etc/resolv.conf'" \
        -a 'validate [cache|nocache]' \
        -a -                      $"validate config, optionally generate cache file" \
        -a 'validate list'        $"validate and list config" \

    usagecat << !EOF
$CEN_USE_HEADER

$CEN_USE_OPTIONS

$CEN_USE_ACTIONS

arguments:
       <dns>                server ip  -or-  '-' pull default server  -or-  '+'
                            pull from resolv.conf
       <fldr>               any folder -or- '-' for stdout -or- '/' to install
       <fqdn>               qualified domain name
       <gateway>            name to override the router name -or- '-' to remove
       <hostname>           host (opt. with domain)  -or-  '-' for current name
       <iface>              interface name like eth0, wlan0 ...
       <netmask>            any netmask, 0.0.0.0 for '-' or if missing
       <router>             a configured router name
       <server>             a configured server name
!EOF
    usagecat -v "More:  Use -- to show details for 'setup' and" \
                "'config' actions." << !EOF
setup: When action 'setup' is used with a <hostname> a full set of configuration files
       will be generated:

       /etc/hostname                            (setup [with <hostname>])
       /etc/hosts.allow                         (setup)
       /etc/hosts.deny                          (setup)
       /etc/hosts_<mode>                        (setup)
       /etc/mailname                            (setup [with <hostname>])
       /etc/network/interfaces                  (setup [with <hostname>])
       /etc/resolv.conf                         (setup, server)
       /etc/system.d/domain                     (setup)
       /etc/samba/networks.conf                 (setup)
       /etc/sysctl.d/host+domain.conf           (setup)
       /etc/sysctl.d/ipv4+ipv6.conf             (setup)
       $CEN_PERSISTENT/centaurinetcfg  (setup, switch, config)
       $CEN_TRANSIENT/network_proxy    (switch, config)
       $CEN_TRANSIENT/network_status   (switch, config)

config:
       The arguments for action 'config' are:

         <role>              the computer's role  -or-  '-' to delete status
                             possible values: WORKSTATION|PRIMARY|SECONDARY|UNKNOWN
         <mode>              the current network mode
                             possible values: MASTER|SLAVE|CLIENT|GUEST|SINGLE|UNKNOWN
         <master>            the server to be used  -or-  '-' for default server

       Examples for 'config':

       # delete status files, create (void) status files ...
       $CEN_NAME config -                       # delete status files
       $CEN_NAME config                         # write void status files
       $CEN_NAME config PRIMARY MASTER alpha1   # a full configuration

resolv:
       Used to rewrite '/etc/resolv.conf', mostly called by centauriswitch

       $CEN_NAME resolv default                 # use configurated domain and dns
       $CEN_NAME resolv ppp0 + + + 8.8.8.8      # use interface ppp0 only
       $CEN_NAME res worms.home none 10.33.4.1  # any iface, no dnsmasq, use domain
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
