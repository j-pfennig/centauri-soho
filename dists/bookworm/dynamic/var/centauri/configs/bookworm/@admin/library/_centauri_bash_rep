#!/usr/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_rep = centauri-bash-lib: Monitoring, Overrides and Repository
#
# Call:     . _centauri_bash_rep [-m]
#
# Options:  -m      execute "monitor init"
#
# The module implements exactly three public functions:
#
#,  [[monitor()]]       'tool start' monitoring
#,  [[override()]]
#,  [[repository()]]
#
# Copyright Dr. J. Pfennig (c) 2024-2025
# ------------------------------------------------------------------------------

CEN_MODULES['_centauri_bash_rep']='0.03:6'

embed -c '_centauri_bash_ext'               # dependency

CEN_REP_DKEY=                               # distribution key, see 'distro'

CEN_REP_HOOK_MAIN=
CEN_REP_HOOK_QUIT=
CEN_REP_HOOK_OPTIONS=
CEN_REP_HOOK_ACTIONS=

# ------------------------------------------------------------------------------
# monitor - init 'tool start' monitoring and default logger implementation
#
# Call:     monitor <kind> <text>...
#
# Arguments:<kind>      kind of hook: init|main|args|opts|quit|exit
#           <text>      text to be logged
#
# Variables:CEN_HOOK_MONITOR    hook used to log something
#           CEN_MONITOR_CALL    call-back to override log implementation
#           CEN_MONITOR_FILE    enable only if this is a writable file
#           CEN_MONITOR_MASK    enable bit mask 1:main 2:acts 4:args 8:quit
#
#
#+Proxy:    The library proxy can be used to configure system wide logging
#           by adding two lines of code, see "/etc/default/centauri_bash_lib":
#
#.          [proxy]
#.          °   # non-comment lines get copied verbatim into the proxy
#.          °   CEN_MONITOR_FILE=/var/centauri/persistent/centauri-monitor
#.          °   [ -w "$CEN_MONITOR_FILE" ] && CEN_MONITOR_MASK=1
#
#+Tools:    The systemd service script of [[centaurisysinit]] truncates the
# log file at early boot time.
#
#+          Use [[centauriinfo]] to display log data with optional filtering and
# high-lighting.
#
#+The write access permission controls which user's 'tool starts' get logged.
#
#+The main library module loads this module with option -m to initialize the
# monitor if CEN_MONITOR_MASK is set. The default implementation just writes
# the argumnents to CEN_MONITOR_FILE:
#
# °     <epochseconds> <ppid> <pid> <user> <text>...
#
#+The predefined <kind> values are implemented by the library itself. Additional
# log entries can be generated calling monitor() directly of via CEN_HOOK_MONITOR.
#
#+After initialization CEN_MONITOR_MASK can be modified to select <kind> or to
# suspend monitoring.
# ------------------------------------------------------------------------------
monitor() {
    # initialization: for security resons hook only a funtion ...
    if [ "$CEN_HOOK_MONITOR" = ':' ] ; then
        if [ -n "$CEN_MONITOR_CALL" ] ; then
            is_function -f "$CEN_MONITOR_CALL" && CEN_HOOK_MONITOR="$CEN_MONITOR_CALL"
        else
            CEN_HOOK_MONITOR='cen_monitor_call'
        fi
        [ -z "$CEN_MONITOR_FILE" ] && CEN_MONITOR_FILE="$CEN_PERSISTENT/monitor"
        if ! [ -w  "$CEN_MONITOR_FILE" ] ; then
            warning -c $" disabled" "Cannot write:" "$CEN_MONITOR_FILE"
            CEN_MONITOR_MASK= ; return 1
        fi

        if ((CEN_MONITOR_MASK & 1)) ; then
            eval 'cen_monitor_main() { $CEN_HOOK_MONITOR main "$@" ; shift ; $CEN_REP_HOOK_MAIN "$@" ; }'
            context -h CEN_HOOK_MAIN CEN_REP_HOOK_MAIN  'cen_monitor_main'
        fi
        if ((CEN_MONITOR_MASK & 2)) ; then
            eval 'cen_monitor_acts() { $CEN_HOOK_MONITOR acts "$@" ; shift ; $CEN_REP_HOOK_ACTIONS "$@" ; }'
            context -h CEN_HOOK_ACTIONS CEN_REP_HOOK_ACTIONS 'cen_monitor_acts'
        fi
        if ((CEN_MONITOR_MASK & 4)) ; then
            eval 'cen_monitor_opts() { $CEN_HOOK_MONITOR opts "$@" ; shift ; $CEN_REP_HOOK_OPTIONS "$@" ; }'
            context -h CEN_HOOK_OPTIONS CEN_REP_HOOK_OPTIONS 'cen_monitor_opts'
        fi
        if ((CEN_MONITOR_MASK & 8)) ; then
            eval 'cen_monitor_quit() { $CEN_HOOK_MONITOR quit "$@" ; shift ; $CEN_REP_HOOK_QUIT "$@" ; }'
            context -h CEN_HOOK_QUIT CEN_REP_HOOK_QUIT 'cen_monitor_quit'
        fi
    elif [ "${CEN_HOOK_MONITOR:--}" = '-' ] ; then
        return 1
    fi
    $CEN_HOOK_MONITOR "$@"
}

cen_monitor_call() {
    # default implementation
    [ -z "$CEN_MONITOR_MASK" ] && return 1
    local name="${USER:-${LOGNAME:-$EUID}}"
    [ "$name" = 0 ] && name='root'
    echo "$EPOCHSECONDS" "$PPID" "$$" "${name:--}" "$CEN_NAME" "${@@Q}" >> "$CEN_MONITOR_FILE"
    return 0

}

# ------------------------------------------------------------------------------
# override - mechanism to pass extra information to scripts
#
# Call:     (1) override [-b <base>] [-f] -c <name>|-|-- <word>...
#           (2) override [-b <base>]      -d <glob>|-|--
#           (3) override [-b <base>]      -l <glob>|-|-- <vnam>
#           (4) override [-b <base>] [-f] -r <name>|-|-- <varr>
#           (5) override [-b <base>]      -p <name>|-|-- [<vnam>]
#
#-      Form (1) creates a file named "$CEN_PERSISTENT/<name>-override" with
#-      °        <value> as content -or- "<base>/<name>-override".
#-      Form (2) delete one or more files created by (1).
#-      Form (3) returns a list of matching ''override'' names (**not file paths**).
#-      Form (4) is used to read the content of an ''override'' file into variable
#-      °        <vnam>.
#-      Form (5) return the file path and **TRUE** if existing or **FALSE** if not.
#
# Options:  -b  base (optional prefix for path)
#           -c  create an override file
#           -d  delete override files by name (glob expression match)
#           -f  make errors fatal
#           -l  get list of override names (glob expression match)
#           -p  return a path, check if existing
#           -r  read file
#
# Arguments:<base>      path that overrides $CEN_PERSISTENT
#           <glob>      bash glob expression
#           <name>      file name part (use '-' for script name)
#           <varr>      name of an array that returns names (**not file paths**)
#           <vnam>      name of a variable that returns the file content
#           <word>      string to be written (joined to a single line)
#
#+Form (2) and (3) do nothing if no ''override'' file exists. Only read or write
# errors get reported.
#
#.Examples: override -c -- hello world
#.          override -p && message "have override"
#.          override -r -- data && message "data: $data"
#
#.          override -c 'other' -- 'hi!'
#.          override -p 'other' path && message "see: $path"
#.          override -d 'other'
#
#.          override -l 'test*' list
#.          override -d 'test*'
# ------------------------------------------------------------------------------
override() {
    local _name="$CEN_NAME" _base="$CEN_PERSISTENT" _fopt _ferr='-e'
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   shift ; _base="${1%/}" ;;
      -f)   _ferr="$1" ;;
      -[cdlpr])
            _fopt="$1" ; shift
            [ -z "$1" -o "${1::1}" = '-' ] || _name="$1" ;;
      *)    _cen_abort - "$1"
      esac
      [ "$1" = '--' ] && { shift ; break ; }
      shift
    done

    _file="$_base/${_name//[[:space:]]/}-override"
    case "$_fopt" in
    -c) writeline $_ferr -c - -o "$_file" -t -- "$*" ;;
    -d) remove -- "$_base/"${_name//[[:space:]]/}'-override' ;;
    -l) local _list
        local -n _cen_override_var="$1" ; _cen_override_var=()
        matchpath -e -a _list -- "$_base/"${_name//[[:space:]]/}'-override'
        for _name in "${_list[@]##*/}" ; do
            _cen_override_var+=("${_name%-override}")
        done ;;
    -p) [ -n "$1" ] && printf -v "$1" '%s' "$_file"
        [ -f "$_file" ] ;;
    -r) readline $_ferr -i "$_file" -s "$1" ;;
    esac
    return                                          # return status
}

# ------------------------------------------------------------------------------
# Override Arguments + Passing extra information to Scripts
#
#+General:  This mechanism manages files in "$CEN_PERSISTENT" using file
# names built like: "<script-name>-override". The target script can implement
# whatever it wants to handle information read from such a file. Typically a
# script will capture a set of action verbs and replace matching verbs by data
# read from the override file.
#
#+A simple implementation of the file handling mechanics is provided by function
# [[override()]].
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Override Options + Overriding option defaults via "/etc/default"
#
#+General: The framework can source a bash script at early startup (before parsing
# the command line). This mechanism is intended to set option defaults and is
# activated by passing option '-o' to the proxy.
#
#+Whilst the sourced code can do whatever is likes to do, it is recommended to
# follow this example:
#
#.  PATH+=":${0%/*}" . _centauri_bash_lib -a -d -o - '0.01' || exit 2
#.
#.  DAT_DEF_BASE="/opt/$CEN_NAME"           # default for option --base
#.  CEN_OPT_BASE=                           # option argument value
#.
#.  # ...
#.
#.  options() {
#.  case "$1" in
#.  °   '')     [ -z "$CEN_OPT_BASE" ] && CEN_OPT_BASE="$DAT_DEF_BASE"
#.  °           ;;
#.  °   -B|--bas|--base)
#.  °           optarg 'base'   -   -t
#.  °           ;;
#.  °   # ...
#.  esac
#.
#.  # ...
#.
#.  main "$@" ; quit
#
#+For a script named "mytool" that follows the example above, the content of file
# "/etc/default/mytool" could be:
#
#. # overriding the default for option --base
#. DAT_DEF_BASE='/somewhere/$CEN_NAME"
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# repository - Repository basic operations
#
# Call:     (1) repository -d|-u   **escape** <vnam> <name>
#           (2) repository [-l|-q] **folder** <vnam> <dist> <conf> [<host>|-|+|**@** [<base>]]
#           (3) repository [-f]    **distro** <anam> [<dist>]
#           (4) repository [-b|-w] **locate** <vnam> <file> [<base> [<dkey>]]
#
#           (1) **Decorate/undecorate repository file names**
#               This command implements the escape rules for file names
#
#           (2) **Get repository folder by distribution and instance**
#               Returns the base folder for (2 arguments), the shared folder
#               ('@' as 3rd argument), or a private folder ('+' for $HOSTNAME)
#
#           (3) **Get an OS distribution information array**
#               Returns an array of: <dkey> <fkey> <dfam> <dist>
#
#           (4) **Locate a repository file by path and vendor key**
#               Tries <dkey> as first and 'a' for any second attempt. If no <dkey>
#               is passed it calls (3) to get one. Uses '$CEN_ROOT' if <base> is
#               empty or '-'. Unless option -b is given it searches the folders
#               "private" and "shared", which should be symlinks, see (2).
#
# Variables:<vnam>  name of a variable to receive a result value
#           <anam>  name of an array  to receive a result
#           <dkey>  distro key: d=debian r=raspbian s=suse t=termux u=ubuntu
#           <fkey>  family key: d=debian r=raspbian s=suse d=termux d=ubuntu
#           <dfam>  family name: 'debian' or 'suse'
#           <dist>  distribution name: debian|raspbian|termux|ubuntu|suse
#           <conf>  a configuration name
#           <file>  full path of file to be located
#           <base>  overrides '$CEN_ROOT'
#
# Options:  -b  search <base> path only
#           -d  decorate
#           -l  create a symlink in $CEN_ROOT
#           -q  quiet, no error messages
#           -u  undo '-d' decoration
#           -w  write state file, see [[sysversion()]]
#
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Repository + The Centauri Repository Structure
#
# Terminology:
#,- <<Main Repository>>     exactly one instance per domain at the primary server
#,- <<Master Repository>>   a clone of the main repository containing all data
#,- <<Local Repository>>    sub-set of main containing only data of the local host
#,- <<Staging Repository>>  intermediate at the primary server for security reasons
#,- <<Distribution>>        a distribution nick name like 'bookworm' or 'trixie'
#,- <<Configuration>>       a local config like: 'centauri', 'worms' or 'trixies'
#
#+General:
# The repository is a data tree and closely related to centauri-bash-lib but not
# a part of it. Anyhow the library documentation is a good place to briefly describe
# its structure. Data is organized as folders and files around three main axes:
#
#,      - <<by distribution>>   like debian/raspbian bookworm, debian trixie or others
#,      - <<by configuration>>  instances of configurations of computers in a network
#,      - <<by computer>>       machine dependent configurations
# °
#- $CEN_ROOT                        # the installation root
#- °  ├── configs                   # the repository part ...
#- °  │   ├── <dist>                # a distribution, example: bookworm
#- °  │   │   ├── @admin            # non-configuration dependent things ...
#- °  │   │   │   ├── library       # centauri-bash-lib bash code
#- °  │   │   │   ├── locale        # centauri-bash-lib translations
#- °  │   │   │   ├── systemd       # systemd services and configurations
#- °  │   │   │   ├── tools         # centauri-tools bash code
#- °  │   │   │   └── ...
#- °  │   │   ├── <conf>            # a configuration instance, example: worms
#- °  │   │   │   ├── @shared       # configurations shared be most computers
#- °  │   │   │   │   ├── <path>    # a shared configuration file
#- °  │   │   │   │   └── ...       # other shared configuration files
#- °  │   │   │   ├── <host>        # configuration of a specific computer
#- °  │   │   │   │   ├── <path>    # a private configuration file
#- °  │   │   │   │   └── ...
#- °  │   │   │   └── ...           # other configuration instances
#- °  │   │   └── ...               # other distributions
#- °  │   └── ...
#- °  └── ...
#
#+Escape: The <path> entries are files that have escaped (decorated) absolute path
# names. The [[repository()]] function is an implementation that handles decorate and
# undecorate.
#
#+      The algorithm is a bit simplistic, but good enough for the moment: for the folder
# part of the path all "/" characters are escaped as "_" (underscore) and real "_"
# are escaped by "''°''" (degree). The file name follows after a "+" character and is not
# escaped (and cannot contain spaces). The whole sequence is prefixed with a single
# letter key followed by "_".  The key is an architecture/distribution flag, see
# [[repository()]] for details. Examples:
#
#.      $CEN_ROOT/configs/<dist>/<inst>/<host>/<path>
#
#.      /etc/password                   # on raspbian
#.      $CEN_ROOT/configs/bookworm/worms/worm3/r_etc+password
#.      /etc/password                   # on debian
#.      $CEN_ROOT/configs/bookworm/worms/worm5/d_etc+password
#
#.      /etc/ssh/ssh_config.d/50_xyz.conf
#.      $CEN_ROOT/configs/bookworm/worms/worm5/d_etc_ssh_ssh''°''config.d+50_xyz.conf
#
#+Purpose:
# The repository is used to distribute centauri-tools, centauri-bash-lib and a lot of
# configuration files in a local network. The 'main' instance is located at the primary
# server and contains all data. The clients usually hold only sub-sets of this data in
# 'local' repositories. The 'centauriconfig' tool implements most of the executable
# logic and uses 'rsyncd' to synchronize server and clients.
#
#+      The clients use timers and the 'centauricron' to run a bi-directional update
# in regular intervals. This can also trigger update actions on the client side.
#
#+Security:
# For security reasons client computers are usually not allowed to write directly into
# the 'main' repository. As an intermediate step the 'staging' repository at the server
# mirrors the 'local' repositories. The 'centaurimachines' tool is used to mirror
# 'main' and to manually merge changes back to 'main'.
#
#+      'centaurimachines' also generates 'rsyncd' configuration files and machine
# passwords. The clients get their 'rsync' passwords over the 'centaurisecrets'
# mechanism.
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Staging + The Centauri Staging Repository
#
#+General: To avoid accidential or malicious corruption of the main repository
# this intermediate data structure is used by client computers. The structure
# is managed by the 'centaurimachines' tool. Via cron the staging data gets
# updated once per hour from the main repository. Merging data back from staging
# to main must be done manually.
#
#-      $CEN_ROOT/machines               # the installation root
#- °  ├── rsyncd.static             # static part of 'rsyncd.conf' file
#- °  ├── rsyncd.template           # per host fragment template
#- °  ├── <host1>                   # any number of host computer folders ...
#- °  │   ├── krb5.keytab           # kerberos keys, sent to host
#- °  │   ├── machine-id            # host identity, passed from host
#- °  │   ├── repository            # sub-set of main, shallow copy with BTRFS
#- °  │   ├── repository.conf       # authentication info, sent to host
#- °  │   ├── repository.rsyncd     # expanded 'rsyncd.template'
#- °  │   └── repository.secret     # for rsyncd authentication/authorisation
#- °  ├── <hostN>
#- °  │   └── ...
#- °  └── ...
#
#+rsyncd: The repository implementation uses the 'rsyncd' program to exchange
# data over the network. By default 'inetd' is used to run 'rsyncd' on demand.
# The configuration file '/etc/rsyncd.conf' is managed by 'centaurimachines'.
# Whenever a host is added to or removed from staging the config is rewritten.
# The file 'rsyncd.static' contains the static configuration data and for each
# host a fragment 'repository.rsyncd' is added.
#
#+master: Some administrative hosts (including the servers) can be configured
# to to bypass staging and keep a full copy of the main repository. This is
# done creating symlinks to main for each '<host>/repository' instead of
# creating sub-set folders (see "centaurimachines°--setup").
# ------------------------------------------------------------------------------
#   local root=/tmp/mount/var/centauri
#   local base=/some/pool
#   local dest
#   # get path of @shared in repository at $root, make symlink
#   repository -l folder dest trixie trixies - "$root"
#   # copy from files from pool to @shared
#   for item in /etc/services /etc/inetd.conf ; do
#       repository -b locate file "$item" "$base"
#       copy -a "$file" "$dest"
#   done


repository() {
    local _opti ;  [ "${1::1}" = '-' ] && { _opti="$1" ; shift ; }
    local _func="$1" ; shift
    case "$#${_func::3}" in
    2esc)       _cen_repo_esc "$@" ;;
    [345]fol)   _cen_repo_fol "$@" ;;
    [12]dis)    _cen_repo_dis "$@" ;;
    [234]loc)   _cen_repo_loc "$@" ;;
    *)          _cen_abort ? "$_func" $"(or wrong arg count)"
    esac
}

_cen_repo_esc() {
    local _sout _sinp _spat
    case "$_opti" in
    -d)     _spat="${2%/*}" ; _sinp="${2##*/}"
            _spat="${_spat//_/°}"
            _sout="${_spat//\//_}+$_sinp"
            ;;
    -u)     _spat="${2%+*}" ; _sinp="${2##*+}"
            _spat="${_spat#*/?_}" ; _spat="${_spat#_}"
            _spat="${_spat//_/\/}" ; _spat="${_spat//°/_}"
            _sout="$_spat/$_sinp" ; [ "${_sout::1}" = '/' ] || _sout="/$_sout"
            ;;
    *)      fatal -t '?' "$_opti"
    esac
    printf -v "$1" '%s' "$_sout"
}

_cen_repo_fol() {
    local _base="${5:-$CEN_ROOT}"
    local _sout="$_base/configs/$2/$3" _link='private'
    case "${4:--}" in
    -)      ;;
    [a-z]*) _sout+="/$4" ;;
    +)      _sout+="/$HOSTNAME" ;;
    @)      _sout+="/@shared" ; _link='shared' ;;
    *)      fatal -t '?' "$4"
    esac
    printf -v "$1" '%s' "$_sout"
    if [ -d "$_sout" ] ; then
        if [ "$_opti" = '-l' ] ; then
            symlink -n -- "${_sout#$CEN_ROOT/}" "$CEN_ROOT/$_link" || return 1
        fi
        return 0
    elif [ "$_opti" != '-q' ] ; then
        error $"Repository folder is missing:" "$_sout"
    fi
    return 1
}

_cen_repo_dis() {
    CEN_REP_DKEY=
    local _sout _sopt _sdis
    local -n _sarr="$1"
    [ "$_opti" = '-w' ] && _sopt='-w -o'
    if ! sysversion $_sopt ; then
        _sarr=() ; return 1
    fi

    _sdis="${2:-$CEN_SYS_DISTRO}"
    case "${_sdis,,}" in
        ubu*)   _sarr=('u' 'u' 'debian' 'ubuntu') ;;
        sus*)   _sarr=('s' 's' 'suse'   'suse') ;;
        ras*)   _sarr=('r' 'd' 'debian' 'raspbian') ;;
        ter*)   _sarr=('t' 'd' 'debian' 'termux') ;;
        deb*)   _sarr=('d' 'd' 'debian' 'debian') ;;
        *)      error $"Unknown linux distribution:" "$_sdis"
                _sarr=() ; return 1
    esac
    CEN_REP_DKEY="$_sarr"
    return 0
}

_cen_repo_loc() {
    local _sbas="$3" _sdis="${4:-$CEN_REP_DKEY}" _stmp _sitm _sfid
    [ "${_sbas:--}" = '-' ] && _sbas="$CEN_ROOT"
    printf -v "$1" ''
    if [ "${_sdis:--}" = '-' ] ; then
        _opti= ; _cen_repo_dis _stmp || return 1
        _sdis="$_stmp"
    fi

    if [ "$_opti" = '-b' ] ; then
        local _sarr=("$_sdis" 'a')
    else
        local _sarr=("private/$_sdis" 'private/a' "shared/$_sdis" 'shared/a')
    fi

    _opti='-d' ; _cen_repo_esc _sfid "$2"

    for _sitm in "${_sarr[@]}" ; do
        [ -e "$_sbas/$_sitm$_sfid" ] || continue
        printf -v "$1" '%s' "$_sbas/$_sitm$_sfid" ; return 0
    done
    return 1
}

# ------------------------------------------------------------------------------
# Startup: [-m]
# ------------------------------------------------------------------------------

[ "$1" = '-m' ] && monitor init
:                                           # return true to indicate success

# end
