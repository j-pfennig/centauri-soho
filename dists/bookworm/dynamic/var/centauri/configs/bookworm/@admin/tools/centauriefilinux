#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. J. Pfennig (c) 2021-2025; BSD License"
CEN_TITLE="Tool to manage EFI boot and to create systemd-boot menu and UKI"

# Import the bash library, set name and version
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -s -y - '0.30:4' || exit 2

CEN_OPT_BASE=           # see --base, EFI partition mount point
CEN_OPT_EXTERN=         # see --external, external disk
CEN_OPT_IFNAMES=        # see --ifnames
CEN_OPT_IMAGE=          # see --image, kernel efi image, relative to DAT_EFIDIR
CEN_OPT_NICKNAME=       # see --nickname, suffix for image folder and loader entries
CEN_OPT_PLAIN=          # see --plain (<empty>:=shim+mok  1:=shim 2:mok 3:=nothing)
CEN_OPT_ROOT=           # see --root

# --- Data ---

# used by do_shim
DAT_EFI_BOOTDIR='EFI/BOOT'
DAT_EFI_DISTDIR='EFI/grub'
DAT_EFI_MEMTDIR='EFI/memtest'
DAT_EFI_SYSDDIR='EFI/systemd'

DAT_ARCH='-'
DAT_ARCH_EFI=

DAT_SYSD_LOADER='loader'
DAT_SYSD_ENTRIES="$DAT_SYSD_LOADER/entries"
DAT_SYSD_CONFIG="$DAT_SYSD_LOADER/loader.conf"

DAT_UKINAME='linux.efi'         # name of unified kernel+initrd+efistub image
DAT_IMAGE=                      # kernel image, relative to DAT_EFIDIR
DAT_MOUNT=
DAT_SUBVOL='/Volumes/Root'      # btrfs subvolume: bootflags=subvol=...
DAT_UKIPATH=                    # set by do_suffix $DAT_MOUNT$/DAT_IMAGE
DAT_SUFFIX=                     # see --nickname and do_suffix
DAT_CMDLINE='cmdline'           # (extra) kernel parameters
DAT_PACKAGE='package'           # flag for update-initramfs calls

# --- relative to CEN_OPT_ROOT ---

# dirs in installation root
DAT_BOOTDIR='/boot'             # folder of distro kernel image
DAT_DKMSDIR='/var/lib/dkms'     # links to MOK for dkms signing
DAT_ROOTDIR=                    # prefix, see --root
DAT_ETCDIR='/etc'
DAT_LIBDIR='/usr/lib'           # centauri MOK, see setup
DAT_MOKDIR='/etc/mok'           # centauri MOK, see setup

# hook for update-initramfs to rebuild UKI
DAT_UPDTHOOK="/etc/initramfs/post-update.d/$CEN_NAME"

# used by do_shim
DAT_DIST_GRUB='/usr/lib/grub/x86_64-efi-signed/grubx64.efi.signed'
DAT_DIST_SHIM='/usr/lib/shim/shimx64.efi.signed'
DAT_DIST_FB='/usr/lib/shim/fbx64.efi.signed'
DAT_DIST_MM='/usr/lib/shim/mmx64.efi.signed'
DAT_DIST_STUB='/usr/lib/systemd/boot/efi/linuxx64.efi.stub'
DAT_DIST_SYSD='/usr/lib/systemd/boot/efi/systemd-bootx64.efi'

# repository paths
DAT_REPO_PRIVATE='/var/centauri/private'
DAT_REPO_SHARED='/var/centauri/shared'

# prefix these names with CEN_OPT_ROOT
DAT_PREFIX=(DAT_ROOTDIR DAT_BOOTDIR DAT_DKMSDIR DAT_ETCDIR DAT_LIBDIR DAT_MOKDIR
            DAT_UPDTHOOK DAT_DIST_FB DAT_DIST_GRUB DAT_DIST_MM DAT_DIST_SHIM
            DAT_DIST_STUB DAT_DIST_SYSD DAT_REPO_PRIVATE DAT_REPO_SHARED)

# ------------------------------------------------------------------------------
# helper
# ------------------------------------------------------------------------------

# helper for 'update' to install legacy grub: <no args>
do_bios() {
    confirm -n -q "install grub for legacy bios at '$CEN_MOUNT_DEV'" || return
    system -z grub-install --target=i386-pc --boot-directory="$DAT_MOUNT" "$CEN_BLKDEVICE"
}

# helper to parse kernel cmdline: <file> [<vxtr>]
do_cmdline() {
    local _pars _item _xtra _xpar=() _file="$1"
    inpfile -e -- "$_file" || return 1
    read -a _pars <"$_file"
    for _item in "${_pars[@]}" ; do
        _xtra='[*]'
        case "$_item" in
        BOOT_IMAGE=*)       ;;
        fsck.repair=*)      ;;
        root=*)             ;;
        rootflags=*)        ;;
        centauriswitch=*)   ;;
        loglevel=*)         ;;
        lsm=*)              ;;
        mitigations=off)    ;;
        net.ifnames=0)      ;;
        resume=*)           ;;
        security=)          ;;
        quiet|ro|nosplash|splash) ;;
        *)  _xtra='   ' ; _xpar+=("$_item")
        esac
        [ -z "$2" ] && message -a "$_xtra $_item"
    done
    if [ -z "$2" ] ; then
        pluralize -a -c 2 -z -p "%s extra %s: ""$_file" "${#_xpar[@]}" "parameter"
    else
        printf -v "$2" "%s" "${_xpar[*]}"
    fi
    return 0
}

# helper to set loader default: <path> [<wait>]
do_default() {
    local path="$1" wait="${2:--}" ; [ "$wait" = '-' ] && wait=0
    create -h - -t -- "$DAT_MOUNT/$DAT_SYSD_CONFIG" <<!EOF
default ${path%% *}*
timeout $wait
!EOF
    local srel='type1'
    create -v srel -- "$DAT_MOUNT/$DAT_SYSD_LOADER/entries.srel"

    # create -- "$DAT_MOUNT/$DAT_SYSD_LOADER/random-seed"
    # bootctl random-seed
}

# helper to check for EFI boot: <no args>
do_efichk() {
    if [ ! -d '/sys/firmware/efi' ] ; then
        if [ -z "$CEN_OPT_FORCE" ] ; then
            if [ "${CEN_CMDARGS::3}" = 'hoo' ] ; then
                trace $"This computer was not booted via EFI. Quit for action 'hook'."
                quit
            fi
            quit -e $"This computer was not booted via EFI. Use --force to run this tool"
        fi
        [ -z "$CEN_OPT_SILENT" ] &&
            warning $"This computer was not booted via EFI. Some commands may not work"
    fi

    case "$CEN_CMDARGS" in
    cmd*|cre*|mok|set*)  ;;
    *)  if [ ! -s "$DAT_UKIPATH" ] ; then
            quit -e -m -p $"No unified kernel image: %s\nPlease run '%s' or '%s' first." \
                        "$DAT_UKIPATH" "$CEN_NAME create" "$CEN_NAME setup"
        fi
    esac
}

# helper to make systemd boot entry: <prio> <text> <file> <args>...
#
#       do_entry [-]                    # remove '[0-9]0' entries
#
#       <text>      -                   # use UKI path
#       <text>      [!/]*               # use /image-...
#       <text>      /*                  # path relative to DAT_MOUNT
#
# priority '[0-9]0' creates default entries (not automatically overriden)
do_entry() {
    local prio="${1:--}" text="$2" file="$3" ; shift ; shift ; shift
    local entr trun

    # generate entry file name
    entr="$prio-${text,,}" ; entr="${entr//[[:space:]]/-}"
    [ "${prio:1:1}" != 0 ] && trun='-t' # truncate non-default entries

    # remove all default entries
    if [ "$prio" = '-' ] ; then
        remove -- "$DAT_MOUNT/$DAT_SYSD_ENTRIES"/[0-9]0-*
        return
    fi

    # create entry
    if [ "$file" = '-' ] ; then
        #text="Linux $text"
        entr+="$DAT_SUFFIX"
        file="${DAT_UKIPATH:${#DAT_MOUNT}}"
    elif [ "${file::1}" != '/' ] ; then
        text="Linux: $text ($file)"
        entr+="-$file"
        file="/image-$file/linux.efi" ; trun='-t'
    elif [ ! -f "$DAT_MOUNT/$file" ] ; then
        return
    fi
    entr="$DAT_MOUNT/$DAT_SYSD_ENTRIES/${entr//[\/\\#:@.]/-}.conf"

    # disabled entry (like MS-Windows which systemd adds automatically)
    [ "$prio" = 10 ] && entr+='.off'

    if dryrun ; then
        message -- "$entr"
        message -a "title   $text"
        message -a "efi     $file"
        [ $# -gt 0 ] && message -a "options $*"
    elif [ $# -gt 0 ] ; then
        create $trun -h - -- "$entr" <<!EOF
title   $text
efi     $file
options $*
!EOF
    else
        create $trun -h - -- "$entr" <<!EOF
title   $text
efi     $file
!EOF
    fi
}

# helper to check uki package install: <file> <name>
do_file() {
    [ -e "$1" ] && return 0
    error -p "Please install package '%s'\nMissing file: %s" "$2" "$1" ; return 1
}

# grub configuration for efi: <fldr>
do_grub() {
    do_text grub "$1"

    folder -f -m "$DAT_MOUNT/grub/fonts"
    copy -q "$DAT_ROOTDIR/usr/share/grub/unicode.pf2" "$DAT_MOUNT/grub/fonts"

    if [ -e "$DAT_MOUNT/grub/grub.cfg" ] ; then
        trace -a -c "existing config" "$DAT_MOUNT/grub/grub.cfg"
    else
        do_repo '/boot/grub/grub.cfg' "$DAT_MOUNT/grub/grub.cfg" -
    fi

    do_repo '/etc/kernel/postrm.d/zz-update-grub'
    do_repo '/etc/kernel/postinst.d/zz-update-grub'
}

# create hook scriptlet to handle kernel updates
do_hook() {
    create -d "${DAT_UPDTHOOK%/*}" || return 1
    create -c -t "$DAT_UPDTHOOK" 770 <<!EOF || return 1
#!$BASH
[ "\$2" -ef '/boot/initrd.img' ] || exit 0
$CEN_TOOLS/$CEN_NAME hook update
!EOF
}

# helper to create UKI: <idir> <path> <message>
do_image() {
    system -c -f objcopy objdump awk

    local idir="$1" imag="$2" mesg="$3"
    local ibmp="$idir/splash.bmp"
    local cmdl="$idir/$DAT_CMDLINE"
    local ipkg="${idir##*/}/$DAT_CMDLINE"

    # backward compatibility: migrate old-style kernel-cmdline
    [ -e "$idir/kernel-cmdline" ] && move -o -q -- "$idir/kernel-cmdline" "$cmdl"

    ### TODO: the loader cannot override a built-in cmdline if SecureBoot is on

    if [ -e "$cmdl" ] ; then
        if [ -h "$DAT_BOOTDIR/efi" -o -d "$DAT_BOOTDIR/efi" ] ; then
            symlink -i -n "efi/$ipkg" "$DAT_BOOTDIR/$DAT_CMDLINE"
        else
            symlink -n "/mnt/boot/$ipkg" "$DAT_BOOTDIR/$DAT_CMDLINE"
        fi
    else
        warning -n $"No kernel command-line:" "$cmdl" \
                   $'\n'"consider running: $CEN_NAME cmdline copy"
    fi

    if [ "$mesg" != '-' ] ; then
        sysfind -q magick || mesg='-'
    elif [ ! -e "$ibmp" ] ; then
        ibmp="$DAT_BOOTDIR/splash.bmp"
        [ ! -e "$ibmp" ] && sysfind -q magick && mesg="Booting Debian ${DAT_SUFFIX:1}"
    fi
    [ "$mesg" != '-' ] && system -e -p magick -background black -fill white -pointsize 22 \
                                 -font /usr/share/fonts/truetype/dejavu/DejaVuSans.ttf \
                                 "label:$mesg ..." "$ibmp"
    [ -e "$ibmp" ] || ibmp='/sys/firmware/acpi/bgrt/image'

    message -a "Generating EFI Linux image:" "$imag"
    local opts=() offs alig size acmd
    inpfile -- "$DAT_DIST_STUB" || return 1         # linuxx64.efi.stub
    tmpfile -r -f

    system -r -e -z objdump -h "$DAT_DIST_STUB" > "$CEN_TMPFILE" || return 1
    acmd='NF==7 {size=strtonum("0x"$3); offset=strtonum("0x"$4)} END {print size + offset}'
    system -r -e -p -s offs awk "$acmd" < "$CEN_TMPFILE" || return 1

    function ___uki_add() {
        # ((offs += alig - (offs % alig)))
        opts+=(--add-section "$1=$2" --change-section-vma "$1=$offs")
        system -r -f -p -s size -- stat '-Lc%s' "$2" ; ((offs += size))
    }

    local pvml pini
    matchpath -s pvml -e -o -- "$DAT_BOOTDIR/vmlinuz" '/vmlinuz' ||
        quit "No kernel image found:" "$DAT_BOOTDIR/vmlinuz"
    matchpath -s pini -e -o -- "$DAT_BOOTDIR/initrd.img" '/initrd.img' ||
        quit "No initrd found:" "$DAT_BOOTDIR/initrd.img"

    [ -n "$CEN_OPT_PLAIN" ] &&  ___uki_add '.cmdline' "$cmdl"
                                ___uki_add '.osrel'   "$DAT_LIBDIR/os-release"
    [ -s "$ibmp" ] &&           ___uki_add '.splash'  "$ibmp"
                                ___uki_add '.linux'   "$pvml"
                                ___uki_add '.initrd'  "$pini"

    opts+=("$DAT_DIST_STUB")                        # linuxx64.efi.stub
    system -e -p -z -- objcopy "${opts[@]}" "$imag" && return 0
    dryrun                                          # ok for --dryrun
}

# install memtest86 in EFI partition
do_memt() {
    [ "$DAT_ARCH" = 'x64' ] || return 0                 # x64 only
    local file='memtest86+x64.efi'
    if [ -e "$DAT_BOOTDIR/$file" ] ; then
        trace -a -c "Setup folder" "$PWD/$DAT_EFI_MEMTDIR"
        folder -f -m "$DAT_EFI_MEMTDIR"
        copy -s -- "$DAT_BOOTDIR/$file" "$DAT_EFI_MEMTDIR"
    else
        message -a -c "Not installed" "$file"
    fi
    return 0
}

# helper to check MOK folder/key: [-c|-d|-s]
do_mokcheck() {
    local fmoc mode

    # do we have a mok folder?
    if [ ! -d "$DAT_MOKDIR" ] ; then
        case "$1" in
        -c)     folder -c -f -m -- "$DAT_MOKDIR" || return 1 ;;
        -d)     return 0 ;;
        -s)     system -q -s mode mokutil --sb-state || mode="no mokutil"
                message -a "No MOK folder," "$mode" ; return 1 ;;
        *)      invoke -e "No MOK folder, use '$CEN_NAME mok create'"
                return 1
        esac
    fi

    # do we have a MOK key (0:=empty  1:=invalid  2:=decypted key missing  3:=ok)
    if matchpath -e "$DAT_MOKDIR/MOK.priv" "$DAT_MOKDIR/MOK.pem" "$DAT_MOKDIR/MOK.der" ; then
        if [ "${#CEN_MATCHPATH[@]}" = 3 ] ; then
            [ -e "$DAT_MOKDIR/MOK.key" ] && fmoc=3 || fmoc=2
        else
            fmoc=1
        fi
    else
        [ -e "$DAT_MOKDIR/MOK.key" ] && fmoc=1 || fmoc=0
    fi

    # status option
    if [ "$1" = '-s' ] ; then
        [ "$fmoc" != 3 ] && fmoc="no MOK key" || fmoc="have MOK key"
        system -q -s mode mokutil --sb-state || mode="no mokutil"
        message -a -p "Existing MOK folder, %s, %s" "$fmoc" "$mode"
        return 0
    fi

    # create/delete option
    if [ "$1" = '-c' ] ; then
        [ "$fmoc" = 3 ] && return 0                     # mok is ok
        [ "$fmoc" = 2 ] && return 2                     # need decrypt
        return 1                                        # create new mok
    elif [ "$1" = '-d' ] ; then
        [ "$fmoc" = 0 ] && return 0                     # no mok present
        confirm -n -y "Remove existing MOK key" || return 1
        do_mokenroll -d
        remove -- "${CEN_MATCHPATH[@]}" "$DAT_MOKDIR/MOK.key" || return 2
        return 0
    fi

    # not creating/deleting, we should have a valid mok key ...
    case "$fmoc" in
    0)  invoke -e "No MOK key, use '$CEN_NAME setup' or '$CEN_NAME mok create'" ;;
    1)  invoke -e "Incomplete MOK key, use '$CEN_NAME mok delete'" ;;
    2)  invoke -e "No decrypted MOK key, use '$CEN_NAME mok decrypt'" ;;
    *)  return 0
    esac
    return 1
}

# helper to create a MOK: <no args>
do_mokcreate() {
    do_mokcheck -c
    case "$?" in
        0)  confirm -y "Keep existing valid MOK key" && return 0 ;;
        2)  confirm -y "MOK exists, decrypt key only" || return 1
            do_mokdecrypt -k ; return ;;    # decrypt key, register with dkms
    esac

    message -a "Creating MOK key (with pass phrase) ..."
    remove "$DAT_MOKDIR"/*
    # get domain name via kernel, network may be not yet configured
    local sdom
    read sdom </proc/sys/kernel/domainname || warning "Cannot get domain name"
    [ -z "$sdom" ] && sdom='unknown' || sdom="${sdom%%.*}"
    # use openssl -nodes to avoid pass phrase
    system -e -p openssl req -new -x509 -newkey rsa:2048 -keyout "$DAT_MOKDIR/MOK.priv" \
        -outform DER -out "$DAT_MOKDIR/MOK.der" -days 36500 -subj "/CN=${sdom^}/" || return 1
    system -e -p openssl x509 -inform der -in "$DAT_MOKDIR/MOK.der" \
                                          -out "$DAT_MOKDIR/MOK.pem" || return 1
    do_mokdecrypt -k                            # decrypt key, register with dkms
}

# helper to decrypt the private key of a MOK certificate: [-k]
do_mokdecrypt() {
    do_mokcheck -c
    case "$?" in
    0|2)    ;;
    *)      invoke -e "No valid MOK key, use '$CEN_NAME mok create'" ; return 1
    esac

    if [ "$DAT_MOKDIR/MOK.priv" -nt "$DAT_MOKDIR/MOK.key" ] ; then
        message -a "Decrypting MOK private key ..."
        rem"$DAT_DISK""$DAT_DISK"ove -- "$DAT_MOKDIR/MOK.key"
        system -z openssl rsa -in "$DAT_MOKDIR/MOK.priv" -out "$DAT_MOKDIR/MOK.key"
        if ! [ -s "$DAT_MOKDIR/MOK.key" ] ; then
            remove -- "$DAT_MOKDIR/MOK.key"
            invoke -e "Failed to decrypt" ; return 1
        fi
    fi
    message -a "Decrypted MOK private key is:" "$DAT_MOKDIR/MOK.key"

    # create symlinks for dkms
    if [ "$1" != '-k' ] || [ ! -d "$DAT_DKMSDIR" ] ; then
        message -a "This MOK is not registered with DKMS"
        return 0
    fi
    message -a "Registering MOK with DKMS ..."
    symlink -n "${DAT_MOKDIR:${#DAT_ROOTDIR}}/MOK.key" "$DAT_DKMSDIR/mok.key"
    symlink -n "${DAT_MOKDIR:${#DAT_ROOTDIR}}/MOK.der" "$DAT_DKMSDIR/mok.pub"
    return 0
}

# helper to enroll/delete a MOK: [-d]
do_mokenroll() {
    if system -q -r -- mokutil --test-key "$DAT_MOKDIR/MOK.der" ; then
        [ "$1" = '-d' ] && return 0             # not enrolled
        message -a "Enrolling MOK at next boot, enter a password..."
        system -e mokutil --import "$DAT_MOKDIR/MOK.der" || return 1
        return 2
    else
        [ "$1" = '-d' ] || return 0             # not to be deleted
        message -a "Removing MOK at next boot, enter a password..."
        system -e mokutil --delete "$DAT_MOKDIR/MOK.der" || return 1
    fi
    return 0
}

# get efi folder: [-h]
do_mount() {
    if [ -n "$CEN_OPT_BASE" ] ; then
        local base="${CEN_OPT_BASE%/[eE][fF][iI]}"
        if folder -c -q "$CEN_OPT_BASE/efi" ; then
            DAT_MOUNT="${PWD%/*}"
        elif folder -c -q "$base" ; then
            DAT_MOUNT="${PWD%/*}"
        fi
    else
        local list
        matchpath -a list -d -o \
            /efi/[eE][fF][iI] /boot/efi/[eE][fF][iI] /mnt/boot/[eE][fF][iI]
        DAT_MOUNT="${list%/*}"
    fi

    [ "$1" = '-h' ] && return
    [ -z "$DAT_MOUNT" ] &&
        quit -e $"Found no compatible EFI folder, use" "'--base=<efi-folder>'"
    [ "${CEN_OPT_IMAGE::1}" = '/' ] &&
        quit -e $"Path must not be absolute" "'--image=$CEN_OPT_IMAGE'"
}

# helper for 'update' to get efi binaries right: <path>
do_plain() {
    local spre scmd sefi spst sdef="$DAT_MOUNT/$DAT_EFI_BOOTDIR/BOOT${DAT_ARCH_EFI^^}"
    local xpre xcmd xpst xdev="$CEN_BLKDEVICE"

    folder -c -f ${CEN_OPT_FORCE:+-m} "$DAT_MOUNT/$1"
    if matchpath -o -e shim${DAT_ARCH}* fb${DAT_ARCH}* *.CSV ; then
        confirm -a -y -q "Remove SecureBoot '${1##*/}' components" &&
            remove *.efi *.EFI *.CSV
    fi

    message -a -c "Setup folder" "$PWD/$1"
    if [ "$1" = "$DAT_EFI_BOOTDIR" ] ; then
        :

    elif [ "$1" = "$DAT_EFI_DISTDIR" ] ; then
        do_file "$DAT_LIBDIR/grub/x86_64-efi" grub-efi-amd64-bin || return 1
        spre="install grub library at '$CEN_MOUNT_DEV'"

        xpre=(grub-install --no-nvram --target=x86_64-efi \
                --efi-directory="$DAT_MOUNT" "$xdev")

        sefi="grub$DAT_ARCH_EFI"
        scmd="build custom grub loader"
        xcmd=(grub-mkimage -d "$DAT_LIBDIR/grub/x86_64-efi"
                -o "$sefi" -p '/grub' -O x86_64-efi
                fat exfat ext2 btrfs iso9660 part_gpt part_msdos efifwsetup
                boot linux multiboot loopback chain reboot  configfile normal
                test loadenv keystatus  cat echo ls sleep search search_label
                search_fs_uuid search_fs_file  font efi_gop efi_uga gfxterm
                gfxterm_background gfxterm_menu all_video)

 #grub-mkimage -O arm64-efi -d ./arm64-efi/ -o grubaa64.efi.unsigned -p /EFI/boot --format 'arm64-efi' --compression  auto  ext2 part_gpt newc blocklist iso9660 udf memdisk cpio minicmd part_msdos part_gpt msdospart fat btrfs exfat loopback gfxterm reboot normal romfs procfs sleep ls cat echo search configfile halt chain test probe linux scsi gfxmenu gfxterm gfxterm_background deepin_gfxmode linux jpeg iso9660  elf part_apple extcmd xfs part_bsd part_gpt search   search_fs_file chain btrfs loadenv png part_gpt gzio part_gpt all_video efifwsetup password_pbkdf2 --sbat sbat


        spst="make grub the default boot loader"
        xpst=("$sefi" "$sdef" "$sdef")      # <src> <dest> [<folder>]

    else
        do_file "$DAT_DIST_SYSD" systemd-boot-efi || return 1
        scmd="install systemd boot"

        sefi="systemd-boot$DAT_ARCH_EFI"
        xcmd=(cp -a "$DAT_DIST_SYSD" "$sefi")

        spst="make systemd the default boot loader"
        xpst=("$DAT_DIST_SYSD" "$sdef" "$sdef")
    fi

    if [ -n "$spre" ] && confirm -n -q "$spre" ; then
        system -z -- "${xpre[@]}"
        [ "$1" = "grub" ] && scmd=
    fi
    if [ -n "$scmd" ] && confirm -n -q "$scmd" ; then
        system -z -- "${xcmd[@]}"
    fi
    if [ -n "$spst" ] && confirm -n -q "$spst" ; then
        [ -n "${xpst[2]}" ] && folder -f -m -- "${xpst[2]}"
        copy -a -- "${xpst[0]}" "${xpst[1]}"
    fi
}

# helper to copy from repository: <repo> [<dest>|- [<mesg>|-]]
do_repo() {
    local repo dest="${2:--}"
    local path="${1%/*}" file="${1##*/}"
    local name="${path//\//_}+$file"
    [ "$dest" = '-' ] && { dest="$DAT_ROOTDIR/$1" ; dest="${dest/\/\//\/}" ; }

    if matchpath -o -e -s repo -- "$DAT_REPO_PRIVATE"/?$name \
                                  "$DAT_REPO_SHARED"/?$name ; then
        folder -m -- "${dest%/*}"
        copy -a -- "$repo" "$dest"
    elif [ "$3" = '-' ] ; then
        warning -p "No source for '%s', create manually" "$dest"
    elif [ -n "$3" ] ; then
        warning -p "No source for '%s' %s" "$dest" "$3"
    fi
}

# helper for 'update' to get shim components right: <path>

# internal disk:
# ├── EFI
# │   ├── BOOT              # default boot entry ...
# │   │   ├── BOOTX64.EFI   # debian's shim64.efi
# │   │   ├── mmx64.efi     # debian's signed MOK manager
# │   │   └── fbx64.efi     # debian's signed boot fallback manager
# │   ├── grub
# │   │   ├── BOOTX64.CSV   # fallback, points to shimx64
# │   │   ├── grub.cfg      # delegate to /grub/grub.cfg
# │   │   ├── grubx64.efi   # debian's signed grub
# │   │   ├── mmx64.efi     # debian's signed MOK manager
# │   │   └── shimx64.efi   # debian's signed shim
# │   └── systemd
# │       ├── BOOTX64.CSV   # fallback, points to shimx64
# │       ├── grubx64.efi   # renamed systemd bootx64.efi, MOK signed
# │       ├── mmx64.efi     # debian's signed MOK manager
# │       └── shimx64.efi   # debian's signed shim

# external disk:
# ├── EFI
# │   └── BOOT              # default boot entry ...
# │       ├── BOOTX64.EFI   # debian's shim64.efi
# │       ├── mmx64.efi     # debian's signed MOK manager
# │       └── grubx64.efi   # debian's signed grub

do_shim() {
    do_file "$DAT_DIST_SHIM" shim-signed || return 1

    if [ -z "$CEN_OPT_EXTERN" ] ; then              # auto detect
        findmount - "$DAT_MOUNT" || CEN_MOUNT_DEV=
        case "$CEN_MOUNT_DEV" in
        '')     warning "Cannot auto-detect disk type, using '--external=off'"
                CEN_OPT_EXTERN=0
                ;;
        /dev/sd*|/dev/mmc*)
                CEN_OPT_EXTERN=1
                message -a "Found external disk, using '--external=on'"
                ;;
        *)      CEN_OPT_EXTERN=0
                message -a "Found internal disk, using '--external=off'"
        esac
    fi

    system -c iconv || return 1                     # used for CSV entries

    if [ "$CEN_OPT_EXTERN" = 1 ] ; then
        if [ "$1" = "$DAT_EFI_DISTDIR" -o "$1" = "$DAT_EFI_SYSDDIR" ] ; then
            [ -d "$1" ] || return 0
            confirm -a -f -y "Remove '%s' boot configuration" "$1" || return 0
            remove -d -- "$1" ; return 0
        elif [ "$1" = "$DAT_EFI_BOOTDIR" ] ; then
            trace -a -c "External disk" "$PWD/$1"
            do_file "$DAT_DIST_GRUB" grub-efi-amd64-signed || return 1
            remove -q -- "$1"/* ; folder -m -f -- "$1"
            copy -s -- "$DAT_DIST_GRUB" "$1/grub$DAT_ARCH_EFI"
            copy -s -- "$DAT_DIST_SHIM" "$1/BOOTX64.EFI"
            copy -s -- "$DAT_DIST_MM"   "$1/mm$DAT_ARCH_EFI"
            do_grub "$1"
            return 0
        fi
    fi

    trace -a -c "Setup folder" "$PWD/$1"
    folder -m -f -- "$1"
    remove -- "$1"/*.[eE][fF][iI] "$1"/*.[cC][sS][vV]

    if [ "$1" = "$DAT_EFI_BOOTDIR" ] ; then
        copy -s -- "$DAT_DIST_SHIM" "$1/BOOT${DAT_ARCH_EFI^^}"
        copy -s -- "$DAT_DIST_MM"   "$1/mm$DAT_ARCH_EFI"
        copy -s -- "$DAT_DIST_FB"   "$1/fb$DAT_ARCH_EFI"

    elif [ "$1" = "$DAT_EFI_DISTDIR" ] ; then
        do_file "$DAT_DIST_GRUB" grub-efi-amd64-signed || return 1
        copy -s -- "$DAT_DIST_GRUB" "$1/grub$DAT_ARCH_EFI"
        copy -s -- "$DAT_DIST_MM"   "$1/mm$DAT_ARCH_EFI"
        copy -s -- "$DAT_DIST_SHIM" "$1/shim$DAT_ARCH_EFI"
        do_text csv "$1" "Grub boot (fallback)"
        do_grub "$1"
    else
        do_file "$DAT_DIST_SYSD" systemd-boot-efi || return 1
        do_sign    "$DAT_DIST_SYSD" "$1/grub$DAT_ARCH_EFI"    # rename as grubx64 !
        copy -s -- "$DAT_DIST_MM"   "$1/mm$DAT_ARCH_EFI"
        copy -s -- "$DAT_DIST_SHIM" "$1/shim$DAT_ARCH_EFI"
        do_text csv "$1" "Systemd boot (fallback)"

        do_repo '/etc/kernel/postrm.d/zz-systemd-boot' - -
        do_repo '/etc/kernel/postinst.d/zz-systemd-boot' - -
    fi
    return 0
}

# helper to sign: <efibin> [<output>]
do_sign() {
    if [ -e "$DAT_MOKDIR/MOK.key" ] ; then
        local opts=(-p sbsign --key "$DAT_MOKDIR/MOK.key")
    elif [ -e "$DAT_MOKDIR/MOK.priv" ] ; then
        local opts=(sbsign --key "$DAT_MOKDIR/MOK.priv")
    else
        error "No MOK key found" ; return 1
    fi
    opts+=(--cert "$DAT_MOKDIR/MOK.pem")

    local otmp oout="$2"
    tmpfile -f -s otmp

    if ! system -e "${opts[@]}" --output "$otmp" "$1" ; then
        dryrun && return 0
        remove -- "$otmp" ; return 1
    elif [ -z "$2" ] ; then
        move -- "$otmp" "$1.signed"
    elif [ "$oout" = '.' ] ; then
        move -s -- "$otmp" "$1"
    elif [ "$oout" = '-' ] ; then
        rename -- "$1" "$1.unsigned" && move -s -- "$otmp" "$1"
    else
        move -s -- "$otmp" "$oout"
    fi
    return 0
}

# create efi/systemd symlinks in /boot folder
do_symlinks() {
    if [ -e "$DAT_BOOTDIR/grub" ] ; then
        if [ -h "$DAT_BOOTDIR/grub" ] || confirm -y "Delete 'boot/grub' folder" ; then
            remove -d "$DAT_BOOTDIR/grub"
        else
            rename -b "$CEN_NAME" -x "$DAT_BOOTDIR/grub"
        fi
    fi
    #   efi       /mnt/boot
    #   entries   efi/loader/entries
    #   grub      efi/grub
    #   cmdline   efi/<image>/cmdline
    #   package   efi/<image>/linux.efi
    [ -h "$DAT_BOOTDIR/efi" ]     || symlink -n '/mnt/boot' "$DAT_BOOTDIR/efi"
    [ -h "$DAT_BOOTDIR/entries" ] || symlink -n 'efi/loader/entries' "$DAT_BOOTDIR/entries"
    [ -h "$DAT_BOOTDIR/grub" ]    || symlink -n 'efi/grub'  "$DAT_BOOTDIR/grub"
    if [ "${1:--}" != '-' ] ; then
        symlink -n "efi/image$DAT_SUFFIX/${1##*/}" "$DAT_BOOTDIR/${DAT_PACKAGE##*/}"
        symlink -n "efi/image$DAT_SUFFIX/$DAT_CMDLINE" "$DAT_BOOTDIR/$DAT_CMDLINE"
    fi
}

# helper to create a text file: csv|grub <fldr> [<text>]
do_text() {
    if [ "$1" = 'csv' ] ; then
        echo "shim$DAT_ARCH_EFI,$3,,fallback boot entry" |
            system -e -p iconv -o "$2/BOOTX64.CSV" -t UTF-16
    else
        text="configfile /grub/grub.cfg"
        create -v text -- "$2/grub.cfg"
    fi
}

# get suffix for image folder and loader entries
do_suffix() {
    local fcom
    if [ -z "$CEN_OPT_NICKNAME" ] ; then
        sysversion -u -o -f
        CEN_OPT_NICKNAME="$CEN_SYS_NICKNAME"
        DAT_SUFFIX="-$CEN_SYS_NICKNAME"
        fcom=1                                      # compatibility flag
    elif [ "$CEN_OPT_NICKNAME" = '-' ] ; then
        CEN_OPT_NICKNAME=
    else
        DAT_SUFFIX="-$CEN_OPT_NICKNAME"
    fi
    DAT_IMAGE="image$DAT_SUFFIX/$DAT_UKINAME"

    if [ -n "$CEN_OPT_IMAGE" ] ; then
        joinpath -s DAT_IMAGE -e 'efi' -- "$CEN_OPT_IMAGE"
    elif [ -n "$fcom" ] ; then                      # fallback to 'image'
        joinpath -- "$DAT_MOUNT" 'image'
        if [ -d "$CEN_JOINPATH" ] && [ ! -d "$CEN_JOINPATH$DAT_SUFFIX" ] ; then
            DAT_IMAGE="image/$DAT_UKINAME"
            DAT_SUFFIX=
            trace "Fallback to compatibility mode:" "$DAT_IMAGE"
        fi
    fi
    joinpath -s DAT_UKIPATH -- "$DAT_MOUNT" "$DAT_IMAGE"
}

# remove unwanted systemd configuration data
do_unconf() {
    local   mach base="$DAT_MOUNT/$DAT_EFI_BOOTDIR"
    case "$1" in
    machine-id) readline -s mach -i "$DAT_ETCDIR/machine-id" || return
                [ -n "$mach" ] || return
                remove -d "$DAT_MOUNT/$mach"    # remove folder
                remove    "$DAT_MOUNT/$DAT_SYSD_ENTRIES"/$mach* ;;
    debian)     remove -d "$base/$1" ;;         # remove folder
    grub)       [ -d "$DAT_BOOTDIR/$1" ] && remove -d "$DAT_BOOTDIR/$1"
                [ -h "$DAT_BOOTDIR/$1" ] || symlink -n "/mnt/boot/grub" "$DAT_BOOTDIR/$1" ;;
    *)          remove    "$base/$1"/*          # remove content
    esac
}

# remove debian hooks used to update the boot folder
do_unhook() {
    trace -c "$CEN_ACTION" "Remove update-grub and systemd-boot hooks"
    remove  "$DAT_ETCDIR/kernel/postinst.d/zz-systemd-boot" \
            "$DAT_ETCDIR/kernel/postrm.d/zz-systemd-boot" \
            "$DAT_ETCDIR/initramfs/post-update.d/systemd-boot"
    do_repo "/etc/kernel/postrm.d/zz-systemd-boot"
    do_repo "/etc/kernel/postinst.d/zz-systemd-boot"
    do_repo "/etc/initramfs/post-update.d/systemd-boot"

    remove  "$DAT_ETCDIR/kernel/postinst.d/zz-update-grub" \
            "$DAT_ETCDIR/kernel/postrm.d/zz-update-grub"
    do_repo "/etc/kernel/postrm.d/zz-update-grub"
    do_repo "/etc/kernel/postinst.d/zz-update-grub"
}

# ------------------------------------------------------------------------------
# run systemd boot manager: <args>...
# ------------------------------------------------------------------------------
actionBootctl() {
    local verb="$1" ; shift
    case "$verb" in
    lis*)   verb='list' ;;
    sta*)   verb='status' ;;
    esac
    system -z -- bootctl --esp-path="$DAT_MOUNT" $verb "$@"
}

# ------------------------------------------------------------------------------
# action cmdline: [boot|copy|edit|show]
# ------------------------------------------------------------------------------
actionCmdline() {
    local fnam="image$DAT_SUFFIX/$DAT_CMDLINE"
    local file="$DAT_MOUNT/$fnam"
    case "$1" in
    boo|boot)       file='/proc/cmdline' ;;
    cop|copy)       outfile -- "$file" || return
                    copy '/proc/cmdline' "$file"
                    symlink -n "efi/$fnam" "$DAT_BOOTDIR/$DAT_CMDLINE" ; return ;;
    edi|edit)       system -e -x editor "$file" ;;
    ext*)           local xtra
                    do_cmdline "$file" xtra || return
                    message "Extra parameters:" "${xtra:--none-}" ; return ;;
    sho|show|'')    ;;
    *)              invoke -a 'boot|copy|edit|show' ; return ;;
    esac
    message "Kernel parameters - [*] indicates a default value:"
    do_cmdline "$file"
}

# ------------------------------------------------------------------------------
# action create: [<image>|- [<message>|-]]
# ------------------------------------------------------------------------------
actionCreate() {
    local idir imag="${1:--}" mesg="${2:--}"
    [ "$imag" = '-' ] && imag="$DAT_UKIPATH" ; imag="${imag%/}"
    if [ -d "$imag" ] ; then
        idir="$imag" ; imag+="/$DAT_UKINAME"
    elif [ ! -d "${imag%/*}" ] ; then
        error "Not a folder:" "${imag%/*}" ; return
    else
        idir="${imag%/*}"
    fi

    do_image "$idir" "$imag" "$mesg" || return      # make uki image

    do_hook || return
    do_unhook || return
    if [ -z "$CEN_OPT_PLAIN" ] ; then
        message -a "Signing EFI image with MOK:" "$imag"
        do_sign "$imag" . || return
    fi
    do_symlinks "$imag"
}

# ------------------------------------------------------------------------------
# run efi boot manager: <args>...
# ------------------------------------------------------------------------------
actionEfimgr() {
    if ! findmount -- - "$DAT_MOUNT" ; then
        error "Could not find device for mount:" "$DAT_MOUNT" ; return
    fi
    local pefi pmen pref
    case "$1 $2" in
    add*)   arguments 3 - "$@" || return ; shift ; set -- -c -L "$1" -l "${2//\//\\}" ;;
    del*)   if [ $# = 2 ] ; then
                set -- -b "$2" -B
            else                            # recurse for multiple deletes ...
                while [ $# -gt 1 ] ; do
                    shift ; actionEfimgr del "$1"
                done ; return
            fi ;;
    ent*\ gru*)
            arguments 2 - "$@" || return ; shift
            pmen="Grub boot menu" ; pref="$DAT_MOUNT/$DAT_EFI_DISTDIR"
            matchpath -s pefi -e -o -- "$pref/shim$DAT_ARCH_EFI" "$pref/grub$DAT_ARCH_EFI" '.' ;;
    ent*\ sys*)
            arguments 2 - "$@" || return ; shift
            pmen="Systemd boot menu" ; pref="$DAT_MOUNT/$DAT_EFI_SYSDDIR"
            matchpath -s pefi -e -o -- "$pref/shim$DAT_ARCH_EFI" "$pref/systemd-boot$DAT_ARCH_EFI" '.' ;;
    ord*)   arguments 2 - "$@" || return ; shift ; set -- -o "$@" ;;
    [a-z]*) invoke -e "Valid sub-commands are:" "add, delete, entry grub|systemd, order"
            return ;;
    esac

    if [ "$pefi" = '.' ] ; then
        invoke -e "No bootable efi binary found" ; return
    elif [ -n "$pefi" ] ; then
        pefi="${pefi:${#DAT_MOUNT}}"
        set -- -c -L "$pmen" -l "${pefi//\//\\}"
    fi
    local verb ; [ "$CEN_VERB" -gt 1 ] && verb='-v'
    system -z -- efibootmgr $verb --disk "$CEN_MOUNT_DEV" "$@"
}

# ------------------------------------------------------------------------------
# action hook: <event>
# ------------------------------------------------------------------------------
actionHook() {
    case "$1" in
    cre*)   do_hook || return
            do_unhook || return
            ;;
    rem*)   remove "$DAT_UPDTHOOK"
            ;;
    upd*)   # the DAT_PACKAGE symlink serves as a flag for update-initramfs calls
            [ -e "$DAT_PACKAGE" ] || return
            actionCreate                        # make new image
            ;;
    *)      invoke -e "Invalid event: %s" "$1"
    esac
}

# ------------------------------------------------------------------------------
# action kernel: [<curr> [<back>]]
# ------------------------------------------------------------------------------
actionKernel() {
    local item stat ncur nbak curr back
    folder -f -c "$DAT_BOOTDIR"

    if [ "$1" = '-' ] ; then
        confirm -y "Make kernel/initrd links in /boot" || return
        matchpath -e "$DAT_ROOTDIR/vmlinuz" "$DAT_ROOTDIR/vmlinuz.old" \
                     "$DAT_ROOTDIR/initrd.img" "$DAT_ROOTDIR/initrd.img.old"
        for item in "${CEN_MATCHPATH[@]}" ; do
            resolve -l -s curr -- "$item" || continue
            remove -- "$item"
            symlink -n "${curr#boot/}" "$DAT_ROOTDIR/boot/${item##*/}"
        done
        create -t -c "$DAT_ROOTDIR/etc/kernel-img.conf" <<!EOF
# Kernel image management overrides
# See kernel-img.conf(5) for details
do_symlinks = yes
do_bootloader = no
do_initrd = yes
link_in_boot = yes
!EOF
        return
    fi

    for item in vmlinuz-* ; do
        [ "${item/$1/}" = "$item" ] || ncur="$item"
        [ "${item/$2/}" = "$item" ] || nbak="$item"

        if [ "$item" -ef "vmlinuz" ] ; then
            curr="$item" ; stat="[current]"
        elif [ "$item" -ef "vmlinuz.old" ] ; then
            back="$item" ; stat="[old]"
        else
            stat=
        fi
        [ $# = 0 ] && message -a -p "%-20s %s" "$item" "$stat"
    done
    [ $# = 0 ] && return                # list only

    # selected new kernel but no backup
    if [ -n "$ncur" -a -z "$nbak" -a "$curr" != "$ncur" ] ; then
        nbak="$curr"
    fi

    [ -z "$ncur" ] && ncur="$curr"
    [ -z "$nbak" ] && nbak="$back"
    [ "$nbak" = "$ncur" ] && nbak=

    if [ -z "$ncur" ] ; then
        error "No current kernel selected" ; return
    fi

    if [ "$curr" != "$ncur" -o "$back" != "$nbak" ] ; then
        message -a "Set current kernel:" "$ncur"
        message -a "    old     kernel:" "${nbak:-(none)}"
        confirm -y -q "Apply kernel changes" || return
    else
        message "No kernel changes" ; return
    fi

    ___set_kernel() {
        symlink -f "$1" "vmlinuz$2"
        local init="initrd.img${1#vmlinuz}"
        symlink -f "$init" "initrd.img$2"
    }

    [ "$curr" != "$ncur" ] && ___set_kernel "$ncur"
    [ "$back" != "$nbak" ] && ___set_kernel "$nbak" ".old"
}

# ------------------------------------------------------------------------------
# generate entries in EFI boot menu
#   (1) menu [<host|- [<volu>|- [<dist>]]]          # setup to defaults
#   (2) menu <numb> create <labl> <netw|-> <arg>... # create custom entry
#   (2) menu <numb> default [<time>]                # set boot default
#   (3) menu <numb> delete                          # delete boot entry
# ------------------------------------------------------------------------------
actionMenu() {
    local volu appl host='-' root='-' dist='-'

    case "$1" in
    ''|-)       root="${2:--}" dist="${3:--}" ;;
    [a-z]*)     host="${1:--}" root="${2:--}" dist="${3:--}" ;;
    [1-9][0-9]) appl="$1" ;;
    [0-9]*)     invoke -e "Not a valid boot entry number:" "$1" ; return ;;
    *)          invoke -e "Not a valid hostname:" "$1" ; return
    esac

    [ "$host" = '-' ] && host="$HOSTNAME"
    if ! nethost "$host" ; then
        [ -z "$CEN_OPT_SILENT" ] && invoke -w "host unknown:" "$host"
    fi

    if [ -n "$appl" ] ; then
        case "$2" in
        cre*)   ;;
        def*)   do_default "${appl}-" "$3" ; return ;;
        del*)   remove "$DAT_MOUNT/$DAT_SYSD_ENTRIES/${appl}-"* ; return ;;
        *)      invoke -a 2 'create|default|delete' ; return
        esac
        shift ; shift
    elif [ -d "$DAT_MOUNT/$DAT_SYSD_ENTRIES" ] ; then
        confirm -a -q -y "Replace existing systemd-boot entries" || return
        do_unconf machine-id                # remove debian config
        do_entry -                          # delete defaults
    else
        confirm -a -q -y "Create systemd-boot entries" || return
        folder -f -m "$DAT_MOUNT/$DAT_SYSD_ENTRIES"
    fi

    if [ "$root" = '-' ] ; then
        if [ -e "/dev/disk/by-label/${host}_vol0" ] ; then
            root="LABEL=${host}_vol0"
        elif [ -e "/dev/disk/by-label/${host}_root" ] ; then
            root="LABEL=${host}_root"
        else
            invoke -e "Please specify a boot device" ; return
        fi
    fi
    do_symlinks

    volu="${root##*_}"
    if [[ "$volu" == vol[0-9] ]] ; then
        root+=" rootflags=subvol=/Volumes/Root"
        if [ "$dist" = '-' ] ; then
            [ -d "/mnt/$volu/Volumes/Root$DAT_SUFFIX" ] && root+="$DAT_SUFFIX"
        else
            root+="-$dist"
        fi
    fi
    trace -a -c "Kernel root is" "$root"
    root="root=$root ro fsck.repair=yes"

    local netw='centauriswitch=simple'
    local opt1='mitigations=off security= quiet'
    local opt2='splash loglevel=3'
    local resu="resume="

    local ifna
    case "$CEN_OPT_IFNAMES" in
    0)  ifna=0 ;;
    1)  ifna=1 ;;
    *)  if  [ "$DAT_ETCDIR/systemd/network/99-default.link" -ef '/dev/null' ] ; then
            ifna=0
        elif netoption 'sysdnames' "$host" ; then
            ifna=1
        fi
    esac
    [ -n "$ifna" ] && opt1="net.ifnames=$ifna $opt1"

    # entry for appliance
    if [ -n "$appl" ] ; then
        local labl ; printf -v labl '%-29s.' "$1" ; shift
        [ "$1" != '-' ] && netw="$1" ; shift
        do_entry "$appl" "$labl" "$dist" "$root" "$resu" "$netw" "$opt1" "$opt2" "$@"
        return
    fi

    # network menu for: router switch repeater (see centauristartup)
    local nmen=:
    if   netoption 'router' "$host" ; then
        nmen=do_entry
    elif netoption 'switch' "$host" ; then
        nmen=do_entry
    elif netoption 'repeater' "$host" ; then
        nmen=do_entry
    fi

    # add extra options from kernel cmd line (to opt1 only)
    local xtra xfil="$DAT_MOUNT/image$DAT_SUFFIX/$DAT_CMDLINE"
    if [ -f "$xfil" ] && do_cmdline "$xfil" xtra && [ -n "$xtra" ] ; then
        confirm -a $"Add extra parameters ""($xtra)" && opt1+=" $xtra"
    fi
    [ -e "/dev/disk/by-label/${host}_swap" ] && resu="resume=LABEL=${host}_swap"

    local mode=$"Workstation"
    if [ "$host" = "${CEN_NET_SERVERS[0]}" -o "$host" = "${CEN_NET_SERVERS[1]}" ] ; then
        mode=$"Server mode"
        netw='centauriswitch=static'
        if netoption 'apoint' "$HOSTNAME" ; then
            mode+=$" with WLAN AP"
            netw+=':apoint'
        else
            netw+=":server"
        fi
    elif nethost "${host}-0" ; then
        netw='centauriswitch=smart'
    elif nethost "${host}-1" ; then
        netw='centauriswitch=smart'
    fi

    local grub="/EFI/grub/shim$DAT_ARCH_EFI"
    [ -e "$DAT_MOUNT$grub" ] || grub="/EFI/grub/grub$DAT_ARCH_EFI"

    printf -v mode '%-29s.' "Linux  : $mode"
    do_entry 90 "$mode" "$dist" "$root" "$resu"   "$netw" "$opt1" "$opt2"

    do_entry 80 $"Linux  : Maintenance mode    ." \
                "$dist" "$root" 'resume=' "$netw" "$opt1" \
                'nosplash systemd.show_status=1 systemd.unit=runlevel2.target'
    $nmen    40 $"Network: Network menu        ." \
                 "$dist" "$root" 'resume=' "centauriswitch=router" "$opt1" \
                 'nosplash centaurilogin=local systemd.unit=runlevel2.target'

    [ "$DAT_ARCH" = 'x64' ] &&
        do_entry 30 $"Memory test"   '/EFI/memtest/memtest86+x64.efi'
    do_entry 20 $"Boot via GRUB"     "$grub"
    do_entry 10 $"Windows"           '/EFI/Microsoft/boot/bootmgfw.efi'

    # update loader config
    #   we use no file-name suffix when deleting or searching entries. For multiple distros
    #   alternate entries should be manually renamed to "[0-9][1-9].conf".
    local path="$DAT_MOUNT/$DAT_SYSD_ENTRIES"
    matchpath -e -o -s path -- "$path"/9?-* "$path"/8?-* "$path"/*
    path="${path##*/}" ; path="${path%.conf}" ; [ -z "$path" ] && path='*'
    trimjoin -w -- "${path//-/ }"
    confirm -a -f -q -y $"Update loader default to '%s'" "$CEN_TRIMJOIN" || return
    do_default "$path"
}

# ------------------------------------------------------------------------------
# generate a mok key:   <cmd> <arg>...
# ------------------------------------------------------------------------------
actionMok() {
    case "${1:-status}" in
    cre*)   do_mokcreate ;;
    dec*)   do_mokdecrypt ;;
    del*)   do_mokcheck -d ;;
    imp*)   do_mokcheck && do_mokenroll ;;
    sig*)   do_mokdecrypt && do_sign "${@:2}" ;;
    sta*)   do_mokcheck -s ;;
    *)      invoke -a 1 'create|decrypt|delete|import|sign|status'
    esac
 }

# ------------------------------------------------------------------------------
# README files for boot partition
# ------------------------------------------------------------------------------
actionReadme() {
    create -c -- "$DAT_MOUNT/README" <<!EOF
Dieses Medium kann Dateisysteme enthalten, die nicht von MS-Windows
unterstützt sind. Es kann sich um ext4 oder btrfs handeln. Obwohl es
dafür Windows Treiber gibt, ist ggf. eine Linux Live CD vorzuziehen um
auf die Daten zugreifen zu können. Alternativ kann dieses Medium auf
PC-Hardware gebootet werden.

This medium may contain filesystems that are not supported by MS-Windows.
These might be ext4 or btrfs. Although there are drivers available for
Windows, using a Linux Live CD should be considered to get access to
the data. Alternately this medium can be booted on PC hardware.
!EOF

    create -c -- "$DAT_MOUNT/README-boot" <<!EOF
This setup supports

    (1) [*] legacy BIOS boot. See: 'grub' and 'grub/i386-pc'
    (2) efi GRUB boot. See: 'EFI/Debian' and 'grub/x86_64-efi'
    (3) efi systemd boot. See: 'EFI/Linux', 'EFI/systemd' and 'loader'
    (4) efi default/fallback via GRUB or systemd. See: 'EFI/boot'

    [*] optional, some installlations only, not recommended. Needs a
        BIOS partition on GPT partitioned disks. Use 'centauriefilinux
        update bios' to install.

Folder:
    grub           efi grub installation (and optionally bios)
    image          unified kernel/initrd image for systemd boot or ...
    image-<distro> ... to allow multiple distributions in parallel
    loader         systemd boot configuration
    EFI/boot       efi default/fallback bootloader
    EFI/grub       efi grub bootloader (custom build)
    EFI/systemd    systemd bootloader, configuration in 'loader'

Optional:
    EFI/memtest    efi version of memtestx86
    EFI/Microsoft/Boot/bootmgfw.efi
                   windows bootloader, usually via efi variable
    <other>/       diagnostic tools etc.

EFI-Variables:
    The primary boot loader for EFI is in EFI/boot of a bootable medium.
    Other boot loaders for EFI's boot manager can be configured using
    EFI variables. Also a boot order can be specified to prefer a boot
    loader. Most EFIs delete boot variable for devices that are detached.

    Usually the EFI/boot entry serves as a fall-back or is used to boot
    removable media. Use 'centauriefilinux efiboot' to configure EFI boot
    variables and boot order. When properly configured, EFIs boot manager
    will run the grub or systemd loader and boot manager at boot time.

Quirks:

    - Windows likes it to overwrite EFI/boot and EFI boot order .
    - systemd boot's menu (via space key) cannot be activated on
      some hardware, consider using a delay (loader/..) or grub.

Details:
    README-grub         grub installation details
    README-systemd
    README-secure-boot
!EOF

    create -c -- "$DAT_MOUNT/README-grub" <<!EOF
# This text describes grub installation details. Most of them are handled
# by 'centauridisk' (the disk setup tool) and 'centauriefilinux'.

# Documentation conventions: The boot disk could be '/dev/sda' and the EFI
# partition should be mounted at '/mnt/boot'

# For legacy BIOS Boot grub has to be installed in the bios-grub partion:

    > grub-install --target=i386-pc --boot-directory=/mnt/boot /dev/sda

# The grub EFI stuff is installed via:

    > grub-install --no-nvram --target=x86_64-efi \
                   --efi-directory=/mnt/boot /dev/sda

# grub adds it's efi modules into /mnt/boot/grub and additionally creates
# '/mnt/boot/EFI/grub'. The later contains a minimal efi image that loads
# grub modules from /mnt/boot/grub. Grub can be made the default EFI boot
# loader (see also README-systemd):

    > cp -a /mnt/boot/EFI/grub/grub$DAT_ARCH_EFI /mnt/boot/EFI/BOOT/BOOT${DAT_ARCH_EFI^^}

# To build a stand-alone custom grub bootloader use the following command:

   > grub-mkimage -d /usr/lib/grub/x86_64-efi -o /mnt/boot/EFI/Debian/boot$DAT_ARCH_EFI \
                  -p "/grub" -O x86_64-efi \
                  fat exfat ext2 btrfs iso9660 part_gpt part_msdos efifwsetup \
                  boot linux multiboot loopback chain reboot  configfile normal \
                  test loadenv keystatus  cat echo ls sleep search search_label \
                  search_fs_uuid search_fs_file  font efi_gop efi_uga gfxterm \
                  gfxterm_background gfxterm_menu all_video

# WARNING: the default boot loader must be named 'BOOT${DAT_ARCH_EFI^^}' !

# An EFI boot variable might be needed. Example:

   > efibootmgr -c -d /dev/sda -L "Grub Boot Menu" -l '\EFI\grub\grub$DAT_ARCH_EFI'

# End.
!EOF

    create -c -- "$DAT_MOUNT/README-secure-boot" <<!EOF
The Linux secure boot implementation creates it's own chain of
trust using a Microsoft signed component 'shim$DAT_ARCH_EFI' and so
called Machine Owner Keys (MOK). EFI binaries and kernel modules
can be MOK signed and are validated using shim.

When installing an image on a new machine only grub can be used
to boot the new image. See section 'Installation' below.

MOKs are X.509 certificates and a stored in EFI variables by
'mm$DAT_ARCH_EFI'. Adding a MOK is called enrollment and is handled
at boot time via shim and the MOK manager.

DKMS can be configured to MOK sign kernel modules at build time.

The details of secure boot and MOKs can be handled using the
'centauriefilinux mok' command. A centauri site will keep a site
specific MOK in its repository.

Usually the MOK certificate private key is encrypted (using a
pass phrase). This creates problems with unattended upgrades.
So 'centauriefilinux' can decryt the key on repository import.
This is a security risk that allows malware to sign any sort
of kernel module or EFI binary.

The EFI boot entries for secure boot should look like this:

  ├── EFI
  │   ├── BOOT              # default boot entry ...
  │   │   ├── BOOTX64.EFI   # debian's shim64.efi
  │   │   ├── mmx64.efi     # debian's signed MOK manager
  │   │   └── fbx64.efi     # debian's signed boot fallback manager
  │   ├── grub
  │   │   ├── BOOTX64.CSV   # fallback, points to shimx64
  │   │   ├── grub.cfg      # delegate to /grub/grub.cfg
  │   │   ├── grubx64.efi   # debian's signed grub
  │   │   ├── mmx64.efi     # debian's signed MOK manager
  │   │   └── shimx64.efi   # debian's signed shim
  │   └── systemd
  │       ├── BOOTX64.CSV   # fallback, points to shimx64
  │       ├── grubx64.efi   # renamed systemd bootx64.efi, MOK signed
  │       ├── mmx64.efi     # debian's signed MOK manager
  │       └── shimx64.efi   # debian's signed shim

The 'fbx64.efi' generates EFI boot variables from BOOTX64.CSV files.


Installation
============

When installing a centauri image on a new machine, the MOK key must
be enrolled before secure boot can be enabled. Use method (1)...(3):

    (1) centauriefilinux setup          # from repository, enroll MOK
    (2) centauriefilinux mok import     # from default in: /etc/mok
    (3) mokutil --import ...            # see man page

The unified kernel image used be systemd-boot (and systemd-boot it-
self) are MOK signed. So if secure boot is enabled systemd-boot
cannot be used before the MOK is enrolled. Only 'grub' can boot in
such a situation (grub and the kernel are signed with a distribution
owner key that is built into shim).
!EOF

    create -c -- "$DAT_MOUNT/README-systemd" <<!EOF
# systemd-boot-efi must be installed to boot via the lightweight
# systemd boot manager. This text provides documentation for some
# configuration details ...

# Although the preferred method to boot can be systemd boot, some
# extra EFI boot loaders should be installed. Typical folders are:

- /mnt/boot/EFI/boot    is the EFI default/emergency bootloader.
  This should contain a copy of the /mnt/boot/EFI/systemd bootloader
  'bootx64.efi' or 'shimx64.efi'. See 'README-secure-boot'

- /mnt/boot/EFI/grub    is the GRUB EFI bootloader location. The
  GRUB bootloader installation is documented in 'README-grub' and
  'README-secure-boot'

- /mnt/boot/EFI/systemd is the systemd bootloader location. This
  must contain a copy of 'grubx64.efi' and optionally 'shimx64.efi',
  see 'README-secure-boot'

- /mnt/boot/image       contains the unified kernel/initrd image to
  be loaded by the systemd bootloader. When multiple distros are
  installed in parallel there may be distro specific folders like

  /mnt/boot/image-bullseye
  /mnt/boot/image-bookworm

- /mnt/boot/loader      contains the systemd boot configuration.
  Systemd's boot manager uses '*.conf' files in sub folder'entries'
  to display a boot menu. Some entries like the default boot loader
  or MS-Windows are automatically shown. See 'centauriefilinux menu'.

# The systemd bootloader can be updated/installed via

    > bootctl --esp-path=/mnt/boot --no-variables update

# ... or ...

    > cp -a /usr/lib/systemd/boot/efi/systemd-bootx64.efi \
            /mnt/boot/EFI/systemd/systemd-bootx64.efi

# ... or /admin/centauriefilinux which also manages the
# configuration in '/mnt/boot/loader' and the kernel/initrd image.
!EOF
}

# ------------------------------------------------------------------------------
# setup secure boot
# ------------------------------------------------------------------------------
actionSetup() {
    if [ -n "$CEN_OPT_PLAIN" ] ; then
        invoke -e "SecureBoot disabled or shim not installed"
        return
    fi
    system -c -f mokutil sbsign openssl
    folder -m -p -f "$DAT_MOKDIR"

    message "Preparing the MOK ..."
    embed centauriconfig put MOK.der -- put MOK.pem -- put MOK.priv
    if ! [ -f "$DAT_MOKDIR/MOK.priv" ] ; then
        invoke -e "Got no MOK key from repository, try '$CEN_NAME mok create'"
        return
    fi

    # decrypt MOK private key, register with dkms
    do_mokdecrypt -k

    message "Create menu entries for systemd-boot ..."
    actionMenu

    message "Preparing SecureBoot ..."
    do_mokenroll
    case "$?" in
    0)  message -a "Done." ;;
    2)  confirm -a "Run '$CEN_NAME update -' to update EFI boot" && actionUpdate -
        message -a "Done, please reboot to enroll the MOK!" ;;
    esac
}

# ------------------------------------------------------------------------------
# update boot loaders: [bios|grub|systemd|-]
# ------------------------------------------------------------------------------
actionUpdate() {
    if findmount -- - "$DAT_MOUNT" ; then
        blkdevice -m -e -- "$CEN_MOUNT_DEV" || return
    else
        error "Could not find device for mount:" "$DAT_MOUNT" ; return
    fi
    local curr="$PWD" ; folder -c -f -- "$DAT_MOUNT"

    # remove debian config
    do_unconf   machine-id
    do_unconf   boot
    do_unconf   debian
    do_unconf   grub
    do_unconf   systemd

    if [ -z "$CEN_OPT_PLAIN" ] ; then
        message "Configure for secure-boot:" "${1/-/boot, systemd, grub}"
        case "$1" in
        -)      do_shim "$DAT_EFI_BOOTDIR" &&
                do_shim "$DAT_EFI_DISTDIR" &&
                do_shim "$DAT_EFI_SYSDDIR" &&
                do_memt ;;
        bios)   do_bios ;;
        boot)   do_shim "$DAT_EFI_BOOTDIR" ;;
        grub)   do_shim "$DAT_EFI_DISTDIR" ;;
        mem*)   do_memt ;;
        sys*)   do_shim "$DAT_EFI_SYSDDIR" ;;
        *)
                invoke -e "Invalid argument:" "$1"
        esac
    else
        message "No secure-boot support"
        case "$1" in
        -)      do_plain "$DAT_EFI_BOOTDIR" &&
                do_plain "$DAT_EFI_DISTDIR" &&
                do_plain "$DAT_EFI_SYSDDIR" &&
                do_memt ;;
        bios)   do_bios ;;
        boot)   do_plain "$DAT_EFI_BOOTDIR" ;;
        grub)   do_plain "$DAT_EFI_DISTDIR" ;;
        mem*)   do_memt ;;
        sys*)   do_plain "$DAT_EFI_SYSDDIR" ;;
        *)
                invoke -e "Invalid argument:" "$1"
        esac
    fi
    folder -c -f -- "$curr"
}

# ------------------------------------------------------------------------------
# option parsing: <option> [<argument>]
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    '')     if [ -n "$CEN_OPT_ROOT" ] ; then
                [ -z "$CEN_OPT_BASE" ] &&
                    quit -e -p "Cannot use '%s' without '%s'" '--root=<root>' '--base=<efi-folder>'
                local name root="${CEN_OPT_ROOT%/}"
                for name in "${DAT_PREFIX[@]}" ; do
                    [ -n "$name" ] && eval printf -v $name '%s' $root\$$name
                done
                trace -a -c 'Kernel folder' "$DAT_BOOTDIR"
            fi

            do_mount ; do_suffix ; do_efichk            # helpers may call quit
            DAT_PACKAGE="$DAT_BOOTDIR/$DAT_PACKAGE"
            if [ -z "$CEN_OPT_PLAIN" ] ; then           # check for shim and mok ...
                if [ -f "$DAT_DIST_SHIM" ] ; then
                    [ -e "$DAT_MOKDIR/MOK.key" ] || CEN_OPT_PLAIN=1
                else
                    CEN_OPT_PLAIN=3
                    [ -e "$DAT_MOKDIR/MOK.key" ] && CEN_OPT_PLAIN=2
                fi
            else
                CEN_OPT_PLAIN=3
            fi
            [ -n "$CEN_OPT_PLAIN" ] && trace "Option '--plain' implied (info=$CEN_OPT_PLAIN)"

            sysversion -a -e
            case "$CEN_SYS_PLATFORM-$CEN_SYS_CPU_ARCH" in
                rpi*)     DAT_ARCH='-' ;;
                *-arm64)  DAT_ARCH='aa64' ;;
                *)        DAT_ARCH='x64'
            esac
            DAT_ARCH_EFI="$DAT_ARCH.efi"
            ;;

    -B|--bas|--base)    optarg 'base'        -   -d  ;;     # folder
    -E|--ext*)          optarg 'extern'      -   -o  ;;     # ternary
    -F|--ifn*)          optarg 'ifnames'     -   -o  ;;     # ternary
    -I|--img|--ima*)    optarg 'image'       -   -t  ;;     # text
    -N|--nic*)          optarg 'nickname'    -   -t  ;;     # text
    -P|--pla*)          optarg 'plain'       -   -f  ;;     # flag
    -R|--roo|--root)    optarg 'root'        -   -d  ;;     # folder
    esac
}

# ------------------------------------------------------------------------------
# action parsing: <verb> <argument>...
# ------------------------------------------------------------------------------
actions() {
    case "$1" in

    boo*)
        invoke -r 'bootctl'  -           ;;
    cmd*)
        invoke -r 'cmdline'  -       0 1 ;;                 # 0 .. 1 args
    cre*)
        invoke -r 'create'   -       0 2 ;;                 # 0 .. 2 args
    efi*)
        invoke -r 'efimgr'   -           ;;
    hoo|hook)
        invoke    'hook'     -         1 ;;                 # one arg
    ker*)
        invoke -r 'kernel'   -       0 2 ;;                 # 0 .. 2 args
    men|menu)
        invoke -r 'menu'     -           ;;
    mok)
        invoke -r -          -           ;;
    rea*)
        invoke -r 'readme'   -           ;;
    set*)
        invoke -r 'setup'    -           ;;
    upd*)
        invoke -r 'update'   -       1 2 ;;                 # one or two args

    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    do_mount -h ; do_suffix
    usageset \
        -o - \
        -o '-B --base     <path> '$"EFI mount point or EFI folder (default: $DAT_MOUNT)" \
        -o '-E --external <extd> '$"External disk    (0:=no  1:=yes  2:=auto)" \
        -o '-F --ifnames  <mode> '$"Interface naming (0:=kernel  1:=systemd  2:=auto)" \
        -o '-I --image    <file> '$"relative linux EFI image path (default: $DAT_IMAGE)" \
        -o '-N --nickname <nick> '$"force distribution nick name  (default: $CEN_OPT_NICKNAME)" \
        -o '-P --plain           '$"ignore secure boot shim, mok and signing" \
        -o '-R --root     <path> '$"root file sytem to be used    (default: /)"

    usagecat << !EOF
$CEN_USE_HEADER

$CEN_USE_OPTIONS

actions:
       bootctl [list|...]   run bootctl on EFI partition
       cmdline copy|edit    copy current /proc/cmdline or edit saved
       cmdline [show|boot]  show saved settings or show current boot status
       create [<image>|- [<message>|-]]
                            create UKI (unified kernel image) EFI binary
       efimgr  --- <arg>... run efibootmgr on EFI partition
       efimgr  add <label> <path>
                            add a boot entry, <path> is relative
       efimgr  delete <n>   delete boot entry <n>
       efimgr  entry grub|systemd
                            add a boot entry for grub or systemd boot
       efimgr  order <n>[,<n>]...
                            set boot order
       hook    <event>      handle update-initramfs events
       kernel               show bootable kernels
       kernel  <curr> [<back>]
                            set current and failsafe kernel and initrd
       kernel  -            make kernel links in /boot folder
       menu    [<host|- [<volu>|- [<nick>]]]
                            generate default entries in EFI boot menu
       menu    <numb> create <label> <netw|-> <arg>...
                            create custom boot entry
       menu    <numb> default [<time>]
                            set default boot entry and menu timeout
       menu    <numb> delete
                            delete boot entry (implies 'menu 90 default')
       mok     [status]     show MOK (machine owner key) status
       mok     sign <ebin> [-|.]
                            sign an EFI binary, see 'sbsign', use '.' for in-place
       mok     create|delete|decrypt|import
                            MOK management, see 'mokutil'
       readme               create a set of README files in EFI partition
       setup                MOK setup, repository, enrollment, dkms
       update  [boot|bios|grub|memtest|systemd|-]
                            update boot loaders, use '-' for all except bios

arguments:
       <event>              update (by update-initramfs)  remove (uninstall hook)
       <curr> <back>        a kernel version
       <dflt>               boot preset: default workstation menu maintenance
       <ebin>               path of an efi binary to be signed
       <host>               override current host name
       <image>              image folder/path         (default: image-<nick>)
       <label>              label text for boot entry
       <message>            text in systemd boot logo (default: Booting Debian <nick>)
       <netw>               network mode/config, see centauriswitch
       <nick>               distribution name, '-' for no path suffixes
       <numb>               2 digit boot entry number
       <volu>               root path, suffix, '+' for nick (default: $DAT_SUBVOL)

examples:
       # setup ...
       $CEN_NAME setup              # automatic setup from repository
       $CEN_NAME update -           # grub/systemd installation/update
       $CEN_NAME create -- menu     # systemd kernel image and boot menu
       $CEN_NAME menu t1 t1_root    # boot menu for 't1' with LABEL=t1_root
       $CEN_NAME menu - - bookworm  # boot menu entries for bookworm distro

       # MOK keys ...
       $CEN_NAME mok                # show secure boot status
       $CEN_NAME mok import         # enroll key, needs reboot
       $CEN_NAME mok sign "/EFI/memtest/memtest86+x64.efi" .

       # update EFI variables ...
       $CEN_NAME efi delete 4       # delete boot entry
       $CEN_NAME efi add "memory test" "/EFI/memtest/memtest86+x64.efi"
       $CEN_NAME efi entry systemd  # add systemd entry
       $CEN_NAME efi order 2,1,0    # set boot order

       # list systemd boot config
       $CEN_NAME boot list
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
