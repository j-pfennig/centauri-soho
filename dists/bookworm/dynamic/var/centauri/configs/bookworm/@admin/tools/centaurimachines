#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. J. Pfennig (c) 2020-2025; BSD License"
CEN_TITLE=$"Manage repository staging and samba-ad/ntfs integration"

PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -m con -r -s -y - '0.18:4' || exit 2

# Data
CEN_OPT_DOMAIN=                 # see --domain
CEN_OPT_NICK=                   # see --nick

CEN_OPT_ADD=                    # see --add
CEN_OPT_CHANGES=                # see --changes
CEN_OPT_DELETE=                 # see --delete
CEN_OPT_EDIT=                   # see --edit
CEN_OPT_EXEC=                   # see --execute
CEN_OPT_LIST=                   # see --list
CEN_OPT_MERGE=                  # see --merge
CEN_OPT_PATH=                   # see --path
CEN_OPT_SETUP=                  # see --setup
CEN_OPT_UPDATE=                 # see --update

DAT_BASE="$CEN_ROOT/machines"
DAT_ROOT="$DAT_BASE"
DAT_MAND=                       # updated in run() ...
DAT_DIST=
DAT_HEADER='message -d 1 -c'
DAT_MESSAGE='message -a'
DAT_SINGLE_MACHINE=
DAT_TEMPLATE=()                 # see do_rsyncd, repository.template

declare -A DAT_MAP_DISTUPD      # change state of distrib repos

# crate rsyncd.conf: <rsyn> <tmpl>
do_config() {
    local empt lesc='***'
    if [ "$1" = '-' ] ; then
        empt='Â°' ; lesc='*<>*<>*'
    fi
    [ -z "$DAT_MAND" ] && netquery -s DAT_MAND domain
    DAT_MAND="${DAT_MAND%%.*}"

    create -c -t -- "$1" <<!EOF
# File '$DAT_BASE/rsyncd.conf' is the header of '/etc/rsyncd.conf'
# which is generated by $CEN_NAME to grant clients repository access.
# This file can be used to configure rsyncd modules that are not managed
# by centauriconfig and $CEN_NAME ...
$empt
gid = users
read only = false
use chroot = true
log format = %h %o %f %l %b
$empt
### public data (site specific modules) ###
$empt
#[music]
#        read only = true
#        path = /export/Music
#        comment = Music library example configuration
#        uid = smbworld
#        gid = users
$empt
### administration (used by $CEN_NAME) ###
$empt
[@$DAT_MAND]
$empt        path = $CEN_ROOT
$empt        read only = false
$empt        comment = System administration tools and data
$empt        auth users = root
$empt        uid = root
$empt        gid = root
$empt        include = /archived /archived/$DAT_MAND/$lesc /backup /backup/$DAT_MAND /configs /configs/* /configs/*/@admin/$lesc /configs/*/@soho/$lesc /configs/*/$DAT_MAND/$lesc
$empt        exclude = *
$empt        secrets file = $CEN_ROOT/secrets/rsyncd_$DAT_MAND.secret
$empt
### autogenerated data (used by $CEN_NAME) ###
$empt
!EOF

    # per machine template

    create -c -t -- "$1" <<!EOF
# File '$DAT_BASE/repository.template' is the template for per-machine rsyncd.conf fragments
#
# Substitions:  \$M  distribution
#               \$H  machine name
#               \$P  base path + distribution
#
[@\$M-\$H]
$empt        path = \$P/\$H/repository
$empt        read only = false
$empt        comment = System administration tools and configuration
$empt        auth users = root
$empt        uid = root
$empt        gid = root
$empt        include = /archived /archived/\$M/*** /backup /backup/\$M /configs /configs/* /configs/*/@admin/*** /configs/*/@soho/*** /configs/*/\$M/***
$empt        exclude = *
$empt        secrets file = \$P/\$H/repository.secret
$empt
!EOF
}

# create pre machine rsyncd.conf: <mach>
do_rsyncd() {
    local line text=() host="$1" path="$DAT_BASE"
    [ "$DAT_ROOT/repository.template" -nt "$path/$host/repository.rsyncd" ] || return

    [ "${#DAT_TEMPLATE[@]}" = 0 ] &&
        inpdata -a DAT_TEMPLATE -- "$DAT_ROOT/repository.template"
    for line in "${DAT_TEMPLATE[@]}" ; do
        [ "${line::1}" = '#' ] && continue
        line="${line//\$M/$DAT_MAND}" ; line="${line//\$H/$host}"
        text+=("${line//\$P/$path}")
    done
    create -t -v text -- "$path/$host/repository.rsyncd" 660
}

# reflink newer files, remove deleted files: <source> <dest>
do_update() {
    [ -d "$1" ] || return
    trace -a "$1  ==>  $2"
    # use reflinks copy to update new files...
    system -e -n -p -t -- cp -a -u --reflink "$1" "$2"

    # run rsync --delete to remove deleted files
    local updt='--update'
    [ -n "$CEN_OPT_FORCE" ] && updt=
    system -e -n -p -t -- rsync -v --archive --protect-args --whole-file $updt --delete "$1" "$2"
}

do_merge() {
    if [ ! -e "$2/$1" ] ; then
        trace -a -c "No such origin:" "$2/$1"
    elif [ -n "$CEN_OPT_FORCE" ] ; then
        system -e -n -p -t -- cp -a -u --reflink "$2/$1" "$3"
    else
        embed -i -t -v -y centauridiff ${CEN_OPT_SILENT:+-s} --merge "$2/$1" "$3/$1"
    fi
}

# ------------------------------------------------------------------------------
# create machine repository: <host>[/<idnt>]
# ------------------------------------------------------------------------------
run_add() {
    local host="${1%%/*}" mreg
    local pasw="${1#*/}" ; [ "$1" = "$pasw" ] && pasw=
    local maid="$host/machine-id"
    local repo="$host/repository"
    local ktab="$host/krb5.keytab"
    local pasc ; [ -s "$maid" ] && pasc="$(<$maid)"

    # save machine id
    if [ -n "$pasw" ] ; then
        if [ -z "$CEN_OPT_FORCE" -a -n "$pasc" -a "$pasc" != "$pasw" ] ; then
            error "Use --force to change the machine-id" ; return
        fi
        mreg=" (register)"
        create -t -v pasw "$maid" 660 root:wheel
    # must have machine id file otherwise...
    elif [ "$host" = "$HOSTNAME" ] ; then
        copy '/etc/machine-id' "$maid"
    else
        pasw="$pasc"
        if [ -z "$pasw" ] ; then
            error "Cannot read secret:" "$host" ; return
        fi
    fi
    $DAT_HEADER "Adding machine" "$host$mreg"

    # create repository
    if [ -L "$repo" -a -d "$repo/configs" ] ; then
        $DAT_MESSAGE "Keeping repository link"
    elif [ "$host" = "$HOSTNAME" ] ; then
        $DAT_MESSAGE "Repository is local"
        symlink -n '../../..' "$repo"
    else
        [ -n "$CEN_OPT_FORCE" -a -e "$repo" ] && remove -d "$repo"

        folder -m "$repo"           775 'root:wheel'
        folder -m "$repo/archived/$DAT_MAND" 770 'root:wheel'
        folder -m "$repo/backup/$DAT_MAND"   770 'root:wheel'

        folder -m "$repo/configs"   775 'root:wheel'
        local dest="$repo/configs/$DAT_DIST"
        folder -m "$dest"           775 'root:wheel'
        folder -m "$dest/$DAT_MAND" 775 'root:wheel'
        error -t || return
        [ -z "$CEN_OPT_UPDATE" ] && run_update "$host"
    fi

    # create repository.conf
    create -c -t "$repo.conf" 600 <<!EOF
CEN_RSYNC_MODULE=$DAT_MAND-$host
CEN_RSYNC_PASSWD=$pasw
!EOF

    # create repository.secret
    create -c -t "$repo.secret" 600 <<!EOF
root:$pasw
!EOF
    do_rsyncd "$host"                               # create repository.rsyncd

    # update staging repository
    $DAT_MESSAGE "Updating staging repository"
    run_update "$host"

    # add to kerberos and get keytab
    if [ -e "$ktab" -a -z "$mreg" ] ; then
        $DAT_MESSAGE "Keeping kerberos state"
    else
        # create AD/DC machine account, save keytab in repo, add IP addr to AC/DC dns
        local skey="$CEN_ROOT/machines/$DAT_DIST/$hnam/krb5.keytab"
        embed -t -v -y centaurikerberos -O "$skey" -s -y \
            machine add "$host" -- keytab "$host" -- host add "$host"
    fi
}

# ------------------------------------------------------------------------------
# worker
# ------------------------------------------------------------------------------
run_delete() {
    local host="$1" deld
    if [ ! -e "$host" ] ; then
        error "No such machine: $host" ; return
    elif [ -L "$host/repository" ] ; then             # not if symlinked
        error "Won't delete symlinked machine: $1" ; return
    fi

    if [ -n "$CEN_OPT_NICK" ] ; then
        local ddis dmor
        local dest dist dlis=("$host/repository/configs/"*)
        for dest in "${dlis[@]}" '' ; do
            [ -z "$dest" ] && break                 # end of list
            [ -d "$dest" ] || continue    # no repository
            dist="${dest##*/}"
            if [ "$CEN_OPT_NICK" = "$dist" ] ; then
                ddis="$dest"
            else
                dmor=1
            fi
        done
        if [ -z "$ddis" ] ; then                    # not found
            error "Distribution not found: $host ($CEN_OPT_NICK)" ; return
        fi
        if [ -n "$dmor" ] ; then                    # dist only
            $DAT_HEADER "Delete machine" "$host ($dist)"
            deld="$ddis"
        fi
    fi

    if [ -z "$deld" ] ; then
        $DAT_HEADER "Delete machine" "$host"
        deld="$host"
    fi
    remove -d -- "$deld"
    embed -t -v -y centaurikerberos -O- -s -y -- machine del "$host" -- host del "$host"
}

# ------------------------------------------------------------------------------
# List machines: <path>
# ------------------------------------------------------------------------------
run_list() {
    local nick="${1%/*}"
    if [ "$DAT_NICK" != "$nick" ] ; then
        $DAT_HEADER "Distribution hosts" "$nick"
        DAT_NICK="$nick"
    fi
    readline -i "$1/machine-id" || CEN_READLINE="-- orphan --"

    local conf list namd namh="${1#*/}" base="$1/repository/configs/$nick"
    local md5m md5s
    for conf in "$base"/[!@]* ; do
        namd="${conf##*/}"
        [ -n "$CEN_OPT_DOMAIN" ] && [ "$CEN_OPT_DOMAIN" != "$namd" ] && continue
        matchpath -a list -e -- "$conf/$namh/d_etc_mok+MOK.pem" \
                                "$conf/@shared/d_etc_mok+MOK.pem" \
                                "$conf/$namh/a_etc_ssh+ssh_host_rsa_key.pub" \
                                "$conf/@shared/a_etc_ssh+ssh_host_rsa_key.pub"
        if [ -n "$list" ] ; then
            system -a list -d '--' -- md5sum "${list[@]}"
            listsearch -c -g -i list -m md5m -o '*MOK.pem' ; md5m="${md5m%% *}"
            listsearch -c -g -i list -m md5s -o '*key.pub' ; md5s="${md5s%% *}"
        else
            md5m= ; md5s=
        fi
        message -a -p "%-12s %-10s %s  %12s  %12s" \
                      "$namh" "$namd" "$CEN_READLINE" "$md5m" "$md5s"
        namh=
    done
}

# ------------------------------------------------------------------------------
# get file paths: <file>
# ------------------------------------------------------------------------------
run_path() {
    local host="$1"
    local dest="$PWD/$host/repository/configs/$DAT_DIST"
    local orig="$CEN_ROOT/configs/$DAT_DIST"
    local file="$CEN_OPT_PATH" item splt

    if [ -n "$CEN_OPT_EDIT" ] ; then
        item="Edit"
    elif [ "$CEN_OPT_EXEC" = '-' ] ; then
        item="Exec"
    else
        item="Path"
    fi
    $DAT_HEADER "$item machine" "$host ($DAT_DIST:$DAT_MAND)"

    ___pathchk() {
        for item in "$1$file" "$DAT_MAND/$1$file" - ; do
            [ "$item" = '-' ] && return 1
            #message "PATH $orig/$item"
            [ -e "$orig/$item" ] && break
            #message "PATH $dest/$item"
            [ -e "$dest/$item" ] && break
        done
        file="$item" ; return 0
    }

    case "$file" in
        /*)                                         # mangle name
            splitpath -a splt -p -- "${file:1}"
            file="${splt//\//_}+${splt[1]}"
            ___pathchk "@shared/d_" || ___pathchk "@shared/a_" || file="$CEN_OPT_PATH"
            ;;
        @*)
            ___pathchk
            ;;
        ?_*)
            ___pathchk "@shared/"
            ;;
        *)
            ___pathchk "@admin/tools/" || ___pathchk "@admin/library/"
    esac

    dest+="/$file" ; orig+="/$file"
    if [ ! -e "$dest" ] ; then
        error $"File not in destination:" "${dest#$PWD/}"
        dest=
    fi
    if [ ! -e "$orig" ] ; then
        error $"File not in origin:" "${orig#$PWD/}"
        orig=
    fi
    [ -z "$dest" -o -z "$orig" ] && return

    if [ -n "$CEN_OPT_EDIT" ] ; then
        embed -r -z centauridiff --prompt --fix "$dest" "$orig"
    elif [ "$CEN_OPT_EXEC" = '-' ] ; then
        embed -r -z centauridiff --pager=true "$dest" "$orig"
    elif [ "$CEN_OPT_EXEC" = '+' ] ; then
        embed -r -z centauridiff --kompare --fix "$dest" "$orig"
    elif [ -n "$CEN_OPT_EXEC" ] ; then
        $CEN_PAGER "$CEN_OPT_EXEC" "$dest" "$orig"
    else
        echo "$dest"
        echo "$orig"
    fi
}

# ------------------------------------------------------------------------------
# worker
# ------------------------------------------------------------------------------
run_merge() {
    local host="$1"
    local dest="$host/repository/configs/$DAT_DIST"
    local darc="$host/repository/archived/$DAT_MAND/$host"
    [ -L "$host/repository" ] && return     # not if symlinked
    [ -e "$host/repository" ] || return     # no repository
    [ -d "$dest" ] || return
    $DAT_HEADER "Merge machine" "$host (${dest##*/})"

    # option --change
    if [ -n "$CEN_OPT_DRYRUN" -o -n "$CEN_OPT_CHANGES" ] ; then
        embed -r -i centauricopy --dry update "$dest" "$CEN_ROOT/configs/$DAT_DIST" \
                                -x _centauri_bash_completion -x _centauri_bash_lib -s
        [ "$darc" -nt "$CEN_ROOT/archived/$DAT_MAND/$host" ] &&
            message -i  "=>  $CEN_ROOT/archived/$DAT_MAND/$host"
        return
    fi

    # option --merge
    [ "$darc" -nt "$CEN_ROOT/archived/$DAT_MAND/$host" ] &&
        copy -a "$darc"  "$CEN_ROOT/archived/$DAT_MAND/$host"
    do_merge '@admin'    "$dest"           "$CEN_ROOT/configs/$DAT_DIST"
    do_merge '@shared'   "$dest/$DAT_MAND" "$CEN_ROOT/configs/$DAT_DIST/$DAT_MAND"
    do_merge "$host"     "$dest/$DAT_MAND" "$CEN_ROOT/configs/$DAT_DIST/$DAT_MAND"
    [ -d "$dest/@soho" ] &&
        do_merge '@soho' "$dest"           "$CEN_ROOT/configs/$DAT_DIST"
}

# ------------------------------------------------------------------------------
# worker
# ------------------------------------------------------------------------------
run_update() {
    # a host may have multiple distros, loop if no --nick is given ...
    local host="$1" hoso
    [ -L "$host/repository" ] && return             # not if  symlinked
    [ -e "$host/repository" ] || return             # no repository

    local dest dist mand
    local dlis=("$DAT_ROOT/$DAT_DIST/$host/repository/configs/$DAT_DIST/$DAT_MAND")
    [ -n "$CEN_OPT_UPDATE" -a -z "$CEN_OPT_DOMAIN" ] &&
        dlis=("$DAT_ROOT/$DAT_DIST/$host/repository/configs/$DAT_DIST/"[a-z]*)

    for dest in "${dlis[@]}" '' ; do
        [ -z "$dest" ] && return                    # end of list
        [ -d "$dest" ] || continue                  # no repository
        mand="${dest##*/}"
        dist="$DAT_DIST"
        dest="${dest%/*}"
        trace -a -c "Update $host" "$dist $mand $dest"

        # copy 'archived' to repository
        local darc="$host/repository/archived/$mand/$host"
        [ "$darc" -nt "$CEN_ROOT/archived/$mand/$host" ] &&
            copy -a -- "$darc" "$CEN_ROOT/archived/$mand/$host"

        # check if repository was changed since last full run
        if dryrun || [ -n "$DAT_SINGLE_MACHINE" -o -n "$CEN_OPT_FORCE" ] ; then
            DAT_MAP_DISTUPD["$dist"]=0
        elif [ -z "${DAT_MAP_DISTUPD["$dist"]}" ] ; then
            embed -v -n -i centauritime check "$CEN_ROOT/configs/$dist"
            DAT_MAP_DISTUPD["$dist"]=$?
        fi
        [ "${DAT_MAP_DISTUPD["$dist"]}" = 0 ] || continue

        [ "$host" = "$hoso" ] || CEN_AUTOIND=       # reset indentation
        hoso="$host"

        if [ -n "$CEN_OPT_ADD" ] && [ ! -d "$dest/$mand/$host" ] ; then
            folder -m -f "$dest/$mand/$host"
            $DAT_HEADER "Create machine" "$host ($dist)"
        elif [ ! -d "$dest/$mand/$host" ] ; then
            trace -a -c "Not configured" "$host ($dist:$mand)"
            continue
        else
            $DAT_HEADER "Update machine" "$host ($dist)"
        fi

        if [ -n "$CEN_OPT_DRYRUN" ] ; then
            embed -r -i centauricopy -s --dry update "$dest/$mand/$host" \
                                            "$CEN_ROOT/configs/$dist/$mand/$host"
            embed -r -i centauricopy -s --dry update "$CEN_ROOT/configs/$dist" "$dest" \
                                -i '/@admin' -i "/$mand/@shared" \
                                -i "/$mand/$host" -x '/*'  -x '*.pyc' -x '*~' \
                                -x '_centauri_bash_completion' -x '_centauri_bash_lib'
            continue
        fi

        # create an empty backup list
        if [ ! -e "$darc" ] ; then
            folder -m -- "${darc%/*}" && create -- "$darc"
            message -a "Created:" "$darc"
        fi

        # merge back config updates of this host but only if PACKAGES exists ...
        [ -e "$dest/$mand/$host/PACKAGES" ] &&
            do_update "$dest/$mand/$host" "$CEN_ROOT/configs/$dist/$mand"

        do_update "$CEN_ROOT/configs/$dist/@admin"        "$dest"
        do_update "$CEN_ROOT/configs/$dist/$mand/@shared" "$dest/$mand"
        do_update "$CEN_ROOT/configs/$dist/$mand/$host"   "$dest/$mand"
        do_rsyncd "$host"
    done
}

# ------------------------------------------------------------------------------
# The one and only action
# ------------------------------------------------------------------------------
run() {
    context -r || return
    system -c -- rsync cp rm
    folder -c -f ${CEN_OPT_SETUP:+-m} "$DAT_BASE"

    # get domain os version

    local temp
    if [ -n "$CEN_OPT_DOMAIN" ] ; then
        DAT_MAND="$CEN_OPT_DOMAIN"
    else
        netquery -s DAT_MAND domain
    fi
    if [ -n "$CEN_OPT_NICK" ] ; then
        DAT_DIST="$CEN_OPT_NICK"
    else
        sysversion -f
        DAT_DIST="$CEN_SYS_NICKNAME"
    fi
    if [ -d "$DAT_DIST" ] ; then
        DAT_BASE+="/$DAT_DIST"
        folder -c -f ${CEN_OPT_SETUP:+-m} "$DAT_BASE"
    fi

    DAT_MAND="${DAT_MAND%%.*}"
    temp="$CEN_ROOT/configs/$DAT_DIST/${DAT_MAND:--}"
    [ -d "$temp" ] || quit -e "Main repository not found:" "$temp"
    trace -a -c "Main repository" -- "$temp"

    # setup staging folder

    if [ -n "$CEN_OPT_SETUP" ] ; then
        do_config 'rsyncd.conf' 'repository.template'
    fi

    # get list of machines

    if [ -n "$CEN_OPT_LIST" ] ; then
       # [ -z "$CEN_OPT_NICK" ]
       folder -f -c -- "$DAT_ROOT"
        DAT_NICK=
        if [ -z "$CEN_OPT_NICK" ] ; then
            matchpath -d -c run_list -- */*
        else
            matchpath -d -c run_list -- "$CEN_OPT_NICK"/*
        fi
        return
    fi

    local fall mach marg mlis=()
    if [ $# = 0 ] ; then
        matchpath -f -a mlis -- */machine-id
        fall=1 ; set -- "${mlis[@]%/*}"
        mlis=()
    else
        DAT_SINGLE_MACHINE=1
    fi
    for marg in "$@" ; do
        mach="${marg%%/*}"                      # strip machine-id
        if [ -n "${mach//[-_a-z0-9]/}" ] ; then
            [ -z "$fall" ] && error "Not a valid machine name:" "$mach"
            continue
        elif [ ! -d "$mach" ] ; then
            if [ -n "$CEN_OPT_ADD" ] ; then
                folder -m -f "$mach"
            else
                [ -z "$fall" ] && error "Not a machine folder:" "$mach"
                continue
            fi
        elif [ -n "$CEN_OPT_DELETE" ] ; then
            :
        elif [ "$marg" = "$mach" ] && [ ! -f "$mach/machine-id" ] ; then
            [ -z "$fall" ] && error "Not a registered machine:" "$mach"
            continue
        fi
        mlis+=("$marg")
    done
    error -t || return

    # call worker for machine

    for mach in "${mlis[@]}" ; do
        [ -n "$CEN_OPT_ADD"     ] && run_add    "$mach"
        [ -n "$CEN_OPT_CHANGES" ] && run_merge  "$mach"
        [ -n "$CEN_OPT_DELETE"  ] && run_delete "$mach"
        [ -n "$CEN_OPT_MERGE"   ] && run_merge  "$mach"
        [ -n "$CEN_OPT_PATH"    ] && run_path   "$mach"
    done
    error -t || return

    [ -z "$CEN_OPT_DELETE"  ] &&
        for mach in "${mlis[@]}" ; do
            [ -n "$CEN_OPT_UPDATE" ] && run_update "$mach"
        done
    error -t || return

    # generate rsyncd.conf

    [ -n "$CEN_OPT_EDIT$CEN_OPT_EXEC$CEN_OPT_PATH" ] && return

    [ -e 'rsyncd.conf' ] || quit -e "Missing static config file:" 'rsyncd.conf'
    if ! dryrun "Create /etc/rsyncd.conf" ; then
        local lsyn
        folder -c -f -- "$DAT_ROOT"
        matchpath -f -a lsyn -e */repository.rsyncd */*/repository.rsyncd
        message -p "Configuring 'rsyncd' for %s repositories" "${#lsyn[@]}"
        cat 'rsyncd.conf' "${lsyn[@]}" > '/etc/rsyncd.conf' || quit -e
    fi
}

# ------------------------------------------------------------------------------
# option parsing: <option> [<argument>]
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    '')
        local optc=() optx=()
        [ -n "$CEN_OPT_ADD"     ] && optc+=('--add')
        [ -n "$CEN_OPT_CHANGES" ] && optc+=('--changes')
        [ -n "$CEN_OPT_DELETE"  ] && optc+=('--delete')
        [ -n "$CEN_OPT_EDIT"    ] && optx+=('--edit')
        [ -n "$CEN_OPT_EXEC"    ] && optx+=('--exec')
        [ -n "$CEN_OPT_LIST"    ] && optx+=('--list')
        [ -n "$CEN_OPT_MERGE"   ] && optc+=('--merge')

        if [ "${#optc[@]}" -gt 1 ] ; then
            optarg - - -m "${optc[*]}" ; return
        elif [ "${#optx[@]}" -gt 1 ] ; then
            optarg - - -m "${optx[*]}" ; return
        elif [ -n "$optx" -a -n "$optc" ] ; then
            optarg - - -m "$optx $optc" ; return
        elif [ -n "$optx" -a -n "$CEN_OPT_UPDATE" ] ; then
            optarg - - -m "$optx --update" ; return
        elif [ -n "$optc" -a -n "$CEN_OPT_PATH" ] ; then
            optarg - - -m "$optc --path" ; return
        fi

        # must have machine name(s)
        [ -n "$CEN_OPT_ADD" -o -n "$CEN_OPT_DELETE" ] && CEN_RUN_MIN_ARGS=1

        [ -n "$CEN_OPT_EDIT" ] && CEN_OPT_PATH="$CEN_OPT_EDIT"
        if [ -n "$CEN_OPT_EXEC" ] ; then
            [ -z "$CEN_OPT_PATH" ] && error "Missing --path option"
            [ "$CEN_OPT_EXEC" = '-' -o "$CEN_OPT_EXEC" = '+' ] ||
                system -e -c -- "$CEN_OPT_EXEC"
        fi
        [ -n "$CEN_OPT_SILENT" ] && { DAT_HEADER='message -c'; DAT_MESSAGE='trace -a'; }
        ;;

    -A|--add)
        optarg 'add'        -   ;;              # flag
    -C|--cha*)
        optarg 'changes'    -   ;;              # flag
    -D|--del*)
        optarg 'delete'     -   ;;              # flag
    -E|--edi|--edit)
        optarg 'edit'     - -t  ;;              # text
    -I|--dom*)
        optarg 'domain'   - -t  ;;              # text
    -L|--lis|--list)
        optarg 'list'       -   ;;              # flag
    -M|--mer*)
        optarg 'merge'      -   ;;              # flag
    -N|--nic*)
        optarg 'nick'     - '[^/]*'  ;;         # text
    -P|--pat|--path)
        optarg 'path'     - -t  ;;              # text
    -S|--set*)
        optarg 'setup'    -     ;;              # flag
    -U|--upd*)
        optarg 'update'   -     ;;              # flag
    -X|--exe*)
        optarg 'exec'     - -t  ;;              # text
    esac
}

# ------------------------------------------------------------------------------
# usage info
# ------------------------------------------------------------------------------
usage() {
     netquery -s DAT_MAND domain ; DAT_MAND="${DAT_MAND%%.*}"
     sysversion -u
     usageset -u "$CEN_NAME <option>... [<mach>...]" \
              -u "$CEN_NAME <option>... -A [<mach>[/<idnt>]...]" \
              -u - \
              -u "$CEN_TITLE." \
              -p 'config'   $"Machine configuration (default: $DAT_MAND)" \
              -p 'distro'   $"System distribution   (default: $CEN_SYS_NICKNAME)" \
              -p 'name'     $"File name or search pattern" \
              -p 'prog'     $"Tool to be executed per file" \

    usagecat << !EOF
$CEN_USE_HEADER Clients must
register their machine-id in the staging repository for centauriconfig,
centaurisecrets and for obtaining their kerberos keytab. See:

        centaurikerberos client     # register a client, get keytab
        centaurisecrets register    # used by centaurikerberos
        centaurisecrets client      # client requests secrets
        centaurisecrets server      # server sends secrets
        centauriconfig sync         # sync client with repository

$CEN_USE_OPTIONS

       -I --domain  config  override the domain name (configuration)
       -N --nick    distro  override the  nick name  (distribution)

       -A --add             [*] add machine(s), see 'centaurisecrects register'
       -C --changes         [*] show changes (what --merge would copy)
       -D --delete          [*] delete machine(s)
       -L --list            [*] list machine ID(s)
       -M --merge           [*] merge back to main repository
       -U --update          update private machine repository

       -E --edit    name    [*] enter an interactive mode
       -P --path    name    generate origin/destination file paths
       -X --exec    prog    [*] runs a diff tool, needs --path to specify a file

       -S --setup           setup the staging folder

       [*] mutually exclusive options

       The --force option can be used to replace a private repository (--add)
       or override newer private files (--update) or to merge back not only
       machine specific files (--merge).

       For --add --delete and --merge the --nick option might be required to
       use another than the current distribution. The --update command uses
       all configured distros if --nick is not specified.

       If --add is used without <idnt> a new machine-id is generated. Be aware
       that this will not create a AD/DC machine account. To add a new machine
       to a domain run 'centaurikerberos client' on the new machine.

$CEN_USE_PARAMS

The script generates "/etc/rsyncd.conf" to allow registered clients to access
the staging repository. So centauriconfig will not alter the main repository.
To sync staging from main centauricron calls "$CEN_NAME -U" hourly.
Updating main from staging must be done manually, see "$CEN_NAME -M".

examples:
       $CEN_NAME -A neptun pluto                # add two machines
       $CEN_NAME -D pluto                       # delete a machine
       $CEN_NAME -D neptun -N buster            # delete distro 'buster'

       $CEN_NAME -U saturn                      # update a single machine
       $CEN_NAME -U                             # update all
       $CEN_NAME -M                             # merge back to main repository
       $CEN_NAME -U -M                          # udate and merge
!EOF
    usagecat -v "more:  Use -- to show the rsyncd configuration." << !EOF
config: $(do_config - -)
!EOF
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
