#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Dr. JÃ¼rgen Pfennig (c) 2023-2024; BSD License"
CEN_TITLE=$"Installer tool for centauri-soho linux machines"

# Import the bash library
if [ -z "$CEN_NAME" ] ; then
    PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -m con -y - '0.12:2' || exit 2
fi

# Variable naming

#   CEN_OPT_                    # options
#   DAT_SOHO_                   # this script
#   DAT_                        # the setup script
#   SOHO_                       # setup.conf

SOHO_WORKSPACE=                 # see get_base and --base
SOHO_DISTRO=                    # debian distribution
SOHO_LOCKED=                    # configured domain, host, ip, server

# Shared with 'setup' script:
SOHO_APT_PROXY=
SOHO_CONFIG=                    # name of the size configuration
SOHO_DOMAIN=                    # domain name
SOHO_DOMUSR=                    # a domain test user
SOHO_ROUTERS=                   # router list, 1st is generic router name
SOHO_NET_APNT=                  # WLAN SSID for host access point(s)
SOHO_NET_BASE=                  # base network
SOHO_NET_PUBLIC=
SOHO_NET_ROUTER_DEF=            # name for primary router
SOHO_NET_ROUTER_IP4=            # 1st router ip address
SOHO_NET_WLAN=                  # WLAN SSID
SOHO_PW_LOCAL=                  # override 'local' passws
SOHO_PW_ROOT=                   # override 'root' passwd
SOHO_PW_WLAN=                   # override WLAN passwd
SOHO_REPO_OPTS=                 # repository OPTIONS
SOHO_SONAME=                    # soho default machine name prefix
SOHO_HONAME=                    #
SOHO_GENAME=                    # generic server name
SOHO_SWAP_SIZE=
SOHO_PLATFORM=                  # usally set by get_architecture

# Data
CEN_OPT_BASE=                   # base folder, see --base
CEN_OPT_CURRENT=                # current config, see --current
CEN_OPT_DISPATCH=               # see --dispatch
CEN_OPT_NETCFG=                 # see --netcfg

DAT_SOHO_ARCH=                  # architecture, see get_architecture()
DAT_SOHO_PARAMS="$CEN_ROOT/default/$CEN_NAME"
DAT_SOHO_CMDS=                  # setup extra commands
DAT_SOHO_NETCFG="@shared/d_etc_default+centaurinetcfg"
DAT_SOHO_SEED=                  # abs path of seed.tgz
DAT_SOHO_SUB=                   # see actionTemplate
DAT_SOHO_DTAR=                  # Distributable tar file

DAT_SEED='seed.tgz'             # the seed tar
DAT_NOT_LAST=                   # true if not last command
DAT_GOT_CONF=                   # flag that setup.conf is loaded
DAT_KB_LAYOUT=                  # see cfg_keyboard

# imported
declare DAT_REPOSITORY DAT_RASPI

# ------------------------------------------------------------------------------
# Helper functions
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# handle configuration parameters: -q|-r|-w [<file>]
#                                  -p [<file> <wrks>]
#
#       -p      patch setup.conf with current parameters
#       -r      read only
#       -q      query prompt user for parameters
#       -t      read parameters from centaurisoho config file
#       -w      write parameters to config file
# ------------------------------------------------------------------------------
cfg_params() {
    # get parameter file path ...
    local file="$2"
    if [ -z "$file" ] ; then
        configfile -p -q && file="$CEN_CONFIGFILE" || file="$HOME/.local/$CEN_NAME"
    fi

    # patch password file...
    if [ "$1" = '-p' ] ; then
        [ -z "$2" -o -z "$3" ] && fatal -t 'option -p needs <file> <wrks>'
        local stab item
        item="$3/passwords"
        stab="s/^wlanpsk=.*/wlanpsk=${SOHO_NET_WLAN_PW@Q}/"
        if [ -f "$item" ] ; then
            system -e -p sed --regexp-extended --in-place=".$CEN_NAME" -e "$stab" "$item"
        else
            warning "Missing password file:" "$3"
        fi
        return 0

     # prompt for parameters...
     elif [ "$1" = '-q' ] ; then
        local pent="<please enter>" sodo netb
        cfg_keyboard -q
        get_value SOHO_DOMAIN         'soho.home'     -  "Domain name  (updates certs)"
        get_value SOHO_NET_PUBLIC     -         "$pent"  "External DNS (- for none)"
        sodo="${SOHO_DOMAIN%%.*}"
        get_value SOHO_SONAME         "$sodo"         -  "Default machine name prefix"
        get_value SOHO_SERVER         "$SOHO_SONAME"1 -  "Primary server name"

        get_value SOHO_NET_BASE       '10.10.0.0/21'  -  "Network IPv4 address and mask"
        get_value SOHO_NET_ROUTER_DEF 'router'        -  "Primary router name"
        netb="${SOHO_NET_BASE%.*}" ; netb="${netb%.*}.1.1"
        get_value SOHO_NET_ROUTER_IP4 "$netb"         -  "Primary router IPv4 address"

        get_value SOHO_NET_WLAN       "$sodo"         -  "WLAN client SSID  (- to disable)"
        get_value SOHO_NET_APNT       "$sodo-ap"      -  "WLAN AP SSID      (- to disable)"
        if [ "$SOHO_NET_WLAN" != '-' -o "$SOHO_NET_APNT" != '-' ] ; then
            [ "$SOHO_NET_WLAN" = "$SOHO_NET_APNT" ] &&
                fatal "SSIDs of WLAN client and WLAN AP must not be equal"
            get_value SOHO_NET_WLAN_PW -        "$pent"  "WLAN password     (- for random)"
        fi
        : "${SOHO_NET_PUBLIC:=-}" "${SOHO_NET_WLAN_PW:=-}"
    return 0
    fi

    # read parameter file ...
    if [ "$1" != '-w' ] ; then
        if [ -s "$file" ] ; then
            source "$file" ||
                fatal "Parameter loading failed:" "$file"
            trace -a -c "Parameters read" "$file"
        else
            trace -a -c "Got no parameters" "$file"
            return 1
        fi
    fi

    # write config file ...
    if [ "$1" = '-w' ] ; then
        local item curr list idnt
        if [ "$file" = '-' ] ; then
            message -m "Current parameter values..." ''
            idnt="${CEN_NAME//?/ }      "
        else
            list=(
            "# '${file##*/}' is a parameter file used by centaurisoho."
            "#"
            "# Purpose #1: it remembers the current workspace path, distro and config"
            "#         #2: it provides defaults for image tar installations"
            "#"
            "# There is little reason to edit this file except for purpose #2."
            ""
            )
        fi
        for item in SOHO_WORKSPACE SOHO_DISTRO SOHO_CONFIG SOHO_HOST - \
                    SOHO_DOMAIN SOHO_SONAME SOHO_SERVER - SOHO_NET_PUBLIC \
                    SOHO_NET_BASE SOHO_NET_ROUTER_DEF SOHO_NET_ROUTER_IP4 \
                    SOHO_NET_WLAN SOHO_NET_APNT SOHO_NET_WLAN_PW ; do
            if [ "$item" = '-' ] ; then
                list+=('') ; continue
            fi
            eval curr=\"\$$item\" ; curr="${curr@A}"
            list+=("$idnt$item=${curr#*=}")
        done
        if [ "$file" = '-' ] ; then
            list+=('')
            create -r -v list -- - || return 1
        else
            list+=('' '# end')
            create -t -v list -- "$file" || return 1
            cfg_keyboard -w -
        fi
     fi
     return 0
}

# ------------------------------------------------------------------------------
# Config keyboard layout for minimal host: [-q|-u] <dest>
# ------------------------------------------------------------------------------
#       -q      query
#       -u      update destination
#
# Using debian's '/etc/default/keyboard' file. Copy local file if present.
# ------------------------------------------------------------------------------
cfg_keyboard() {
    [ "${2:--}" = '-' ] && return 1                 # do nothing on current host
                                                    # run only without centauritools
    [ -s "$dest/var/centauri/tools/_centauri_bash_lib" ] && return 0

    local dest="$2" keyb='/etc/default/keyboard' dflt="<copy current>" dval='-'

    if [ "$1" = '-q' ] ; then
        # do we have a local debian Keyboard config?
        [ -s "$keyb" ] || { dflt='us' ; dval="$dflt" ; }
        get_value DAT_KB_LAYOUT "$dval" "$dflt" "Keyboard layout (fr,de,us,...)"
        return 0
    elif [ "$1" != '-u' ] ; then
        return 1
    fi

    if [ "$DAT_KB_LAYOUT" = '-' ] ; then
        :
    elif [ -z "$DAT_KB_LAYOUT" ] && [ -s "$keyb" ] ; then
        copy -- "$keyb" "$dest" || return 1
    else
        create -t -h - -- "$dest$keyb" <<!EOF
XKBMODEL="pc105"
XKBLAYOUT="$DAT_KB_LAYOUT"
XKBVARIANT=""
XKBOPTIONS=""
BACKSPACE="guess"
!EOF
    fi
    return 0
}

# ------------------------------------------------------------------------------
# apply configuration: <dest>|- <name>|- <para>|-
# ------------------------------------------------------------------------------
#   Where to get centaurisoho parameters:
#   (1) <para> file argument
#   (2) <dest>/etc/default/centaurisoho
#   (3) /etc/default/centaurisoho
#
#   <dest>  mountpoint of root-fs or '-' for this machine
#   <name>  machine name or '-' for $HOSTNAME
#   <para>  '' to query  '-' no params  <file> param file
# ------------------------------------------------------------------------------
cfg_apply() {
    local dest="${1:--}" name="${2:--}" para="$3"
    local list wrks dcfg='/etc/default/centaurisoho'

    if  [ "$dest" = '-' ] ; then
        get_yesno -y "Update configuration of local host" || quit -a -u
        [ "$name" = '-' ] && name="$HOSTNAME"
        wrks="$SOHO_WORKSPACE" ; dest='/'
    else
        # install to an image? Get workspace and params  ...
        [ -d "$dest/boot" -a -d "$dest/usr" ] || dest+='/Volumes/Root'
        dcfg="$dest$dcfg"
        inpdata -a list -q -r -- "$dcfg"
        txtgrep -s wrks -i list -m -y 'SOHO_WORKSPACE=*'
        wrks="${wrks#*=}" ; wrks="${wrks#[\'\"]}" ; wrks="${wrks%[\'\"]}"
        if [ -n "$wrks" ] && [ -d "$dest$wrks" ] ; then
            wrks="$dest$wrks"
        else
            wrks="$SOHO_WORKSPACE"
        fi
        trace -a -c "dest workspace" "$wrks"
        if [ -s "$dcfg" ] ; then
            cfg_params -r "$dcfg" || return 1
            get_setup -n || return 1                # complete and validate only
        fi
        if [ "$name" = '-' ] ; then
            invoke -e "Configuration needs a hostname" ; return 1
        fi
       get_yesno -y "Update configuration of '%s'" "$name" || quit -a -u
    fi

    case "$para" in
    '')     cfg_params -q || return 1 ;;
    -)      ;;
    *)      cfg_params -r "$para" || return 1
    esac
    get_yesno -n "Apply configuration" || quit -a -u
    cfg_params -w "$dcfg"
    cfg_params -p "$dcfg" "$wrks"

    # update installed templates: <wrks> <host> <root>
    SOHO_DNAME="${SOHI_DOMAIN%.*}"
    copyAllTemplates "$wrks" "$name" "$dest"

    ___wlan_config() {
        [ "${SOHO_NET_WLAN:--}" = '-' ] || set -- "$@" --wlan   "$SOHO_NET_WLAN:$SOHO_NET_WLAN_PW"
        [ "${SOHO_NET_APNT:--}" = '-' ] || set -- "$@" --apoint "$SOHO_NET_APNT:$SOHO_NET_WLAN_PW"
        folder -f -m 'etc/hostapd'
        embed -v 'centaurinetgen' "$@" --host="$name" nmcon -- wpasup -- hostapd
    }

    if [ "$dest" = '/' ] ; then
        embed -v centaurinetcfg setup "$name"
        ___wlan_config
    elif [ -s "$dest/etc/default/centaurinetcfg" ] ; then
        item="$PWD" ; folder -c -f -- "$dest"
        embed -v centaurinetcfg --conf="etc/default/centaurinetcfg" --out=. setup "$name"
        ___wlan_config '--out=.'
        folder -c -f "$item"
        DAT_GOT_CONF=
    fi
    return 0
}

# ------------------------------------------------------------------------------
# get host architecture
# ------------------------------------------------------------------------------
#   SOHO_PLATFORM   x86 (pc)    rpi (raspi)     p32 (raspi2)
# ------------------------------------------------------------------------------
get_architecture() {
    [ -n "$DAT_SOHO_ARCH" ] && return 0
    system -q -r -s DAT_SOHO_ARCH -- dpkg --print-architecture
    [ -n "$SOHO_PLATFORM" ] && return 0
    system -c raspi-config && SOHO_PLATFORM='rpi'
    case "$SOHO_PLATFORM-$DAT_SOHO_ARCH" in
        *-)         quit -f "Not running a debian system?" ;;
        -amd64)     SOHO_PLATFORM='x86' ;;
        rpi-arm64)  ;;
        rpi-arm*)   SOHO_PLATFORM='r32' ;;
        *)          error "Unsupported hardware architecture:" "$DAT_SOHO_ARCH"
                    return 1
    esac
    return 0
}

# ------------------------------------------------------------------------------
# get base folder, check seed (unless -f|-n is used): [-f|-n|-q|-w]
# ------------------------------------------------------------------------------
# Options:      -n  do not check seed, do not change working dir
#               -q  like -n but no error messages
#               -f  do not check seed
#               -r  like -w with fallback to repository
#               -w  just get workspace, do not change working dir
# ------------------------------------------------------------------------------
get_base() {
    local nmsg ; [ "$1" = '-q' -o "$1" = '-r' -o "$1" = '-w' ] && nmsg=1
    if [ -n "$SOHO_WORKSPACE" ] ; then              # previous call
        [ "$1" = '-n' -o -n "$nmsg" ] && return 0   # dont change folder
        folder -f -c -- "$SOHO_WORKSPACE" ; return 0
    fi

    cfg_params -r #### || return 1
    local updt curr="$SOHO_WORKSPACE:$SOHO_DISTRO:$SOHO_CONFIG"

    [ -n "$CEN_OPT_BASE" ] && SOHO_WORKSPACE="$CEN_OPT_BASE"
    [ -n "$CEN_OPT_CURRENT" ] &&
        splitkeyval  "$CEN_OPT_CURRENT" SOHO_DISTRO SOHO_CONFIG ':'
    if [ -z "$SOHO_WORKSPACE" ] ; then
        [ "$1" = '-q' ] && return 1
        [ "$1" = '-r' ] || quit -e "No known workspace, use option '--base=<fldr>'"
        get_repository ; return
    elif [ ! -d "$SOHO_WORKSPACE/dists" ] ; then
        [ "$1" = '-q' ] && return 1
        [ "$1" = '-r' ] || quit -e "Not a valid workspace:" "$SOHO_WORKSPACE"
        get_repository ; return
    elif [ "$1" = '-w' ] ; then
        return 0
    elif [ -z "$SOHO_DISTRO" -o -z "$SOHO_CONFIG" ] ; then
        [ "$1" = '-q' ] && return 1
        quit -e "No configuration info, use option '--current=<dist>:<inst>'"
    fi

    [ "$curr" = "$SOHO_WORKSPACE:$SOHO_DISTRO:$SOHO_CONFIG" ] || updt="   update"
    trace "base=$SOHO_WORKSPACE   current=${curr#*:}$updt"

    [ -n "$updt" ] && cfg_params -w                 # update params

    [ "$1" = '-n' -o "$1" = '-q' ] && return 0      # dont change folder
    folder -f -c -- "$SOHO_WORKSPACE"
    [ "$1" = '-f' ] && return 0                     # no seed check

    if ! matchpath -o -e -s DAT_SOHO_SEED -- "$DAT_SEED" ; then
        error "No known seed file, use options '--base=<fldr> --current=<dist>:<inst>'"
        return 1
    fi
    trace -a -c "Seed file" "$DAT_SOHO_SEED"
    return 0
}

# get extra commands from 'setup'
get_cmds() {
    [ -n "$DAT_SOHO_CMDS" ] && return 0
    if [ -z "$SOHO_WORKSPACE" ] ; then
        get_base -q || return 1
    fi
    [ -x "$SOHO_WORKSPACE/setup" ] || return 1
    system -a DAT_SOHO_CMDS -d '\n' -n -r -- "$SOHO_WORKSPACE/setup" commands
}

# get distributable and work folder: [<dist>:[<conf>]|-|+
get_dist() {
    [ -z "$SOHO_WORKSPACE" ] && return 1
    prettypath -p -- "$SOHO_WORKSPACE/.." || return 1
    local bnam="$CEN_PRETTYPATH/$CEN_NAME-"
    case "${1:-+}" in
    *[/.]*) bnam="$1" ;;
    +)      bnam+="$SOHO_DISTRO-$SOHO_CONFIG" ;;
    -)      bnam+="$SOHO_DISTRO" ;;
    :*)     bnam+="$SOHO_DISTRO-${1:1}" ;;
    *)      bnam+="${1/:/-}"
    esac
    inpfile -c -l -q -s DAT_SOHO_DTAR -x 'tgz' -- "$bnam" || return 1
    trace -a -c "distributable" "$DAT_SOHO_DTAR"
    return 0
}

# check network base: [-w] <base>
get_network() {
    local merr='error'
    [ "$1" = '-w' ] && { merr='warning -a' ; shift ; }
    CEN_NET_NETWORKS=()
    if ! netparse -a -b -- "$1" ; then
        $merr "Network base has invalid syntax" ; return 1
    elif [ "$_netparse_bits" -lt 10 ] ; then
        $merr "Network mask bits value must be >= 10" ; return 1
    elif [ "$_netparse_bits" -gt 22 ] ; then
        $merr "Network mask bits value must be <= 22" ; return 1
    fi
    netconv -b "$_netparse_addr"
    local abin="${_netconv:--1}"                # address as binary
    netconv -b "${_netparse_mask:-0}"           # mask as binary
                                                # get allow offset bits ...
    local mask=$(( (1<<(32 - _netparse_bits)) - 1 ))
    ((mask &= ~255)) ; ((mask += _netconv))     # lower 8 bit must be 0
    trace -c -p 'offset mask' "%x %x %x" "$mask" "$_netconv" "$abin" #
    if [ "$((abin & ~mask))" != 0 ] ; then
        $merr "Network mask or network base ip address are invalid" ; return 1
    fi

    CEN_NET_NETBITS="$_netparse_bits"
    CEN_NET_NETMASK="$_netparse_mask" ; _netparse_addr="${_netparse_addr%.*}"
    CEN_NET_NETWORKS=("$1")
    netparse '<0>0.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>0.128' ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>1.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/24")
    netparse '<0>2.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/24")
    netparse '<0>3.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>3.128' ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    return 0
}

# ------------------------------------------------------------------------------
# convert repository file name: -d|-u <name> <vnam>
# ------------------------------------------------------------------------------
#   -d decorate
#   -u undo '-d' decoration
# ------------------------------------------------------------------------------
get_path() {
    local _sout _sinp _spat
    case "$1" in
    -d)     _spat="${2%/*}" ; _sinp="${2##*/}"
            _spat="${_spat//_/Â°}"
            _sout="${_spat//\//_}+$_sinp"
            ;;
    -u)     _spat="${2%+*}" ; _sinp="${2##*+}"
            _spat="${_spat#*/?_}" ; _spat="${_spat#_}"
            _spat="${_spat//_/\/}" ; _spat="${_spat//Â°/_}"
            _sout="$_spat/$_sinp" ; [ "${_sout::1}" = '/' ] || _sout="/$_sout"
            ;;
    *)      fatal -t '?' "$1"
    esac
    printf -v "$3" '%s' "$_sout"
}

# ------------------------------------------------------------------------------
# get repository path: -no args-
# ------------------------------------------------------------------------------
get_repository() {
    [ -n "$DAT_REPOSITORY" ] && return 0
    if [ -n "$SOHO_DNAME" ] ; then
        DAT_REPOSITORY="$CEN_ROOT/configs/$SOHO_DISTRO/$SOHO_DNAME"
        return 0
    elif [ -d "$CEN_ROOT/shared" ] ; then
        resolve -e -m $CEN_ROOT/shared/.. || return
        DAT_REPOSITORY="$CEN_RESOLVE"
        return 0
    fi
    error -n "Missing '$CEN_ROOT/shared', please create manually by" \
             "running: ln -s $CEN_ROOT/configs/<dist>/<dnam>/@shared $CEN_ROOT/shared"
    return 1
}

# ------------------------------------------------------------------------------
# load configuration and the setup plugin: [-c]
# ------------------------------------------------------------------------------
#   Options:    -c      use 'setup --config' (don't load plugin code)
#               -n      no init, don't call 'setup' at all
#
#   Get network config, derive from 'setup.conf' if needed:
#       --netcfg=2      use centaurinetcfg if it exists and HOSTNAME != SOHO_ORIGIN
#       --netcfg=0      always use 'setup.conf'
#       --netcfg=1      always use 'centaurinetcfg', fatal if not existing
# ------------------------------------------------------------------------------
get_setup() {
    local oset='source'
    [ "$1" = '-c' ] && oset='config'

    if [ "$1" = '-n' ] ; then                       # no 'setup'
        DAT_GOT_CONF= ; SOHO_SETUP=                 # config/setup now invalid
    elif [ "$SOHO_SETUP" = 1 ] ; then               # sourced before
        :
    elif [ ! -x "$SOHO_WORKSPACE/setup" ] ; then
        invoke -e "Missing 'setup' script" ; return 1
    else
        trace -a "Sourcing 'setup' script ..."
        source "$SOHO_WORKSPACE/setup" --$oset
        if [ -z "$SOHO_SETUP" ] ; then
            invoke -e "Failed to load 'setup' script" ; return 1
        fi
        trace -a "Sourcing 'setup' succeeded"
    fi

    if [ -n "$CEN_NET_DOMAIN" ] ; then
        invoke -e "Network config already loaded" ; return 1
    fi

    # get passwords for root and local
    ___pwentry() {
        case "${1%=*}" in
        root)   SOHO_PW_ROOT="${1#*=}" ;;
        local)  SOHO_PW_LOCAL="${1#*=}" ;;
        esac
        return 0
    }

    # last chance defaults, centaurinetcfg needs these...
    : ${SOHO_GENAME:=server}
    : ${SOHO_ROUTERS:=router}

    # the setup script sets SOHO_xxxx data, add CEN_NET_xxx here
    CEN_NET_DOMAIN="$SOHO_DOMAIN"
    CEN_NET_SERVER_GEN="$SOHO_GENAME"
    CEN_NET_SERVERS=("$SOHO_SERVER" "$SOHO_SECOND")
    get_network "$SOHO_NET_BASE" || return 1

    : ${SOHO_ROUTERS:='router'}
    set -f ; set -- $SOHO_ROUTERS ; set +f
    : ${SOHO_NET_ROUTER_DEF:="${2:-"${1}0"}"}
    : ${SOHO_NET_ROUTER_IP4:="${SOHO_NET_BASE%.*}.1"}

    CEN_NET_ADDR_IPLIST=("10.255.255.1")

    # option -c or -n stop here
    [ "$oset" = 'config' -o -z "$DAT_GOT_CONF" ] && return 0

    configfile -l ___pwentry -n './passwords' || return 1
    if [ "${SOHO_PW_ROOT:--}" = '-' ] ; then
        error "No password for 'root' (see SOHO_PW_ROOT)" ; return 1
    elif [ "${SOHO_PW_LOCAL:--}" = '-' ] ; then
        error "No password for 'local' (see SOHO_PW_LOCAL)" ; return 1
    fi

    case "$CEN_OPT_NETCFG" in
    0)  return 0 ;;
    1)  ;;
    *)  [ "$HOSTNAME" == "$SOHO_ORIGIN" ] && return 0
    esac

    trace "Trying to load cached 'centaurinetcfg'"
    CEN_NET_DOMAIN=
    if netconfig ; then
        trace -a "Loading 'centaurinetcfg' succeeded"
    else
        error "cannot load cached network config, please run '$CEN_NAME config'"
        return 1
    fi

    [ "$SOHO_DOMAIN" != "$CEN_NET_DOMAIN" ] && warning \
        "Domain mismatch:" "$SOHO_DOMAIN (setup.conf), $CEN_NET_DOMAIN (netcfg)"

    SOHO_DOMAIN="$CEN_NET_DOMAIN"
    SOHO_DNAME="${SOHI_DOMAIN%.*}"
    SOHO_NET_BASE="$CEN_NET_NETWORKS"
    SOHO_SERVER="${CEN_NET_SERVERS[0]}"
    SOHO_SECOND="${CEN_NET_SERVERS[1]}"
    SOHO_ROUTERS="$CEN_NET_ROUTER_GEN ${CEN_NET_ROUTERS[*]}"
    SOHO_NET_ROUTER_DEF="$CEN_NET_ROUTER_DEF"
    SOHO_NET_ROUTER_IP4="$CEN_NET_ROUTER_IP4"
    return 0
}

# ------------------------------------------------------------------------------
# update existing files from repository: <dest>
# ------------------------------------------------------------------------------
get_update() {
    confirm -a -f -y "Update '%s' files from repository" "$1" || return
    local curr="$PWD" miss=0 coun=0
    folder -c -f -- "$1"

    # (1) get sub-folders of destination, cannot use CEN_WALK_DIRS

    local dest="$PWD" dirs=() item file list
    ___updates_dir() {                              # callback from walk()
        dirs+=("$2") ; return 1
    }
    walk -r -n -d ___updates_dir -f false -- .

    # (2) walk over files in sub-folders

    for item in "${dirs[@]}" ; do
        walk -r -b -l 1 -- "$item"
        list=()
        for file in "${CEN_WALK_FILES[@]}" ; do
            [ "${file%/_centauri_bash_dyn}" = "$file" ] || continue
            file="${file#.}"
            if [ -e "$file" ] ; then
                list+=("$file")
            elif [ -h "$file" ] ; then
                list+=("$file")
            else
                message -a -c "File not in repo" "${file#$CEN_ROOT/}"
                ((miss += 1))
            fi
        done
        [ -z "$list" ] && continue
        trace -a -p "%-56s: %4s %s" "${item#./}" "${#list[*]}" "items"
        system -f -p -- cp -a "${list[@]}" "$dest/${item#./}"
        ((coun += ${#list[@]}))
    done
    file="$dest/var/centauri/library"
    embed -i -v "$file/autoload" -B -P "$dest/var/centauri/library"
    folder -c -f "$curr"
    message -a -p "Updated %s folders, %s items, %s not in repository" "${#dirs[@]}" "$coun" "$miss"
}

# ------------------------------------------------------------------------------
# ask for parameter value
#   (1) <vnam> -      <prom> <text>   # <vnam> set to reply
#   (2) <vnam> <dflt> -      <text>   # <vnam> set to reply/<dflt>
#   (3) <vnam> <dflt> <prom> <text>   # <vnam> set to reply/<dflt>
# ------------------------------------------------------------------------------
get_value() {
    local _curr _dflt="${2:--}" _prom="${3:--}" _text
    eval _curr=\"\$$1\"
    [ "${_curr:--}" != '-' ] && _dflt="$_curr"
    [ "$_prom" = '-' -o "${_dflt:--}" != '-' ] && _prom="$_dflt"

    printf -v _text '%s%%s[%s]' "$4" "$_prom"
    local _leng ; printf -v _leng '%56s'
    local _fill=$((${#_leng} - ${#_text}))
    [ "$_fill" -lt 1 ] && _fill=1
    printf -v _text "$_text" "${_leng::_fill}"

    while : ; do
        confirm -a -f -p - -u "$_text"
        [ -z "$CEN_CONFIRM" ] && CEN_CONFIRM="$_dflt"
        # input validation
        case "$1" in
            SOHO_NET_BASE)
                get_network "$CEN_CONFIRM" && break
                ;;
            SOHO_NET_WLAN_PW)
                [ "${#CEN_CONFIRM}" -ge 8 ] && break
                error $"Minimum password length is 8 chars"
                ;;
            SOHO_NET_ROUTER_IP4)
                netparse -e -a -- "$CEN_CONFIRM" && break
                ;;
            *)
                break ;;
        esac
    done
    error -c
    printf -v "$1" '%s' "$CEN_CONFIRM"
}

# confirm y/n in same format as get_value
get_yesno() {
    local text yopt="$1" ; shift
    [ $# -gt 1 ] && printf -v text "$@" || text="$1"
    confirm $yopt -f "%-48s" "$text"
}

# ------------------------------------------------------------------------------
# source the install helper: <verb> [<dist>|- [<conf>|-]]
# ------------------------------------------------------------------------------
run_installer() {
    [ -x './installer' ] || quit -e "Install helper not found:" "$PWD/installer"
    local opts=('./installer' "$@")
    DAT_SELF="$CEN_NAME"
    dryrun -s "source ${opts[@]}" && return
    trace -a -c "Sourcing" "${opts[@]}"
    source "${opts[@]}"
}

# ------------------------------------------------------------------------------
# Backup to create a disk tar: <host> <boot>|-|+ [<root>|-|+ [<arch>]]
# ------------------------------------------------------------------------------
actionBackup() {
    get_base -n || return
    local arch="$4" base curr="$PWD" item file auto mptb mptr fail bdir
    local host="${1:--}" ; [ "$host" = '-' ] && host="$HOSTNAME"
    local aboo="${2:--}" aroo="${3:--}"
    [ "$aboo" = '+' ] && aboo="${host}_boot"
    [ "$aroo" = '-' ] && aroo="${host}_root"
    if [ "$aroo" = '+' ] ; then
        aroo="${host}_vol0"
        [ ! -b "/dev/disk/by-label/$aroo" ] &&
            [ -b "/dev/disk/by-label/${host}_root" ] && aroo="${host}_root"
    fi

    # boot root volumes     # btrfs
    # boot root             # ext4 (raspi)
    #      root             # ext4 (debian bootstrap)

    if [ "${2:--}" = '-' ] ; then
        invoke -w "Backup of 'root' only"
    elif [ -d "$aboo" ] ; then
        prettypath -s mptb -- "$aboo"
    else
        automount -- "$aboo" || return
        mptb="$CEN_MOUNT_DIR" ; auto=1
    fi

    if [ -d "$aroo" ] ; then
        prettypath -s mptr -- "$aroo"
    else
        automount -b -- "$aroo" || return
        mptr="$CEN_MOUNT_DIR" ; auto=1
    fi

    if [ "$mptr" -ef '/mnt/vol0/Volumes/Root' ] ; then
        mptr='/mnt/vol0'
        warning "Backup of a running system may result in garbage"
    elif [ -d "$mptr/mnt/vol0" -a ! -d "$mptr/Volumes/Root" ] ; then
        confirm -n "Mount option 'subvol=/' might be missing. Continue" || quit -a -u
    fi

    for item in 'boot' 'root' 'usr' 'home' 'shared' ; do
        printf -v file "%s_%s_%(%Y-%m-%d)T.tar.xz" "$host" "$item" -1
        [ -s "$curr/$file" ] && continue
        if [ "$item" = 'boot' ] ; then
            [ -z "$mptb" ] && continue              # root includes boot
            folder -c -f "$mptb"
            embed -t centauribackup -A0 -H "$host" -S "$curr" -P xz -T "$item" archive .

        elif [ -d "$mptr/Volumes/Root" ] ; then
            if [ "$item" = 'root' ] ; then
                embed -t centauribackup -A0 -H "$host" -B "$mptr/Volumes/Root" \
                                        -S "${curr/_root_/_vol0_}" -P xz 'root'
            elif [ "$item" = 'usr' ] ; then
                embed -t centauribackup -A0 -H "$host" -B "$mptr/Volumes/Root" \
                                        -S "$curr" -P xz 'usr'
            else
                embed -t centauribackup -A0 -H "$host" -B "$mptr/Volumes" \
                                        -S "$curr" -P xz "$item"
            fi

        elif [ -d "$mptr/$item" ] ; then
            embed -t centauribackup -A0 -H "$host" -B "$mptr" -S "$curr" -P xz "$item"
        fi
    done

    folder -c -f "$curr"
    for item in 'boot' 'root' 'usr' 'home' 'shared' ; do
        [ -z "$mptb" -a "$item" = 'boot' ] && continue
        [ -z "$mptb" -a "$item" = 'shared' ] && continue
        printf -v file "%s_%s_%(%Y-%m-%d)T.tar.xz" "$host" "$item" -1
        [ -s "$file" ] && continue
        [ "$item" = 'shared' ] && continue
        error -a "Backup file missing for:" "$item" ; fail=1
    done

    if [ -z "$fail" ] ; then
        if [ "${arch:--}" = '-' ] ; then
            bdir="$mptr/Volumes/Root"
            [ -d "$bdir" ] || bdir="$mptr"
            [ -d "$bdir/boot/firmware" ] && arch='rpi' || arch='x86'
        fi
        message -p "Backups are complete, creating dist tar (%s)" "$arch"

        printf -v item "%s_*_%(%Y-%m-%d)T.tar.xz" "$host" -1
        printf -v file "%s_disk-%s_%(%Y-%m-%d)T.tar" "$host" "$arch" -1
        local vols volf
        if [ -e "$mptr/Volumes/Root" ] ; then
            volf="${1}_volumes"
            system -e -p -s vols -- ls -1 "$mptr/Volumes"
            create -t -v vols -- "$volf"
        else
            remove "$volf"
        fi

        # copy imagetool and create imagetool.xy
        local tool="$SOHO_WORKSPACE/dists/@tools"
        if [ -s "$tool/imagetool" ] ; then
            embed -z -v -i -- "$tool/imagetool" archive "$PWD"
            system -e -p -- cp -a -u -- "$tool/imagetool"* "$tool/grub.minimal" .
            system -e -p -- cp -a -u "$DAT_SOHO_PARAMS" 'imagetool.params'
        else
            warning "Missing file:" "$tool/imagetool"
        fi

        # volf, item can be void and must not be quoted
        if system -t -e -p -- tar -cf "$file" imagetool* grub.minimal $volf $item ; then
            confirm -a -y "Dist tar created, remove constituent tars" &&
                remove -- $volf $item imagetool* grub.minimal
        fi
    fi

    [ -n "$auto" ] && automount -q
}

# ------------------------------------------------------------------------------
# update config: network                              # get config from template
#                query    <dest>|- <name>|- <para>|-  # configuration query menu
#                show                                 # show config parameters
#                update                               # update installed templates
# ------------------------------------------------------------------------------
# When used to modify a system that is not booted the root is found by walking
# up from <workdir>:
#
#       centaurosoho  --base=<workdir> config ...
# ------------------------------------------------------------------------------
actionConfig() {
    local ccmd="${1:-network}"
    if [ $# -lt 2 ] ; then
        get_base -f || return                       # change dir to base folder
    elif [ "${ccmd::3}" = 'que' ] ; then
        get_base -n
    else
        invoke -e "Only 'query' can have a arguments" ; return
    fi

    # find root folder
    local root="$PWD"
    while [ "$root" != '/' ] ; do
        root="${root%/*}" ; [ -z "$root" ] && root='/'
        [ -d "$root/usr/bin" -a -d "$root/etc/default" ] && break
    done
    trace -a -p "Root folder: '%s'    Workspace: '%s'" "$root" "$PWD"

    case "$ccmd" in
    net*)
        ;;
    que*)
        shift
        cfg_apply "$@" ; return
        ;;
    sho|show)
        cfg_params -r || return
        cfg_params -w '-' ; return
        ;;
    upd*)
        if [ "$root" != '/' ] ; then
            invoke -e "can update local system only" ; return
        fi
        cfg_params -r || return
        confirm -y "Update system configuration" || quit -a -u
        uall=1
        ;;
    *)  invoke -e "Argument must be one of: %s" 'network query show update'
        return
    esac

    if [ -z "$SOHO_DOMAIN" ] ; then
        get_setup -c || return                      # load 'setup.conf'
    fi

    local repo="$CEN_ROOT/configs/$SOHO_DISTRO/${SOHO_DOMAIN%%.*}"
    if [ -e "$repo/$DAT_SOHO_NETCFG" ] ; then
        confirm -a -y "Replace the existing network configuration" || quit -a -u
    fi

    local file ; tmpfile -s file
    copyFromTemplate "templates/$DAT_SOHO_NETCFG.TEMPLATE" "$file"
    error -t || return
    CEN_NET_DOMAIN=                         # must re-read config
    DAT_REPOSITORY="$repo"
    copyFromRepo /etc/services              # netcfg needs centauri settings
    embed -t -v centaurinetcfg --config="$file" validate cache
    error -t || return
    move "$file" "$repo/$DAT_SOHO_NETCFG"

    [ -n "$uall" ] && copyAllTemplates "$SOHO_WORKSPACE"
}

# ------------------------------------------------------------------------------
# Create distribution tar from workspace: [[<dist>] <conf>]
# ------------------------------------------------------------------------------
actionDistr() {
    get_base -f || return
    local dist="$SOHO_DISTRO" conf="$SOHO_CONFIG" seed
    case "$1:$2" in
    :)      ;;
    -:)     conf= ;;
    -:-)    ;;
    *:)     dist="$1" ; conf= ;;
    *:-)    dist="$1" ;;
    -:*)    conf="$2" ;;
    *)      dist="$1" ; conf="$2"
    esac

    if [ ! -d "dists/$dist" ] ; then
        invoke -e "Not a valid distribution:" "$dist" ; return
    elif [ "${conf:--}" = '-' ] ; then
        seed="$dist"
    elif [ ! -d "dists/$dist/configs/$conf" ] ; then
        if [ -s "dists/$dist/@seed/seed-$dist.tgz" ] ; then
            error "Must unpack distribution tar, see:" "$CEN_NAME unpack"
        else
            invoke -e "Not a valid configuration:" "$conf"
        fi
        return
    else
        seed="$dist-$conf"
    fi

    message "Packing workspace:" "$seed"

    if [ -d "dists/$dist/dynamic" -a -d "dists/$dist/static" ] ; then
        get_update "dists/$dist/dynamic"
        if [ -z "$conf" ] ; then
            run_installer 'pack' "$dist"
        else
            run_installer 'pack' "$dist" "$conf"
        fi
    elif [ -s "dists/$dist/@seed/seed-$seed.tgz" ] ; then
        invoke -w "Missing dynamic|static but seed tar exists"
    else
        invoke -e "Missing dynamic|static and missing seed tar" ; return
    fi

    if [ -z "$conf" ] ; then
        run_installer 'dist' "$dist"
    else
        run_installer 'dist' "$dist" "$conf"
    fi
}

# ------------------------------------------------------------------------------
# Run docviewer
# ------------------------------------------------------------------------------
actionDocview() {
    get_base -r || return                           # get base folder
    local docv="$SOHO_WORKSPACE/README/docviewer.dynamic"
    [ -x "$docv" ] || docv="$DAT_REPOSITORY/../@soho/docviewer"
    embed -x -v -- "$docv" "$@"
}

# ------------------------------------------------------------------------------
# Test output of configuration data
# ------------------------------------------------------------------------------
actionDump() {
    get_base -f || return                           # change dir to base folder
    get_setup -c
    debug SOHO_DISTRO                       # [1] debian distribution

    # The template engine wants these variables:

    debug -i SOHO_DOMAIN
    debug -i SOHO_DNAME                     #     generated from DOMAIN
    debug -i SOHO_SONAME                    # [1]
    debug    SOHO_NET_BASE
    debug -i SOHO_NET_PUBLIC                # [1]
    debug    SOHO_SERVER
    debug -i SOHO_SECOND
    debug    SOHO_ROUTERS
    debug -i SOHO_NET_ROUTER_DEF            #     generated from SOHO_ROUTERS
    debug -i SOHO_NET_ROUTER_IP4
    debug -i SOHO_NET_WLAN                  # [1]
    debug -i SOHO_NET_APNT                  # [1]
    debug    CEN_NET_NETBITS
    debug -i CEN_NET_NETMASK
    debug -i CEN_NET_SERVER_GEN
    debug -i CEN_NET_SERVERS
    debug -i CEN_NET_NETWORKS
    debug -i CEN_NET_ADDR_IPLIST
}

# ------------------------------------------------------------------------------
# Unpack distributable and seed: [<dist> [<work>]]
#
#   <path>.tgz
#   centaurisoho-master.tgz
#   centaurisoho-<dist>.tgz
#   centaurisoho-<dist>-<conf>.tgz
# ------------------------------------------------------------------------------
actionExpand() {
    get_base -q
    local work curr
    get_dist "$1" || return
    work="${DAT_SOHO_DTAR##*/}" ; work="${work%.*}"     # filename only
    curr="${work#*-}"
    case "$work" in
    *-*-*)  work="${work%-*}"
            SOHO_DISTRO="${curr%-*}" ; SOHO_CONFIG="${curr#*-}"
            ;;
    *-*)    SOHO_DISTRO="$curr" ; SOHO_CONFIG='-'
            ;;
    *)      if [ -n "$CEN_OPT_CURRENT" ] ; then
                splitkeyval  "$CEN_OPT_CURRENT" SOHO_DISTRO SOHO_CONFIG ':'
            else
                error "Cannot parse file name, use --current=<dist>:<conf>"
                return
            fi
    esac

    [ -n "$CEN_OPT_BASE" ] && work=$CEN_OPT_BASE
    trace -a -c "Expanding"  "$work  $SOHO_DISTRO:$SOHO_CONFIG"

    if [ -z "$CEN_OPT_FORCE" ] && [ -e "$work" ] ; then
        error "Workspace already exists (try '--force'):" "$work" ; return
    fi
    confirm -y "Unpack '${DAT_SOHO_DTAR##*/}' to '$work'" || return
    dryrun -s "Create: $work" || folder -f -m -c "$work"
    dryrun "Unpack $DAT_SOHO_DTAR" || {
        system -e -p -- tar -xaf "$DAT_SOHO_DTAR" --strip-components=1 || return
        [ ! -s "$DAT_SEED" ] && fatal "No '$DAT_SEED' in '$DAT_SOHO_DTAR'"
    }
    dryrun "Unpack $PWD" || {
        SOHO_WORKSPACE="$PWD"
        actionUnpack
    }
}

# ------------------------------------------------------------------------------
# Get workspace info: [<dist>]
# ------------------------------------------------------------------------------
actionInfo() {
    get_base -q
    get_architecture
    message -a -c "HW architecture" "${SOHO_PLATFORM:-<unknown>} ($DAT_SOHO_ARCH)"
    message -a -c "Configuration"   "${CEN_CONFIGFILE:-<unknown>}"

    local work="$SOHO_WORKSPACE" seed="$DAT_SEED"
    [ -e "$work" ] || work="<missing>"
    message -a -c "Workspace" "$work"
    [ -e "$work" ] || return

    get_dist "$1"
    local dist="$DAT_SOHO_DTAR" curr="$SOHO_DISTRO:$SOHO_CONFIG"
    [ -e "$dist" ] || dist="<missing>"
    [ "$curr" = ':' ] && curr="<missing>"
    if [ -f "$SOHO_WORKSPACE/$seed" ] ; then
        resolve -l -s seed -- "$SOHO_WORKSPACE/$seed"
    else
        seed="<missing>"
    fi
    message -a -c "Distributable" "$dist"
    message -a -c "Seed tar" "$seed"
    message -a -c "current" "$curr"

    local sarr item mesg="Completed"
    matchpath -a sarr -e -- "$SOHO_WORKSPACE/.state/"*-done
    for item in "${sarr[@]}" ; do
        item="${item##*/}"
        message -a -c "$mesg" "${item%-done}"
        mesg='...'
    done
}

# ------------------------------------------------------------------------------
# Install seed tar: [<conf>]
# ------------------------------------------------------------------------------
actionInstall() {
    get_base -f || return                           # change dir to base folder
    run_installer 'install' - "$1"
}

# ------------------------------------------------------------------------------
# Message text: <mesg> [<file>|- [<pref>]]
# ------------------------------------------------------------------------------
actionMessage() {
    get_base -n || return                           # get base folder
    outputMessage "$@"
}

# this function can be called from 'setup'
outputMessage() {
    local text=() pref="$3" subs="$4"
    ___message() {
        if [ -n "$1" ] ; then
            [ "${1::1}" = '#' ] && return
            text+=("$pref${1/\%1\%/$subs}")
        else
            text+=('')
        fi
        return 0
    }
    ___mesgsec() {
        [ "${1::1}" = '[' ] || return 0
        printf -v subs '%s%-11s %3s' "$pref" "$1" "${CEN_CONFIGFILE[2]}"
        text+=("$subs") ; return 0
    }

    if [ "${1:--}" = '-' ] ; then
        configfile -m -l ___mesgsec -n "$SOHO_WORKSPACE/dists/$SOHO_DISTRO/@misc/messages" '*'
    else
        configfile -l ___message -n "$SOHO_WORKSPACE/dists/$SOHO_DISTRO/@misc/messages" -- "$1"
    fi
    create -t -v text -- "${2:-}"
}

# ------------------------------------------------------------------------------
# network configuration: [cache|show|update|wait]
# ------------------------------------------------------------------------------
actionNetwork() {
    local what="${1:-show}" opts fupd
    case "$what" in
    cac*)   opts=('cache') ;;
    sho*)   opts=('--pager=yes' 'list') ;;
    upd*)   opts=('cache') ; fupd=1 ;;
    wai*)   waitForNetwork ; return ;;
    *)      invoke -e "Argument must be one of: cache update show wait" ; return
    esac
    get_base -f || return                           # change dir to base folder
    tmpfile -f || return
    copyFromTemplate '@shared/d_etc_default+centaurinetcfg' "$CEN_TMPFILE"
    embed -t centaurinetcfg validate --config="$CEN_TMPFILE" "${opts[@]}" || return
    [ -z "$fupd" ] && return
    move -- "$CEN_TMPFILE" "$CEN_ROOT/default/centaurinetcfg" || return
    attributes -m - -o root:wheel -- "$CEN_ROOT/default/centaurinetcfg"
}

waitForNetwork() {
    netconfig                                       # may fail, don't care
    progress -l $"Wait for network becoming online"
    local addr totl ftrp serv="$CEN_NET_SERVERS"
    [ "$HOSTNAME" = "$serv" ] && serv=              # don't wait for myself

    ___waitTrap() { ftrp=1 ; }                      # catch interrupt
    context -t ___waitTrap

    for addr in eth0 eth1 wlan0 wlan1 - ; do
        netiface -k "$addr" || continue
        nettool -q -d "$_netiface" isup && break
    done
    [ "$addr" = '-' ] && warning $"Perhaps no network interface is available"
    timer -i -
    while : ; do
        for addr in $serv 8.8.8.8 debian.org - ; do
            [ "$addr" = '-' -o  -n "$ftrp" ] && break
            sysrun -q -- ping -c1 -W2 "$addr" && break
        done
        if [ "$addr" = '-' -a -z "$ftrp" ] ; then
            timer -s totl -p -
            progress -a -p $"Waiting for network since %s [s]" "$((totl / 1000))"
            timer -w 2
            continue
        fi
        if [ -s '/etc/apt/apt.conf' ] ; then
            addr=
            txtgrep -i - -m -s addr -y 'Acquire::http::Proxy*' </etc/apt/apt.conf
            if [ -n "$addr" ] ; then
                addr="${addr#*\"}" ; addr="${addr#http://}" ; addr="${addr%\"*}"
                progress -l $"Check if apt proxy can be reached (use ^C to stop)"
                if ! echo 2>/dev/null >"/dev/tcp/${addr/:/\/}" ; then
                    error $"Cannot connect to apt proxy:" "$addr"
                    return 2
                fi
            fi
        fi
        context -t '-'
        if [ -n "$ftrp" ] ; then
            confirm -n $"Network check interrupted, continue anyhow" || quit -a -u
            ftrp=
        else
            message $"Network is online"
        fi
        return 0
    done
}

# ------------------------------------------------------------------------------
# Save or restore file ownerships: save|restore
# ------------------------------------------------------------------------------
actionOwners() {
    local osav item file
    case "$1" in
    sav|save)   osav=1 ;;
    res*)       ;;
    *)          invoke -e "Argument must be one of:" 'save restore' ; return
    esac
    get_base -f || return                           # change dir to base folder

    for item in 'dists'/[!@]* ; do
        [ -d "$item" ] || continue
        if ! [ -d "$item/dynamic" -a -d "$item/static" ] ; then
            invoke -e "Missing dynamic|static (run unpack):" "$dist" ; continue
        fi
        file="$item/OWNERS"
        if [ -n "$osav" ] ; then
            embed centauriowner --base="$item" --all --yes save "$file" || break
        elif [ -s "$file" ] ; then
            system -e -p -- chown -R 'root:root' "$item" || break
            embed centauriowner --base="$item" --all restore "$file" || break
        else
            invoke -e "Missing OWNERS file:" "$file" ; continue
        fi
    done
}

# ------------------------------------------------------------------------------
# Create seed tars and remove static and dynamic folders
# ------------------------------------------------------------------------------
actionPack() {
    get_base -f || return                           # change dir to base folder

    confirm -n "Create distribution tars and delete the tar sources" || quit -a -u

    local ysav="$CEN_YESNO" ; CEN_YESNO='y'
    local dirs=() dist item seed fldr noex
    for item in 'dists'/[!@]* ; do
        [ -d "$item" ] || continue
        dist="${item##*/}"

        if [ -d "$item/dynamic" -a -d "$item/static" ] ; then
            get_update "$item/dynamic"
            run_installer 'pack' "$dist"
        elif [ -s "$item/@seed/seed-$dist.tgz" ] ; then
            trace "Missing dynamic|static but seed tar exists:" "$dist"
        else
            invoke -e "Missing dynamic|static and missing seed tar:" "$dist"
            continue
        fi
        if [ -s "$item/@seed/seed-$dist.tgz" ] ; then
            for fldr in "$item/static" "$item/dynamic" "$item/configs" ; do
                [ -d "$fldr" ] && dirs+=("$fldr")
            done
        else
            invoke -e "Got no valid seed tar:" "$dist"
        fi
    done
    CEN_YESNO="$ysav"
    error -t || return
    if [ -n "$dirs" ] ; then
        confirm -y -f "Remove %s static|dynamic|configs folders" "${#dirs[@]}" &&
            remove -d -- "${dirs[@]}" 'static' 'dynamic'
    fi
    remove 'dists'/*/@seed/seed-*-*.tgz
    matchpath -a noex -n -- * ; remove -- "${noex[@]}"
}

# ------------------------------------------------------------------------------
# rename a system
# ------------------------------------------------------------------------------
actionRename() {
    local curr="$HOSTNAME" name="${2,,}" dorg dnew
    [ $# -gt 1 ] && curr="${1,,}" || name="${1,,}"
    [ "$curr" = "$name" ] && { invoke -e "Same hostname specified:" "$name" ; return ; }
    matchpath -o -e -s dnew -- "/dev/disk/by-label/${name}_"* \
                          && { invoke -e "New hostname is already in use:" "$name" ; return ; }
    matchpath -o -e -s dcur -- "/dev/disk/by-label/${curr}_"* \
                          || { invoke -e "Current hostname not valid:" "$curr" ; return ; }
    local item indx=0 parr=() args=() disk lblr
    for item in 'boot' 'swap' 'vol0' 'root' ; do
        findmount -d -l "${curr}_$item" && parr[indx]="$CEN_MOUNT_DEV"
        #trace -a -c "${curr}_$item" "$CEN_MOUNT_DEV"
        ((indx += 1))
    done
    if [ -z "${parr[2]}" ] ; then           # root partition: root or vol0
        parr[2]="${parr[3]}" ; lblr="${name}_root"
    else
        lblr="${name}_vol0"
    fi
    case "${parr[2]}" in
    *nvme*) disk="${parr[2]%p?}" ;;
    *mmcb*) disk="${parr[2]%p?}" ;;
    *)      disk="${parr[2]%[0-9]}" ;;
    esac
    if [ -z "${parr[0]}" ] ; then
        parr[0]="${disk}1"
        trace "get boot from device:" "${parr[0]}"
        [ -b "${parr[0]}" ] || parr[0]=
    else
        args+=(label "${parr[0]##*[a-z]}" "${name}_boot" --)
    fi
    [ -z "${parr[0]}" ] && { invoke -e "Found no boot/EFI partition" ; return ; }
    [ -z "${parr[1]}" ] && { invoke -w "Found no swap partition" ; }
    [ -z "${parr[2]}" ] && { invoke -e "Found no root partition" ; return ; }

    system -c udisksctl || quit -e "Please install the 'udisks2' package"

    [ -n "${parr[1]}" ] && args+=(label "${parr[1]##*[a-z]}" "${name}_swap" --)
    args+=(label "${parr[2]##*[a-z]}" "$lblr")

    findmount /
    if [ "$CEN_MOUNT_DEV" = "${parr[2]}" ] ; then
        cat <<!EOF

You are going try an 'in place rename'. This is supported but can make your
system un-bootable if anything goes wrong. Make sure that you can handle a
possible desaster properly!

!EOF
    fi
    cat <<!EOF
Do not interrupt any work in progress. Rename needs the following steps to
succeed:

    1)  update /etc/fstab and grub.cfg       tool: centaurirestore
    2)  update systemd boot menu and splash  tool: centauri(efilinux|raspi)
    3)  change partition labels              tool: centaurimedia

!EOF
    ___rename_x86() {
        confirm -y "Update /etc/fstab and 'grub.cfg'" &&
            embed -i -t -v -z centaurirestore -y -R "$2" -C "$name" -C + -C + -C +
        confirm -y "Update systemd boot menu and splash" &&
            embed -i -t -v -z centauriefilinux -y -B "$1" -R "$2" menu "$name"
    }
    ___rename_rpi() {
        confirm -y "Update /etc/fstab" &&
            embed -i -t -v -z centaurirestore -y -R "$2" -C "$name" -C + -C + -C -
        confirm -y "Update boot firmware config" || return
        local item args=()
        for item in "$1"/cmdline-*.txt ; do
            item="${item#*cmdline-}"
            args+=('entry' "${item%.txt}" "$3" '--')
        done
        embed -i -t -v -z centauriraspi --force --host="$name" "${args[@]}" 'default'
    }

    if [ -d '/boot/firmware' ] ; then
        ___rename_rpi '/boot/firmware' '/' "LABEL=$lblr"
    else
        ___rename_x86 '/boot/efi' '/' "LABEL=$lblr"
    fi

    folder -c /
    message -a "Umount and change partition labels"
    system -q -- umount -a --types vfat,ext4,btrfs

    confirm -y -f "Change partition labels of '%s'" "$disk" || return
    embed -i -v -z centaurimedia --yes --device="$disk" ${args[*]} -- probe || return

    message -a "Reload systemd and mount"
    system -e systemctl daemon-reload || return
    system -q -- mount -a --types vfat,ext4,btrfs
    message "Completed, please reboot soon"
}

# ------------------------------------------------------------------------------
# show repository info, copy from repository: [[-u] <path> [<dest> [<dflt>]]]
#
#   <path>      path in root file system
#   <dest>      destination, overrides <path> unless '-'
#   <dflt>      alternate for missing <path>, no error if '-'
# ------------------------------------------------------------------------------
actionRepository() {
    # get base folder and repository path
    get_base -n || return
    get_repository || return

    # no args: print repository information
    : ${DAT_HOST:=$HOSTNAME}
    local tmpl="$SOHO_WORKSPACE/templates"
    if [ $# = 0 ] ; then
        message -a -c "Repository" "$DAT_REPOSITORY"
        if [ -d "$DAT_REPOSITORY/@shared" ] ; then
            set -- "$DAT_REPOSITORY/@shared"/?_*
            trace -a -c "... shared" "$DAT_REPOSITORY/@shared ($# items)"
        else
            message -d 12 -a -c "... shared" "--- missing ---"
        fi
        if [ -d "$DAT_REPOSITORY/$DAT_HOST" ] ; then
            set -- "$DAT_REPOSITORY/$DAT_HOST"/?_*
            trace -a -c "... private" "$DAT_REPOSITORY/$DAT_HOST ($# items)"
        else
            message -d 12 -a -c "... private" "--- missing ---"
        fi
        if [ -d "$tmpl" ] ; then
            message -a -c "Templates" "$tmpl"
        else
            message -d 12 -a -c "Templates" "--- missing ---"
        fi
        return
    fi

    if [ -z "$SOHO_DNAME" ] ; then
        folder -c -f -p "$DAT_REPOSITORY/@shared/.."
        : ${SOHO_DNAME=${PWD##*/}}
    fi
    folder -c -f "$tmpl/.."
    copyFromRepo "$@"
}

configCheck() {
    trace -a -c " " "$@"
    if [ ! -d "$DAT_REPOSITORY/$1" ] ; then
        confirm -n -f "Host '%s' not found in repository. Continue anyhow" "$1" || quit -a -u
    fi
    return 0
}

# install a file from repository: [-c|-u] <path> [<dest> [<dflt>]]
copyFromRepo() {
    local fupd
    case "$1" in
    -c) configCheck "$DAT_HOST" ; return ;;         # return status
    -u) fupd='-u' ; shift                           # update
    esac
    trace -a -c " $fupd" "$@"

    local dest="${2:--}" dflt="$3" name
    get_path -d "$1" name                           # escape repo name
    local ndom="${name//$SOHO_DNAME/%D%}"           # allow domain substitution
    local glst=() repo="$DAT_REPOSITORY"
    [ "$dest" = '-' ] && dest="$1"
    if [ -n "$DAT_RASPI" ] ; then                   # raspiberry pi ...
        glst+=("$repo/$DAT_HOST/r$name" "templates/$DAT_HOST/r$name.TEMPLATE"
                                        "templates/$DAT_HOST/r$ndom.TEMPLATE"
               "$repo/@shared/r$name"   "templates/@shared/r$name.TEMPLATE"
                                        "templates/@shared/r$ndom.TEMPLATE"
               "$repo/$SOHO_SERVER/r$name")
    fi
                                                    # all and debian family
    glst+=("$repo/$DAT_HOST"/[ad]$name "templates/$DAT_HOST"/[ad]$name.TEMPLATE
                                       "templates/$DAT_HOST"/[ad]$ndom.TEMPLATE
           "$repo/@shared"/[ad]$name   "templates/@shared"/[ad]$name.TEMPLATE
                                       "templates/@shared"/[ad]$ndom.TEMPLATE
           "$repo/$SOHO_SERVER"/[ad]$name)
                                                    # get 1st existing file
    if ! matchpath -o -e -s repo -- "${glst[@]}" ; then
        case "$dflt" in
        '') error "File not in repository:" "$1" ; return 1 ;;
        -)  return 1 ;;
        *)  copyFromRepo "$dflt" "$dest" ; return   # return status
        esac
    fi
                                                    # destination, create folder
    case "$dest" in
    */)     dest+="${1:1}" ;;
    ..)     dest="../$1" ;;
    .)      dest="./$1" ;;
    esac
    folder -m -- "${dest%/*}" || return 1

    if [ "${repo%.TEMPLATE}" = "$repo" ] ; then
        copy -a $fupd -s -- "$repo" "$dest" && return 0
    else
        copyFromTemplate "$repo" "$dest" && return 0
    fi
    return 1
}

# ------------------------------------------------------------------------------
# Create from template: <finp>, documentation see: @misc/messages
#
#   SOHO_DISTRO                     # [1] debian distribution
#
# The template engine wants these variables:
#
#   SOHO_DOMAIN                     #     [2]
#   SOHO_DNAME                      #     [2] generated from DOMAIN
#   SOHO_SONAME                     # [1]
#   SOHO_NET_BASE                   #     [2]
#   SOHO_NET_PUBLIC                 # [1]
#   SOHO_SERVER                     #     [2]
#   SOHO_SECOND                     #     [2]
#   SOHO_ROUTERS                    #     [2]
#no SOHO_NET_ROUTER_DEF             #     [2] generated from SOHO_ROUTERS
#   SOHO_NET_ROUTER_IP4=            #     [2]
#   SOHO_NET_WLAN                   # [1]
#   SOHO_NET_APNT                   # [1]
#
#   HOSTNAME
#
#   CEN_NET_NETBITS
#   CEN_NET_NETMASK
#   CEN_NET_SERVER_GEN
#   CEN_NET_SERVERS     [0] [1]
#   CEN_NET_NETWORKS    [0] [1] [2]
#   CEN_NET_ADDR_IPLIST
# ------------------------------------------------------------------------------
templ_subst_name() {
    case "$DAT_SOHO_SUB" in
    A)  DAT_SOHO_SUB="$SOHO_NET_APNT" ;;
    B)  DAT_SOHO_SUB="$SOHO_NET_BASE" ;;
    C)  DAT_SOHO_SUB="$SOHO_HONAME" ;;
    D)  DAT_SOHO_SUB="$SOHO_DOMAIN" ;;
    G)  DAT_SOHO_SUB="$SOHO_GENAME" ;;
    H)  DAT_SOHO_SUB="$HOSTNAME" ;;
    I)  DAT_SOHO_SUB="$SOHO_NET_PUBLIC" ;;
    M)  DAT_SOHO_SUB="$SOHO_SONAME" ;;
    N)  DAT_SOHO_SUB="$SOHO_DNAME" ;;
    P)  DAT_SOHO_SUB="$SOHO_SERVER" ;;
    R)  DAT_SOHO_SUB="${SOHO_ROUTERS%%[[:space:]]*}" ;;
    S)  DAT_SOHO_SUB="$SOHO_SECOND" ;;
    W)  DAT_SOHO_SUB="$SOHO_NET_WLAN" ;;
    Z)  DAT_SOHO_SUB="$SOHO_DISTRO" ;;
    esac
}

templ_subst_ipv4() {
    case "$DAT_SOHO_SUB" in
    B)  DAT_SOHO_SUB="$CEN_NET_NETBITS" ; return ;;
    N)  DAT_SOHO_SUB="$CEN_NET_NETMASK" ; return ;;

    D)  DAT_SOHO_SUB="${CEN_NET_NETWORKS%/*}" ;;
    G)  nethost -- "$CEN_NET_SERVER_GEN" ; DAT_SOHO_SUB="$_nethost_ip" ;;
    H)  DAT_SOHO_SUB="$CEN_NET_ADDR_IPLIST" ;;
    P)  nethost -- "${CEN_NET_SERVERS[0]}" ; DAT_SOHO_SUB="$_nethost_ip" ;;
    R)  DAT_SOHO_SUB="$SOHO_NET_ROUTER_IP4" ;;
    S)  nethost -- "${CEN_NET_SERVERS[1]}" ; DAT_SOHO_SUB="$_nethost_ip" ;;

    V)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[1]}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ;;
    X)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[2]}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ;;

    *)  DAT_SOHO_SUB='[ERROR]' ; return ;;
    esac

    case "$1" in
    6)  netconv -u "$DAT_SOHO_SUB" ; DAT_SOHO_SUB="$_netconv" ;;
    5)  netconv -u "${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="$_netconv" ;;
    4)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ;;
    3)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*}" ;;
    2)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*.*}" ;;
    1)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*.*.*}" ;;
    0)  ;;
    *)  DAT_SOHO_SUB='[ERROR]' ;;
    esac
}

templ_subst() {
    # any %... string? If not just print (regexp are slow)
    local text="$1"
    local lead="${text%%%*}"
    [ "$lead" = "$text" ] && { printf '%s\n' "$text" ; return ; }
    local subs="${text:${#lead}}" tail xkey xsuf xres

    # loop over %...% fragments
    while [[ "${subs}" =~ (.*)%([ABCDGHIMNPRSVWXZ])(\^\^|\^|[1-6])?%(.*) ]] ; do
        subs="${BASH_REMATCH[1]}"       # not yet parsed
        xkey="${BASH_REMATCH[2]}"       # key
        xsuf="${BASH_REMATCH[3]}"       # suffix
        tail="${BASH_REMATCH[4]}$tail"  # already parsed
        DAT_SOHO_SUB="$xkey"            # substitute this now ...
        case "$xsuf" in
        '')     templ_subst_name ; tail="${DAT_SOHO_SUB}$tail" ;;
        '^')    templ_subst_name ; tail="${DAT_SOHO_SUB^}$tail" ;;
        '^^')   templ_subst_name ; tail="${DAT_SOHO_SUB^^}$tail" ;;
        *)      templ_subst_ipv4 "$xsuf" ; tail="${DAT_SOHO_SUB}$tail" ;;
        esac
    done
    printf "%s\n" "$lead$subs$tail"
    return 0
}

# ------------------------------------------------------------------------------
# Restore a disk tar: <imag> <disk> [<name> [ext4|btrs] [<swap>]] [<para>|-]
# ------------------------------------------------------------------------------
actionRestore() {
    local base disk dist rasp volf item host name curr="$PWD" para fsys swap swad='8'
    while [ $# -gt 0 ] ; do
        case "$1" in
        /dev/*)     disk="$1" ;;
        *.tar|+)    imag="$1" ;;
        *.*|-)      para="$1" ;;
        ext4|btrfs) fsys="$1" ;;
        [1-9]*M)    swap=1 ;;
        [1-9]*G)    swap="${1%G}"
                    [ -n "${swap//[0-9]}" ] && quit -e "Invalid swap size:" "$1"
                    ;;
        [a-z]*)     [ -z "$name" ] && name="$1" || para="$1";;
        *)          invoke -e "Invalid argument or hostname:" "$1" ; return
        esac ; shift
    done

    # check input
    blkdevice -d -e -x -- "$disk" || return
    inpfile -c -l -- "${imag:-+}" || return
    if [ "${para:--}" != '-' ] && [ ! -e "$para" ] ; then
        error "Parameter file not found:" "$para" ; return
    fi

    # create temp folder
    tmpfile -n -t -r -s base
    folder -c -f -m -r -- "$base"
    case "$CEN_INPFILE" in
    *-rpi_*)    swad='4'; rasp='rpi' ;;
    *-r32_*)    swad='4'; rasp='rpi' ; [ -z "$fsys" ] && fsys='ext4' ;;
    *debian-bookworm*)  item='worm9' ;;
    *debian-trixie*)    item='trix9' ;;
    *debian-*)          item='xxxx9' ;;
    esac

    # unpack imag
    system -e -p -r -- tar -xaf "$CEN_INPFILE" || return
    if matchpath -a labl -e -- $host*_boot_* $host*_root_* ; then
        matchpath -a labl -e -f -- *_boot_* *_root_*
        host="${labl%%_*}"
    fi

    if [ -n "$item" ] ; then
        warning "A minimal system must be renamed or will not boot:" "$host"
        name="$item" ; item=
    elif [ -z "$name" ] ; then
        name="$host"
    fi
    [ -z "$item" ] && get_value name "$name" - "Set hostname of installed image"
    [ -z "$swap" ] && get_value swap "$swad" - "Size of swap partition in GByte"

    [[ "$name" =~ [a-z][-a-z]*[a-z] ]] || quit -e "Invalid host name:" "$name"
    [ -n "${swap//[0-9]}" ] && quit -e "Invalid swap size:" "$swap"

    local opts=('-y' '-D' "$CEN_BLKDEVICE")
    if [ "${#labl[@]}" = 1 ] ; then                     # bios boot, no gpt ...
        labl=('' "$labl") ; opts+=('-B' '-M')
    elif [ "${#labl[@]}" != 2 ] ; then
        error "Input data unusable ($host):" "$CEN_INPFILE" ; return
    fi

    if [ "$fsys" = 'ext4' ] ; then
        opts+=('-4')
    else
        volf="${host}_volumes"
        if [ ! -e "$volf" ] ; then                      # ext4 mode without volumes file
            opts+=('-4') ; volf= ; fsys='ext4'
        fi
    fi

    [ "$name" != "$host" ] && opts+=(-N "$name")

    if [ -n "$rasp" ] ; then
        confirm -a -y -f '%-48s' "Install '$name' in 'raspberry' mode" || return
        embed -z -v centauridisk "${opts[@]}" -M -R 512 -P$swap -- "${labl[1]}"
    else
        confirm -a -y -f '%-48s' "Install '$name' in 'x86/pc' mode" || return
        embed -z -v centauridisk "${opts[@]}" -P$swap -- "${labl[1]}"
    fi

    # replace grub.cfg (ext4 mode only)
    while [ "$fsys" = 'ext4' ] ; do
        system -e -p -r -- partprobe ; sleep 1
        automount -b -- "${name}_root" || break ; auto=1
        [ -d "$CEN_MOUNT_DIR/boot/grub" ] || break
        [ -x "$CEN_MOUNT_DIR/usr/sbin/udate-grub.distrib" ] && break

        message "Replacing 'grub.cfg' with 'grub.minimal'"
        local gcfg stab="s/^set myname=.*/set myname=$name/"
        system -e -p -s gcfg -- sed -e "$stab" 'grub.minimal' || break
        create -t -v gcfg -- "$CEN_MOUNT_DIR/boot/grub/grub.cfg"

        targ='/usr/sbin/update-grub'
        message "Diverting '$targ' to noop"
        system -e -p dpkg-divert --root="$CEN_MOUNT_DIR" --rename --add "$targ" || break
        targ="$CEN_MOUNT_DIR$targ"
        dryrun "<script $targ>" && break
        {   echo "#!/usr/bin/bash"
            echo echo "update-grub: disabled by '$CEN_NAME'"
            echo exit 0
        } >"$targ"
        system -e -p -- chmod 775 "$targ"
        break
    done

    # apply parameter settings
    while [ "$para" != '-' ] ; do
        if [ -z "$auto" ] ; then
            system -e -p -r -- partprobe ; sleep 1
            automount -b -- "${name}_vol0" || break
            auto=1
        fi
     #   if [ -z "$para" ] ; then
     #       para="$CEN_MOUNT_DIR/etc/default/$CEN_NAME"
     #       [ -s "$para" ] || para=
     #   fi
        actionConfig query "$CEN_MOUNT_DIR" "$name" "$para"
        break
    done

    # extra volumes
    if [ -n "$volf" ] ; then
        local auto tarf volu
        while read item ; do
            case "$item" in
            Root|Home)
                ;;
            *)
                matchpath -e -o -s tarf -- *_${item,}_*
                message -p "Extra volume: %s  Tar file: %s" "$item" "${tarf:--}"
                if [ -z "$auto" ] ; then
                    system -e -p -r -- partprobe ; sleep 1
                    automount -b -- "${name}_vol0" || break
                    auto=1
                    if [ ! -d "$CEN_MOUNT_DIR/Volumes" ] ; then
                        error "Missing folder:" "$CEN_MOUNT_DIR/Volumes"
                        break
                    fi
                fi
                volu="$CEN_MOUNT_DIR/Volumes/$item"
                if [ ! -e "$volu" ] ; then
                    system -e -p -- btrfs subvolume create "$volu"
                    create -- "$volu/${name^^}_${item^^}"
                    [ "$item" = 'Backup' ] &&
                        embed centauridata init "$CEN_MOUNT_DIR/Volumes/Backup" - + -
                fi
                [ -n "$tarf" ] &&
                    system -e -p -- tar -C "$volu" -xaf "$tarf"
            esac
        done < "$volf"
        [ -z "$auto" ] || automount -q
    fi

    # remove tmp data
    folder -c -f -- "$curr"
    remove -d -- "$base"
}

# ------------------------------------------------------------------------------
# call setup plugin
# ------------------------------------------------------------------------------
actionSetup() {
    # run config if we have no cached netcfg ...
    if [ ! -s "$CEN_ROOT/persistent/centaurinetcfg" ] ; then
        message "Creating network configuration data"
        actionConfig 'net' ; error -t || return
    fi

    # run setup script ...
    local rest verb="$CEN_ACTION"
    case "$CEN_ACTION" in
    clone)  get_base -f || return ; verb= ;;
    seed)   get_base ;;
    *)      get_base -f || return
    esac
    trace -a -c "Base folder" "$SOHO_WORKSPACE"

    # source the setup script as plugin
    if [ -z "$CEN_OPT_DISPATCH" ] ; then
        get_architecture || return

        # updated seed tar, must restart
        if [ "$DAT_SEED" -nt '.timestamp' ] ; then
            trace "The seed tar was updated, must restart after unpacking"
            dryrun -s "unpack/restart" && quit -t -a
            run_installer 'install'
            # install replaced our sources, so we must restart now ...
            [ "$DAT_SEED" -nt '.timestamp' ] ||
                embed -x "$CEN_NAME" "${CEN_CMDOPTS[@]}" "${CEN_CMDARGS[@]}"
            quit -t -i                      # quit if not exexuted
        fi

        get_setup || return
    fi

    # at this point setup has sourced setup.conf, so we can use it's variables
    dryrun -s 'setup' && return

    local repo="$CEN_ROOT/configs/$SOHO_DISTRO/${SOHO_DOMAIN%%.*}"
    if [ "templates/$DAT_SOHO_NETCFG.TEMPLATE" -nt "$repo/$DAT_SOHO_NETCFG" ] ; then
        message "The network configuration needs to be updated"
        actionConfig 'net'
    fi

    trace -p "Calling '%s' in 'setup' script" "$CEN_OPT_DISPATCH"
    [ -n "${CEN_CMDARGS[CEN_CMDINDX]}" ] && DAT_NOT_LAST=1 || DAT_NOT_LAST=
    isfunction -c -e --  "$CEN_OPT_DISPATCH" $verb "$@"
    trace -p "Returned from '%s'" "$CEN_OPT_DISPATCH"

    local serv icli
    nethost "$HOSTNAME" ; icli="$_nethost_ip"
    if netquery -e -s serv primary ; then
        nethost "$serv"
        SOHO_LOCKED="$SOHO_DOMAIN - - $serv $_nethost_ip"
    else
        SOHO_LOCKED="$SOHO_DOMAIN $HOSTNAME $icli $serv $_nethost_ip"
    fi

    if [ 'setup.conf' -nt "$DAT_SOHO_PARAMS" ] ; then
        trace "Updating parameter file..."
        cfg_params -w
    fi
}

# ------------------------------------------------------------------------------
# Process a template: <tmpl> [<fout>|-]
# ------------------------------------------------------------------------------
actionTemplate() {
    if [ "$#" = 0 ] ; then
        syspager                                # check pager
        get_base -n || return
        $CEN_PAGER outputMessage 'template' ; return
    fi
    copyFromTemplate "$1" "$2"
}

# update installed templates: <wrks> [<host> [<root>]]
copyAllTemplates() {
    local item priv dest host="${2:--$HOSTNAME}" root="$3"
    local tmpl="$1/templates"
    if [ ! -d "$tmpl" ] ; then
        invoke -e $"Cannot locate the 'templates' folder" ; return 1
    fi
    for item in "$tmpl/@shared/"*.TEMPLATE ; do
        priv="${file/@shared/$host}"
        [ -e "$priv" ] && item="$priv"
        item="${item%.TEMPLATE}"
        get_path -u "${item##*/}" dest
        dest="${dest//%D%/$SOHO_DNAME}"

    # TODO handle prefix a, r, d ...
        dest="$root${dest:2}"
        [ -e "$dest" ] || continue
        copyFromTemplate "$item" "$dest"
    done
}

copyFromTemplate() {
    if [ -z "$DAT_GOT_CONF" ] ; then
        get_base -n || return
        if [ -z "$CEN_NET_DOMAIN" ] ; then
            get_setup || return
        fi
        DAT_GOT_CONF=1
    fi

    local dest tmpl="${1%.TEMPLATE}.TEMPLATE"
    [ "${tmpl::1}" = '/' ] || tmpl="$SOHO_WORKSPACE/templates/${tmpl#templates/}"

    if [ "$2" = '.' ] ; then
        get_path -u "${tmpl%.TEMPLATE}" dest    # un-decorate destination
        dest="${dest//%D%/$SOHO_DNAME}"         # allow domain substitution
        outfile -- "$dest" || return
    elif [ "${2:--}" = '-' ] ; then
        inpdata -r -c templ_subst -- "$tmpl"
        return
    elif [ -d "$2" ] ; then
        get_path -u "${tmpl%.TEMPLATE}" dest    # un-decorate destination
        dest="${dest//%D%/$SOHO_DNAME}"         # allow domain substitution
        outfile -a -q -- "$2$dest" || return
    else
        outfile -a -- "$2" || return
    fi

    dryrun "template $tmpl -> $CEN_OUTFILE" && return
    inpdata -c templ_subst -- "$tmpl" >"$CEN_OUTFILE"
    [ -x "$tmpl" ] && attributes -m 775 -- "$CEN_OUTFILE"
}

# ------------------------------------------------------------------------------
# action unpack distributable tars to workspace: [<dist> [<conf>]]
# ------------------------------------------------------------------------------
actionUnpack() {
    get_base -f || return

    local dirs=() dist item star curr
    for item in "$SOHO_WORKSPACE/dists"/[!@]* ; do
        [ -d "$item" ] || continue
        dist="${item##*/}"
        [ "${1:--}" != '-' -a "$1" != "$dist" ] && continue
        if [ "${2:--}" != '-' ] ; then
            curr="$1:$2"
            matchpath -e -o -- "$item/@seed/seed-$dist-$2.tgz"
        else
            curr="$1"
            matchpath -e -o -- "$item/@seed/seed-$dist".tgz "$item/@seed/seed-$dist"-*.tgz
        fi
        star="$CEN_MATCHPATH"
        if [ ! -s "$star" ] ; then
            warning -a -c $"Cannot unpack - no seed tar:" "$curr"
            continue
        elif [ -d "$item/dynamic" -o -d "$item/static" ] ; then
            warning -a -c $"Skipping unpack" "$dist -" $"'dynamic' or 'static' folder already exists"
            continue
        fi
        message -a -c $"Run unpack" "$star"
        system -f -- tar --directory="$item" -xaf "$star"
    done
}

# ------------------------------------------------------------------------------
# zerofill and trim free space: -no args-
# ------------------------------------------------------------------------------
actionVacuum() {
    confirm -y $"This will remove all cache data and log files" || return
    embed -y centauricleanup --all
    embed -y centaurimedia copy '/dev/zero' "$CEN_NAME-$$.tmp"
    remove "$CEN_NAME-$$.tmp"
    system -q -- fstrim /
    if [ -d '/mnt/boot' ] ; then
        if system -q -- systemd-detect-virt -q ; then
            embed centaurimedia copy '/dev/zero' "/mnt/boot/$CEN_NAME-$$.tmp"
            remove "/mnt/boot/$CEN_NAME-$$.tmp"
        fi
        system -q -- fstrim '/mnt/boot'
    fi
}

# ------------------------------------------------------------------------------
# sync workspace with repository: get|put <work> [<dist>]
# ------------------------------------------------------------------------------
actionWorkspace() {
    # archive workspace
    if [ "${1::3}" = 'arc' ] ; then
        actionPack ; error -t || return
        run_installer 'archive' "$2"
        return
    fi

    # workspace folder ...
    if [ "$1" = 'get' ] ; then
        if [ -e "$2" ] ; then
            confirm -n $"Existing workspace, continue anyhow" || return
            folder -c -f -- "$2"
        else
            folder -c -m -f -- "$2"
        fi
    elif [ "$1" = 'put' ] ; then
        if [ ! -d "$2" ] ; then
            invoke -e $"Workspace not found" ; return
        fi
        folder -c -f -- "$2"
    else
        invoke -e $"1st argument must be 'get' or 'put'" ; return
    fi
    message -a -c $"Workspace folder" "$PWD"

    # repository folder ...
    local repo dist
    if [ "${3:--}" = '-' ] ; then
        resolve -e -c -s repo -- "$CEN_ROOT/shared/../.." || return
    else
        folder -s repo -- "$CEN_ROOT/configs/$3" || return
    fi
    message -a -c $"Repository" "$repo"

    if [ "$1" = 'get' ] ; then
        # copy content of master folder
        embed -z centauricopy sync "$repo/@soho/master" . || return
        CEN_OPT_BASE="$PWD" ; actionUnpack
    else
        for dist in dists/[a-z]* ; do
            [ -d "$dist/static" ] || continue
            run_installer pack "${dist#*/}"
        done
        embed -z centauricopy sync -x 'dists/[a-z]*/[a-z]*' -x 'seed-*-*.tgz' \
                              -x '^seed.tgz' -x '^setup.conf' -x '^configs' \
                              -x '^dynamic' -x '^packages' -x '^passwords' \
                              -x '^private' -x '^static' -x '^templates' \
                              "$repo/@soho/master"
    fi
}

# ------------------------------------------------------------------------------
# Testing
# ------------------------------------------------------------------------------
actionXxx() {
    return 0
}

# ------------------------------------------------------------------------------
# option parsing: <option> [<argument>]
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    -B|--bas|--base)
        optarg 'base'       -    -d ;;          # existing folder

    -C|--curr*)
        optarg 'current'    -    -t ;;          # text argument

    -N|--net*)
        optarg 'netcfg'     -    -o ;;          # ternary

    --dis*)
        optarg 'dispatch'   -    -t ;;          # text argument

    esac
}

# ------------------------------------------------------------------------------
# action parsing: <verb> <argument>...
# ------------------------------------------------------------------------------
actions() {
    case "$1" in

    # admin actions
    con*)
        invoke -s 'config'  -             1 4 ;;   # 1 .. 4 args
    dis*)
        invoke -s 'distr'   -             0 2 ;;   # one optional arg
    doc*|help)
        invoke    'docview' -             0 + ;;   # one optional arg
    dum|dump)
        invoke -s 'dump'    -               0 ;;   # no args
    exp*)
        invoke -s 'expand'  -             0 1 ;;   # one optional arg
    inf*)
        invoke -s 'info'    -             0 1 ;;   # one optional arg
    ins*)
        invoke -s 'install' -             0 1 ;;   # one optional arg
    pac|pack)
        invoke -s 'pack'    -               0 ;;   # no args
    unp*)
        invoke -s 'unpack'  -             0 2 ;;   # 0 .. 2 args
    wor*)
        invoke -s 'workspace' -           2 3 ;;   # 2 or 3 args

    # setup actions
    app*)
        invoke -r 'appli'   actionSetup     0 ;;   # no args
    bac*)
        invoke -r 'backup'  -             2 4 ;;   # 2 ... 4 args
    bas|base)
        invoke -r 'base'    actionSetup     0 ;;   # no args
    cli*)
        invoke -r 'client'  actionSetup     0 ;;   # no args
    clo*)
        invoke -r 'clone'   actionSetup   1 3 ;;   # 1 or 3 args
    mes*)
        invoke    'message' -             1 4 ;;
    net*)
        invoke -r 'network' -             0 1 ;;
    own*)
        invoke -r 'owners'  -             1   ;;
    ren*)
        invoke -r 'rename'  -             1 2 ;;   # 1 or 2 args
    rep*)
        invoke -r 'repository' -          0 3 ;;
    res*)
        invoke -r 'restore' -             2 + ;;
    see|seed)
        invoke -r 'seed'    actionSetup     0 ;;
    ser*)
        invoke -r 'server'  actionSetup     0 ;;   # no args
    tem*)
        invoke    'template' -            0 2 ;;   # 0 ... 2 args
    vac*)
        invoke -r 'vacuum'   -              0 ;;
    xxx*)
        invoke  'xxx'   -              0 + ;;

    # short form aliases for 'clone'
    /dev/*)
        invoke -r 'clone'   actionSetup    1 3 "$@" ;;  # 1 .. 3 args

    # call an exended command of 'setup'
    ??*)
        local item ; get_cmds
        for item in "${DAT_SOHO_CMDS[@]}" ; do
            item="${item%|*}"
            [ "$1" = "$item" ] && invoke -r "$item" actionSetup - - "${@:2}"
        done
    esac
}

# ------------------------------------------------------------------------------
# usage info
# ------------------------------------------------------------------------------
usage() {

    usageset \
        -o - \
        -o '--dispatch   <func>'  $"internal: used by setup helper to register" \
        -o -                      $"          a dispatch function for commands" \
        -o '-B --base    <fldr>'  $"workspace folder containing the seed tar" \
        -o '-C --current <dist>:<inst>' \
        -o -                      $"select the current distribution and installation" \
        -o '-N --netcfg  <mnet>'  $"prefer 'centaurinetcfg' data over 'setup.conf'" \

    usageset \
        -a $"â¢â¢â¢ setup commands â¢â¢â¢" \
        -a 'configure'            $"# update 'setup.conf' from network configuration" \
        -a 'seed'                 $"# step 1: unpack seed tar" \
        -a '[clone] /dev/<disk> [<name> [<swap>]]' \
        -a -                      $"# step 2: clone to EFI bootable BTRFS disk" \
        -a 'base'                 $"# step 3: install a base system" \
        -a 'client'               $"# ...     make this a client machine" \
        -a 'appliance'            $"# ...     make this an appliance" \
        -a 'server'               $"# ...     make this a server machine"

    local item ; get_cmds
    for item in "${DAT_SOHO_CMDS[@]}" ; do
        usageset -a "${item%|*}" "# ${item#*|}"
    done

    usageset \
        -a - \
        -a "â¢â¢â¢ setup tools â¢â¢â¢" \
        -a 'config     [network|show|update]' \
        -a -                      $"# update configuration from 'setup.conf'" \
        -a 'config     query [<dest>|- [<name>|- [<para>|-]]]'\
        -a -                      $"# update configuration using a menu" \
        -a 'info'                 $"# print some status information" \
        -a 'network    [cache|show|update|wait]' \
        -a 'repository [<path> [<dest>|- [<dflt>|-]]]' \
        -a -                      $"# install a file from repository" \
        -a 'template   <path> [<file>|-|.]' \
        -a -                      $"# expand a template to stdout or a file" \
        -a - \
        -a "â¢â¢â¢ packaging commands â¢â¢â¢" \
        -a 'distrib    [[<dist>]Â°<conf>]' \
        -a -                      $"# generate distributable tar file from workspace" \
        -a 'expand     [<soho>]'  $"# create workspace from distributable tar file" \
        -a 'owner      save|restore' \
        -a -                      $"# restore file attributes (git clone) or save" \
        -a 'pack'                 $"# generate seed tar file from workspace" \
        -a 'unpack     [[<dist>]Â°<conf>]' \
        -a -                      $"# unpack seed tar file in workspace" \
        -a 'workspace  archive -|<suff>' \
        -a -                      $"# run 'pack' and create 'centaurisoho-master' tar" \
        -a 'workspace  get|put <work> [<dist>]' \
        -a -                      $"# syncronize workspace with repository" \

    usageset \
        -a - \
        -a $"â¢â¢â¢ other/helpers â¢â¢â¢" \
        -a 'backup     <host> <boot>|-|+ [<root>|-|+ [<arch>]]' \
        -a -                      $"# offline backup to create a disk tar" \
        -a 'docview    [<key>]'   $"# documentation viewer" \
        -a 'message    <mtag> [<file>|- [<pref> [<subs>]]]' \
        -a -                      $"# cat or copy a text from '@misc/messages' file" \
        -a 'rename     [<curr>] <name>' \
        -a -                      $"# change the hostname of a running system" \
        -a 'restore    <dist> <disk> [ext4|btrfs] [<name>] [<swap>] [<para>|-]' \
        -a -                      $"# install an image tar to a block device" \

    usageset \
        -p '<arch>'               $"backup target: architecture" \
        -p '<boot>'               $"... [*] [**]   boot partition or mountpoint" \
        -p '<host>'               $"...            current host name" \
        -p '<root>'               $"... [*] [***]  root partition or mountpoint" \
        -p '[*]'                  $"use '+' to get partition label from host name" \
        -p '[**]'                 $"use '-' to skip" \
        -p '[***]'                $"use '-' for '<host>_root' instead of '<host>_vol0'" \
        -p - \
        -p '<mtag>'               $"message text: section tag inside []" \
        -p '<pref>'               $"...           line prefix like '# '" \
        -p '<subs>'               $"...           substitute for %1%" \
        -p - \
        -p '<dest>'               $"destination unless '-', overrides <path>" \
        -p '<dflt>'               $"alternate for missing <path>, no error if '-'" \
        -p '<disk>'               $"a disk drive name like **sdb** or **mmcblk1**" \
        -p '<file>'               $"file name or path" \
        -p '<key>'                $"a chapter number or a word to search for" \
        -p '<mnet>'               $"use one of: 0|off  1|on  2|auto (default)" \
        -p '<name>'               $"the name that is assigned to the clone" \
        -p '<para>'               $"paramater file (default: /etc/default/$CEN_NAME)," \
        -p -                      $"use '-' to disable configuration prompts" \
        -p '<path>'               $"full path name, starts with '/'" \
        -p '<seed>'               $"alternate seed tar (gets linked to seed.tar)" \
        -p '<soho>'               $"master tar file (the distributable)" \
        -p '<suff>'               $"append suffix to file name (before extension)" \
        -p '<swap>'               $"swap partition size in <nnn>M or <nn>G notation" \

    usageset \
        -l $"Setup" \
        -t $"In step 1 you unpack a distributable tar and run the extracted 'setup':" \
        -t - \
        -t "Â°   tar -xaf centaurisoho-bookworm-worms.tgz" \
        -t "Â°   centaurisoho-bookworm-worms/setup seed" \
        -t - \
        -t $"This step installs centauri-bash-library and tools. You can continue" \
        -t $"using 'setup' or you can now use the slightly friendlier '$CEN_NAME'."

    usageset \
        -l $"Templates" \
        -t $"The 'repository' and 'template' actions use '*.TEMPLATE' files to generate" \
        -t $"configuration files. Template parameters are from 'setup.conf' (setup step" \
        -t $"1 and 2) or later also from '/etc/default/centaurinetcfg'."
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
