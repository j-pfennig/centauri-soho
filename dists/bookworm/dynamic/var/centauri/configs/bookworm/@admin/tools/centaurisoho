#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL='Dr. JÃ¼rgen Pfennig (c) 2023-2025; '$"BSD License"
CEN_TITLE=$"Installer tool for centaurisoho linux machines"

# Import the bash library
if [ -z "$CEN_NAME" ] ; then
    PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -m con -t -y - '0.21:3' || exit 2
fi

# Variable naming scopes ...

#   CEN_OPT_                    # options
#   DAT_SOHO_                   # this script
#   DAT_                        # the setup script
#   SOHO_                       # setup.conf

SOHO_WORKSPACE=                 # see get_workspace and --base
SOHO_DISTRO=                    # debian distribution

# Shared with 'setup' script:
SOHO_APT_PROXY=
SOHO_CONFIG=                    # name of the network configuration
SOHO_DOMAIN=                    # domain name
SOHO_DOMUSR=                    # a domain test user
SOHO_ROUTERS=                   # router list, 1st is generic router name

SOHO_NET_BASE=                  # network base address/mask
SOHO_NET_PUBLIC=                # public dyn-dns provider
SOHO_NET_ROUTER_DEF=            # name for primary router
SOHO_NET_ROUTER_IP4=            # 1st router ip address
SOHO_NET_WLAN=                  # wlan ssid
SOHO_NET_APNT=                  # wlan ssid for host access point
SOHO_NET_EXTERN=                # external base address/mask

SOHO_REPO_OPTS=                 # repository OPTIONS
SOHO_SONAME=                    # soho default machine name prefix
SOHO_GENAME=                    # generic server name

SOHO_SWAP_SIZE=
SOHO_PLATFORM=                  # usally set by get_architecture
SOHO_HOST=                      # target host, see cfg_apply() and setup script

DAT_SOHO_KEYB=                  # see cfg_keyboard

# Data
CEN_OPT_BASE=                   # base folder, see --base
CEN_OPT_CURRENT=                # current config, see --current
CEN_OPT_DISPATCH=               # see --dispatch

DAT_SOHO_ARCH=                  # architecture, see get_architecture()
DAT_SOHO_PARAMS="${CEN_PATHS[6]}/$CEN_NAME"
DAT_SOHO_NETCFG="${CEN_PATHS[6]}/centaurinetcfg"
DAT_SOHO_CMDS=                  # setup extra commands
DAT_SOHO_NETREP='@shared/d_etc_default+centaurinetcfg'
DAT_SOHO_SEED=                  # abs path of seed.tgz
DAT_SOHO_SUB=                   # see actionTemplate
DAT_SOHO_DTAR=                  # Distributable tar file
DAT_SOHO_DEST=                  # mount point, see cfg_apply
DAT_SOHO_ROOT="$CEN_ROOT"       # overriden by cfg_apply() to match DAT_SOHO_DEST

DAT_SEED='seed.tgz'             # the seed tar
DAT_NOT_LAST=                   # true if not last command

# imported
declare DAT_REPOSITORY DAT_RASPI

# ------------------------------------------------------------------------------
# Protect the development system
# ------------------------------------------------------------------------------
allowInstall() {
    # explicitly allowed ...
    [ -n "$CEN_OPT_FORCE" ] && return 0
    [ -f "$CEN_ROOT/persistent/$CEN_NAME-conf" ] && return 0
    # protect the development system ...
    [ -d "$CEN_TOOLS/utilities" ] || return 0

    [ "$CEN_ACTION" = 'restore' ] && return 0
    quit -e $"The command cannot be used on this host:" "$CEN_ACTION"
}

# ------------------------------------------------------------------------------
# handle configuration parameters: -q|-r|-w [<file>]
#                                  -p [<file> <wrks>]
#
#       -p      patch setup.conf with current parameters
#       -r      read only
#       -q      query prompt user for parameters
#       -t      read parameters from centaurisoho config file
#       -w      write parameters to config file
# ------------------------------------------------------------------------------
cfg_params() {
    # get parameter file path ...
    local opti="$1" file="${2:-$DAT_SOHO_PARAMS}"

    # patch password file...
    if [ "$opti" = '-p' ] ; then
        [ -z "$2" -o -z "$3" ] && fatal -t $"Option '-p' needs <file> and <wrks> arguments"
        local stab item
        item="$3/passwords"
        stab="s/^wlanpsk=.*/wlanpsk=${SOHO_NET_WLAN_PW@Q}/"
        if [ -f "$item" ] ; then
            system -e -p sed --regexp-extended --in-place=".$CEN_NAME" -e "$stab" "$item"
        else
            warning $"Missing password file:" "$3"
        fi
        return 0
     fi

     # prompt for parameters...
     if [ "$opti" = '-q' ] ; then
        local pent=$"<please enter>" popt=$"<optional>" sodo netb conf gnam
        cfg_keyboard -q
        get_value SOHO_DOMAIN           'soho.home' "$SOHO_DOMAIN" $"Domain name  (updates certs)"
        sodo="${SOHO_DOMAIN%%.*}" ; conf="$SOHO_CONFIG"
        get_value SOHO_ZONE             "$sodo"         "$conf" $"Repository configuration name"
        get_value SOHO_NET_PUBLIC       -               "$pent" $"External DNS (- for none)"
        get_value SOHO_SONAME           "$sodo"         -       $"Default machine name prefix"
        gnam="${SOHO_SONAME:-$SOHO_GENAME}1"
        get_value SOHO_SERVER           "$SOHO_SERVER"  "$gnam" $"Primary server name"
        case "$SOHO_SERVER" in
        *0) SOHO_GENAME="${SOHO_SERVER%0}" ; SOHO_SECOND="$SOHO_GENAME"1 ;;
        *1) SOHO_GENAME="${SOHO_SERVER%1}" ; SOHO_SECOND="$SOHO_GENAME"2 ;;
        esac
        netb="${SOHO_NET_BASE:-10.10.0.0/21}"
        get_value SOHO_NET_BASE         "$netb"         -       $"Network IPv4 address and mask"
        get_value SOHO_NET_EXTERN       -               "$popt" $"External Network addr. and mask"
        netb="${SOHO_NET_BASE%.*.*}"
        get_value SOHO_NET_ROUTER_DEF   'router'        -       $"Primary router name"
        get_value SOHO_NET_ROUTER_IP4   "${netb}.1.1"   -       $"Primary router IPv4 address"
        get_value SOHO_APT_PROXY        "${netb}.1.10"  -       $"APT proxy IPv4    (- to disable)"

        get_value SOHO_NET_WLAN         "$sodo"         -       $"WLAN client SSID  (- to disable)"
        get_value SOHO_NET_APNT         "$sodo-ap"      -       $"WLAN AP SSID      (- to disable)"
        if [ "$SOHO_NET_WLAN" != '-' -o "$SOHO_NET_APNT" != '-' ] ; then
            [ "$SOHO_NET_WLAN" = "$SOHO_NET_APNT" ] &&
                fatal $"SSIDs of WLAN client and WLAN AP must not be equal"
            get_value SOHO_NET_WLAN_PW  -               "$pent" $"WLAN password     (- for random)"
        fi
        : "${SOHO_NET_PUBLIC:=-}" "${SOHO_NET_WLAN_PW:=-}"

    # read parameter file ...
    elif [ "$opti" != '-w' ] ; then
        if [ -r "$file" ] ; then
            local wrks="$SOHO_WORKSPACE"
            source "$file" ||
                fatal $"Parameter loading failed:" "$file"
            [ -n "$wrks" ] && SOHO_WORKSPACE="$wrks"
            trace -a -c "Parameters read" "$file"
        else
            trace -a -c "Got no parameters" "$file"
            return 1
        fi
    fi

    # last chance defaults, centaurinetcfg needs these...
    : ${SOHO_GENAME:=server}
    : ${SOHO_ROUTERS:=router}
    set -f ; set -- $SOHO_ROUTERS ; set +f
    : ${SOHO_NET_ROUTER_DEF:="${2:-"${1}0"}"}

    # write config file ...
    if [ "$opti" = '-w' ] ; then
        local item curr list idnt
        if [ "$file" = '-' ] ; then
            message -m $"Current parameter values..." ''
            idnt="${CEN_NAME//?/ }      "
        else
            list=(
            "# '${file##*/}' is a parameter file used by centaurisoho."
            "#"
            "# Purpose #1: it remembers the current workspace path, distro and config"
            "#         #2: it provides defaults for image tar installations"
            "#"
            "# There is little reason to edit this file except for purpose #2."
            ""
            )
        fi

        # temporarily remove mount point from workspace path...
        SOHO_WORKSPACE="${SOHO_WORKSPACE#$DAT_SOHO_DEST}"
        trace -a -c " save" "$SOHO_WORKSPACE $SOHO_DISTRO $SOHO_CONFIG ..."

        for item in SOHO_WORKSPACE SOHO_DISTRO SOHO_CONFIG - \
                    SOHO_DOMAIN SOHO_SONAME SOHO_GENAME SOHO_SERVER SOHO_SECOND - \
                    SOHO_APT_PROXY SOHO_REPO_OPTS SOHO_NET_PUBLIC - \
                    SOHO_NET_BASE SOHO_NET_ROUTER_DEF SOHO_NET_ROUTER_IP4 \
                    SOHO_NET_EXTERN - SOHO_NET_WLAN SOHO_NET_APNT SOHO_NET_WLAN_PW - \
                    SOHO_DOMUSR SOHO_HASS ; do
            if [ "$item" = '-' ] ; then
                list+=('') ; continue
            fi
            eval curr=\"\$$item\" ; curr="${curr@A}"
            list+=("$idnt$item=${curr#*=}")
        done
        SOHO_WORKSPACE="$DAT_SOHO_DEST$SOHO_WORKSPACE"

        if [ "$file" = '-' ] ; then
            list+=('')
            create -r -v list -- - || return 1
        else
            list+=('' '# end')
            create -t -v list -- "$file" 600 || return 1
            cfg_keyboard -u
        fi
     fi

    # set netconfig params that are needed for template exansion
    if [ -n "$SOHO_NET_BASE" ] ; then
        CEN_NET_DOMAIN="$SOHO_DOMAIN"
        CEN_NET_SERVER_GEN="$SOHO_GENAME"
        CEN_NET_SERVERS=("$SOHO_SERVER" "$SOHO_SECOND")
        get_address "$SOHO_NET_BASE" || return 1
        CEN_NET_ADDR_IPLIST=('10.255.255.1')
    fi
    return 0
}

# ------------------------------------------------------------------------------
# Config keyboard layout for minimal host: -q|-u
# ------------------------------------------------------------------------------
#       -q      query
#       -u      update destination
#
# Using debian's '/etc/default/keyboard' file. Copy local file if present.
#
# 'setup clone' creates an issue file: '$CEN_ROOT/persistent/issue.d/keyboard',
# so we do nothing if this file exists.
# ------------------------------------------------------------------------------
cfg_keyboard() {
    [ -z "$DAT_SOHO_DEST" ] && return 0             # do nothing on current host
                                                    # ignore with issue file ...
    [ -e "$DAT_SOHO_ROOT/persistent/issue.d/keyboard" ] && return 0

    local keyb='/etc/default/keyboard' dflt="<copy current>" dval='-'

    if [ "$1" = '-q' ] ; then
        # do we have a local debian Keyboard config?
        [ -s "$keyb" ] || { dflt='us' ; dval="$dflt" ; }
        get_value DAT_SOHO_KEYB "$dval" "$dflt" $"Keyboard layout (fr,de,us,...)"
        return 0
    elif [ "$1" != '-u' ] ; then
        return 1
    fi

    if [ "$DAT_SOHO_KEYB" = '-' ] ; then            # disabled
        :
    elif [ -z "$DAT_SOHO_KEYB" ] && [ -s "$keyb" ] ; then
        copy -- "$keyb" "$DAT_SOHO_DEST" || return 1
    else
        create -t -h - -- "$DAT_SOHO_DEST$keyb" <<!EOF
XKBMODEL="pc105"
XKBLAYOUT="$DAT_SOHO_KEYB"
XKBVARIANT=""
XKBOPTIONS=""
BACKSPACE="guess"
!EOF
    fi
    return 0
}

# ------------------------------------------------------------------------------
# apply configuration: <dest>|- <name>|- <para>|-|+
# ------------------------------------------------------------------------------
#   Where to get centaurisoho parameters:
#   (1) <para> file argument
#   (2) <dest>/etc/default/centaurisoho
#   (3) /etc/default/centaurisoho
#
#   <dest>  mountpoint of root-fs or '-' for this machine
#   <name>  machine name or '-' for $HOSTNAME
#   <para>  '+' to query  '-' no params  <file> param file
# ------------------------------------------------------------------------------
cfg_apply() {
    local dest="${1%/}" ; dest="${dest:--}"
    local name="${2:--}" para="$3"
    local list wrks dcfg="$DAT_SOHO_PARAMS"
    [ "$name" = '-' ] && name="$HOSTNAME" || SOHO_HOST="$name"

    if  [ "$dest" = '-' ] ; then
        allowInstall                                # check permission to install
        get_yesno -y $"Update configuration of local host" || quit -a -u
        wrks="$SOHO_WORKSPACE" ; dest='/'
    else
        # install to an image? Get workspace and params  ...
        [ -d "$dest/boot" -a -d "$dest/usr" ] || dest+='/Volumes/Root'
        dcfg="$dest/etc/default/$CEN_NAME"
        DAT_SOHO_PARAMS="$dcfg"
        DAT_SOHO_DEST="${dest%/}"
        DAT_SOHO_ROOT="$DAT_SOHO_DEST/var/centauri"
        if [ "${para:--}" != '-' -a "$para" != '+' ] ; then
            message -a -c $"Parameter file" "$para"
            dcfg="$para"
        elif [ ! -e "$dcfg" ] ; then
            warning -p $"This image cannot be configured (missing: %s)" "$dcfg"
            return 1
        fi
        inpdata -a list -q -r -- "$dcfg"
        txtgrep -s wrks -i list -m -y 'SOHO_WORKSPACE=*'
        wrks="${wrks#*=}" ; wrks="${wrks#[\'\"]}" ; wrks="${wrks%[\'\"]}"
        if [ -n "$wrks" ] && [ -d "$dest$wrks" ] ; then
            SOHO_WORKSPACE="$dest$wrks"
        else
            trace -a -c "wrong workspace" "$wrks"
            get_workspace -c || return 1                # use --base option
        fi
        wrks="$SOHO_WORKSPACE"
        trace -a -c "dest workspace" "$wrks"
        get_config -n "$dcfg" || return 1               # complete and validate only

        if [ "$name" = '-' ] ; then
            readline -q -s name -i "$dest/etc/hostname" && name="${name%%.*}"
            if [ -z "$name" ] ; then
                invoke -e $"Configuration needs a hostname" ; return 1
            fi
        fi
        get_yesno -y $"Update configuration of '%s'" "$name" || para='-'
        # assume hard coded path, $CEN_ROOT/default can be invalid
        DAT_SOHO_NETCFG='/etc/default/centaurinetcfg'
    fi

    # only if we have a <para> argument ...
    if [ -n "$para" ] ; then
        case "$para" in
        +)  while true ; do
                cfg_params -q "$dcfg" || return 1
                confirm -d - -v $"yes no quit" -p $" [y/n/q]? " $"Apply configuration"
                case $? in
                0)  break ;;
                1)  ;;
                *)  para='-' ; break # return 0
                esac
            done
            ;;
        -)  [ "$CEN_ACTION" = 'restore' ] && return 0
            cfg_params -r || return 1 ;;
        *)  cfg_params -r "$para" || return 1
        esac
        if [ "$para" != '-' ] ; then
            cfg_params -w "$dcfg"
            cfg_params -p "$dcfg" "$wrks"
        fi
    fi

    # update installed templates: <wrks> <host> <root>
    SOHO_DNAME="${SOHO_DOMAIN%.*}"
    templ_expand "$DAT_SOHO_NETREP" "$dest"
    templ_update "$wrks" "$name" "$dest"

    copyFromRepo '/etc/services' "$dest"                # netcfg wants centauri settings
    if [ "$dest" = '/' ] ; then
        embed -v centaurinetcfg setup "$name"
        cfg_wlan
        embed -v centauriroute init                     # switch /etc/network/interfaces
    else
        item="$PWD" ; folder -c -f -- "$dest"
        embed -v centaurinetcfg --conf="${DAT_SOHO_NETCFG:1}" --out=. setup "$name"
        cfg_wlan "$host" '--out=.'
        folder -c -f "$item"
    fi

    # if we have naming mode 'systemd' the interface configuration must be
    # updated at next boot. Usually 'centaurisysinit' would do this, but is
    # not enable yet. So we touch the config and expect 'centauriswitch' to
    # do the update at next boot ...
    system -e -p touch touch --date=@$((EPOCHSECONDS + 2)) "${dest%/}$DAT_SOHO_NETCFG"
    message "Touched to trigger re-config:" "${dest%/}$DAT_SOHO_NETCFG"
    return 0
}

# ------------------------------------------------------------------------------
# update wlan password: <host> <netgen-args>...
# ------------------------------------------------------------------------------
cfg_wlan() {
    local host="${1:$HOSTNAME}" ; shift
    local pasw="${SOHO_NET_WLAN_PW:--}"
    if [ "$pasw" = '-' ] ; then
        warning $"WLAN password set to random, use 'centaurinetgen' to fix"
    else
        trace -a "Setting wlan password"
    fi
    [ "${SOHO_NET_WLAN:--}" = '-' ] || set -- "$@" --wlan   "$SOHO_NET_WLAN:$pasw"
    [ "${SOHO_NET_APNT:--}" = '-' ] || set -- "$@" --apoint "$SOHO_NET_APNT:$pasw"
    folder -f -m "$DAT_SOHO_DEST/etc/hostapd"
    embed -v 'centaurinetgen' -f -s "$@" --host="$host" nmcon -- wpasup -- hostapd
}

# ------------------------------------------------------------------------------
# check network base address: [-w] <base>
# ------------------------------------------------------------------------------
get_address() {
    local oerr
    [ "$1" = '-w' ] && { oerr="$1" ; shift ; }
    [ "${1:--}" = '-' ] && fatal -t '+'
    CEN_NET_NETWORKS=()
    if ! netparse -a -b -- "$1" ; then
        error $oerr $"Network base has invalid syntax" ; return 1
    elif [ "$_netparse_bits" -lt 10 ] ; then
        error $oerr $"Network mask bits value must be >= 10" ; return 1
    elif [ "$_netparse_bits" -gt 22 ] ; then
        error $oerr $"Network mask bits value must be <= 22" ; return 1
    fi
    netconv -b "$_netparse_addr"
    local abin="${_netconv:--1}"                # address as binary
    netconv -b "${_netparse_mask:-0}"           # mask as binary
                                                # get allow offset bits ...
    local mask=$(( (1<<(32 - _netparse_bits)) - 1 ))
    ((mask &= ~255)) ; ((mask += _netconv))     # lower 8 bit must be 0
    if [ "$((abin & ~mask))" != 0 ] ; then
        trace -c -p 'offset mask' "%x %x %x" "$mask" "$_netconv" "$abin" #
        #error $oerr $"Network mask or network base ip address are invalid" ; return 1
        error $oerr $"Network mask too short for base address" ; return 1
    fi

    CEN_NET_NETBITS="$_netparse_bits"
    CEN_NET_NETMASK="$_netparse_mask" ; _netparse_addr="${_netparse_addr%.*}"
    CEN_NET_NETWORKS=("$1")
    netparse '<0>0.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>0.128' ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>1.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/24")
    netparse '<0>2.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/24")
    netparse '<0>3.0'   ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    netparse '<0>3.128' ; CEN_NET_NETWORKS+=("$_netparse_addr/25")
    return 0
}

# ------------------------------------------------------------------------------
# get host architecture
# ------------------------------------------------------------------------------
#   SOHO_PLATFORM   x86 (pc)    rpi (raspi)     r32 (raspi2)
# ------------------------------------------------------------------------------
get_architecture() {
    [ -n "$DAT_SOHO_ARCH" ] && return 0
    system -q -r -s DAT_SOHO_ARCH -- dpkg --print-architecture
    [ -n "$SOHO_PLATFORM" ] && return 0
    system -c raspi-config && { SOHO_PLATFORM='rpi' ; DAT_RASPI=1 ; }
    case "$SOHO_PLATFORM-$DAT_SOHO_ARCH" in
        *-)         quit -f $"Not running a debian system?" ;;
        -amd64)     SOHO_PLATFORM='x86' ;;
        rpi-arm64)  DAT_RASPI=2 ;;
        rpi-arm*)   SOHO_PLATFORM='r32' ;;
        *)          error $"Unsupported hardware architecture:" "$DAT_SOHO_ARCH"
                    return 1
    esac
    return 0
}

# ------------------------------------------------------------------------------
# get extra commands from 'setup'
# ------------------------------------------------------------------------------
get_commands() {
    [ -n "$DAT_SOHO_CMDS" ] && return 0
    [ -n "$SOHO_WORKSPACE" ] || return 1
    [ -x "$SOHO_WORKSPACE/setup" ] || return 1
    system -a DAT_SOHO_CMDS -d '\n' -n -r -- "$SOHO_WORKSPACE/setup" commands
}

# ------------------------------------------------------------------------------
# load the SOHO_xxx config params: [-n|-s] [<dcfg>]
# ------------------------------------------------------------------------------
# Options:
#       -n      used by cfg_apply (invalidate config)
#       -s      load /etc/default/centaurisoho only, no error message
#
#   (1) load /etc/default/centaurisoho
#   (2) if setup.conf is newer than /etc/default/centaurisoho then update
#   (3) if /etc/default/centaurisoho is newer then centaurinetcfg then update
# ------------------------------------------------------------------------------
get_config() {
    [ "$1" = '-n' ] && SOHO_DOMAIN=             # force read
    [ -z "$SOHO_DOMAIN" ] && cfg_params -r "$2" # just read centaurisoho
    [ "$1" = '-s' ] && return 0                 # used by get_workspace
    if [ "$1" = '-n' ] ; then                   # no 'setup'
        netconfig -u ; return 0                 # net config now invalid
    fi

    if [ -z "$SOHO_DOMAIN" ] ; then
        trace "Initializing parameter file"
    elif [ "$SOHO_WORKSPACE/setup.conf" -nt "$DAT_SOHO_PARAMS" ] ; then
        message -a $"Updating parameters from 'setup.conf'" ; SOHO_DOMAIN=
    fi
    if [ -z "$SOHO_DOMAIN" ] ; then
        get_setup -c || return 1                # re-read setup.conf
        cfg_params -w || return 1
    fi
    return 0
}

# ------------------------------------------------------------------------------
# get distributable and work folder: [<dist>:[<conf>]|-|+
# ------------------------------------------------------------------------------
get_disttar() {
    [ -z "$SOHO_WORKSPACE" ] && return 1
    prettypath -p -- "$SOHO_WORKSPACE/.." || return 1
    local bnam="$CEN_PRETTYPATH/$CEN_NAME-"
    case "${1:-+}" in
    *[/.]*) bnam="$1" ;;
    +)      bnam+="$SOHO_DISTRO-$SOHO_CONFIG" ;;
    -)      bnam+="$SOHO_DISTRO" ;;
    :*)     bnam+="$SOHO_DISTRO-${1:1}" ;;
    *)      bnam+="${1/:/-}"
    esac
    inpfile -c -l -q -s DAT_SOHO_DTAR -x 'tgz' -- "$bnam" || return 1
    trace -a -c "distributable" "$DAT_SOHO_DTAR"
    return 0
}

# ------------------------------------------------------------------------------
# expand the centaurinetcfg template, update cache, load cache data
# ------------------------------------------------------------------------------
#
#   (1) get_netcache <root>|- <args>...         # explicit base and sub-action
#   (2) get_netcache                            # update: get_netcache / cache
#
# The CEN_NET_xxxx Variables are loaded from the cache using netconfig().
# ------------------------------------------------------------------------------
get_netcache() {
    allowInstall                                    # check permission to install
    if [ $# = 0 ] ; then
        # run config if we have no cached netcfg ...
        if [ ! -s "$CEN_ROOT/persistent/centaurinetcfg" ] ; then
            message $"Creating network configuration cache"
            set -- '/' cache
        elif [ "$DAT_SOHO_PARAMS" -nt "$DAT_SOHO_NETCFG" ] &&
            confirm -a -y $"Replace the existing network configuration" ; then
            set -- '/' cache
        else
            return 0
        fi
    fi

    local dest="${1:--}" ; shift
    tmpfile -f -r || return 1
    templ_expand "$DAT_SOHO_NETREP" "$CEN_TMPFILE"
    copyFromRepo '/etc/services'                    # netcfg wants centauri settings
    embed -t centaurinetcfg validate --config="$CEN_TMPFILE" "$@" || return 1
    netconfig -e -r || return 1                     # re-read cache

    [ "$dest" = '-' ] && return 0                   # don't save cache
    joinpath -r -s dest -- "$dest" "$DAT_SOHO_NETCFG"
    move -- "$CEN_TMPFILE" "$dest" || return 1
    attributes -m - -o root:root -- "$dest"         # ignore error
    return 0
}

# ------------------------------------------------------------------------------
# get repository path: [-e|-l]
# ------------------------------------------------------------------------------
#   -e      simple error message, don't complain about missing @shared symlink
#   -l      symlink @shared (implies -e)
# ------------------------------------------------------------------------------
get_repository() {
    local conf
    # get from configuration ...
    [ -z "$DAT_REPOSITORY" -a -n "$SOHO_CONFIG" ] &&
        for conf in "$SOHO_CONFIG" "$SOHO_DNAME" ; do
            repository -q folder DAT_REPOSITORY "$SOHO_DISTRO" "$conf" - "$DAT_SOHO_ROOT" && break
        done

    # or get current repository ...
    if [ -z "$DAT_REPOSITORY" -a "$1" != '-l' ] && [ -d "$CEN_ROOT/shared" ] ; then
        resolve -f -m "$CEN_ROOT/shared/.."
        DAT_REPOSITORY="$CEN_RESOLVE"
        trace -a -c ' ' "$DAT_REPOSITORY" ; return 0
    fi

    if [ -n "$DAT_REPOSITORY" ] ; then
        [ "$1" = '-l' ] && symlink -f -n -- "$DAT_REPOSITORY/@shared" "$CEN_ROOT/shared"
        trace -a -c " $1" "$DAT_REPOSITORY" ; return 0
    elif [ "$1" != '-e' -a "$1" != '-l' ] ; then
        error -n "Missing '$CEN_ROOT/shared', please create manually by" \
                 "running: ln -s $CEN_ROOT/configs/<dist>/<conf>/@shared $CEN_ROOT/shared"
    elif [ -n "$SOHO_CONFIG" ] ; then
        error "Cannot find repository '%s' or '%s'" "$SOHO_DNAME" "$SOHO_CONFIG"
    else
        error "Cannot find repository"
    fi
    return 1
}

# ------------------------------------------------------------------------------
# load configuration and the setup plugin: [-c]
# ------------------------------------------------------------------------------
#   Options:    -c      use 'setup --config' (don't load plugin code)
# ------------------------------------------------------------------------------
get_setup() {
    local oset='source'
    [ "$1" = '-c' ] && oset='config'                # process config only

    if [ "$SOHO_SETUP" = 1 ] ; then                 # don't source twice
        :
    elif [ ! -x "$SOHO_WORKSPACE/setup" ] ; then
        invoke -e "Missing 'setup' script" ; return 1
    else
        trace -a "Sourcing 'setup' script ..."
        source "$SOHO_WORKSPACE/setup" --$oset
        if [ -z "$SOHO_SETUP" ] ; then
            invoke -e "Failed to load 'setup' script" ; return 1
        fi
        trace -a "Sourcing 'setup' succeeded"
    fi
    return 0
}

# ------------------------------------------------------------------------------
# update existing files from repository: <dest>
# ------------------------------------------------------------------------------
get_update() {
    confirm -a -f -y $"Update '%s' files from repository" "$1" || return
    local curr="$PWD" miss=0 coun=0
    folder -c -f -- "$1"

    # (1) get sub-folders of destination, cannot use CEN_WALK_DIRS

    local dest="$PWD" dirs=() item file list
    ___updates_dir() {                              # callback from walk()
        dirs+=("$2") ; return 1
    }
    walk -r -n -d ___updates_dir -f false -- .

    # (2) walk over files in sub-folders

    for item in "${dirs[@]}" ; do
        walk -r -b -l 1 -- "$item"
        list=()
        for file in "${CEN_WALK_FILES[@]}" ; do
            [ "${file%/_centauri_bash_dyn}" = "$file" ] || continue
            file="${file#.}"
            if [ -e "$file" ] ; then
                list+=("$file")
            elif [ -h "$file" ] ; then
                list+=("$file")
            else
                message -a -c $"File not in repository" "${file#$CEN_ROOT/}"
                ((miss += 1))
            fi
        done
        [ -z "$list" ] && continue
        trace -a -p "%-56s: %4s %s" "${item#./}" "${#list[*]}" $"items"
        system -f -p -- cp -a "${list[@]}" "$dest/${item#./}"
        ((coun += ${#list[@]}))
    done
    file="$dest/var/centauri/library"
    embed -i -v "$file/autoload" -B -P "$dest/var/centauri/library"
    folder -c -f "$curr"
    message -a -p $"Updated %s folders, %s items, %s not in repository" "${#dirs[@]}" "$coun" "$miss"
}

# ------------------------------------------------------------------------------
# ask for parameter value
#   (1) <vnam> -      <prom> <text>   # <vnam> set to reply
#   (2) <vnam> <dflt> -      <text>   # <vnam> set to reply/<dflt>
#   (3) <vnam> <dflt> <prom> <text>   # <vnam> set to reply/<dflt>
# ------------------------------------------------------------------------------
get_value() {
    local _curr _dflt="${2:--}" _prom="${3:--}" _text
    eval _curr=\"\$$1\"
    [ "${_curr:--}" != '-' ] && _dflt="$_curr"
    [ "$_prom" = '-' -o "${_dflt:--}" != '-' ] && _prom="$_dflt"

    printf -v _text '%s%%s[%s]' "$4" "$_prom"
    local _leng ; printf -v _leng '%56s'
    local _fill=$((${#_leng} - ${#_text}))
    [ "$_fill" -lt 1 ] && _fill=1
    printf -v _text "$_text" "${_leng::_fill}"

    while : ; do
        confirm -a -f -p - -u "$_text"
        [ -z "$CEN_CONFIRM" ] && CEN_CONFIRM="$_dflt"
        # input validation
        case "$1" in
            SOHO_NET_BASE)
                get_address "$CEN_CONFIRM" && break
                ;;
            SOHO_NET_EXTERN)
                [ "${CEN_CONFIRM:--}" = '-' ] && break
                get_address "$CEN_CONFIRM" && break
                ;;
            SOHO_NET_WLAN_PW)
                [ "${#CEN_CONFIRM}" -ge 8 ] && break
                [ "$CEN_CONFIRM" = '-' ] && break
                error $"Minimum password length is 8 chars"
                ;;
            SOHO_NET_ROUTER_IP4)
                netparse -e -a -- "$CEN_CONFIRM" && break
                ;;
            *)
                break ;;
        esac
    done
    error -c
    printf -v "$1" '%s' "$CEN_CONFIRM"
}

# ------------------------------------------------------------------------------
# get workspace folder, check seed (unless -f|-n is used): [-f|-n|-q]
# ------------------------------------------------------------------------------
# Options:      -c  get info from options or try /root/centaurisoho-*-*/seed.tgz
#               -f  do not check seed, change to working dir
#               -n  do not check seed, do not change working dir
#               -q  like -n but no error messages
#
# This function calls quit on all errors.
# ------------------------------------------------------------------------------
get_workspace() {
    if [ "$1" = '-c' ] ; then                   # used by cfg_apply
        SOHO_WORKSPACE= ; SOHO_DISTRO= ; SOHO_CONFIG=
        if [ -z "$CEN_OPT_BASE" ] && matchpath -f -o -p -- \
            "$DAT_SOHO_DEST"/root/centaurisoho-*-*/seed.tgz ; then
                SOHO_WORKSPACE="${CEN_MATCHPATH%/*}"
            message -a -c "Found workspace" "$SOHO_WORKSPACE"
        fi
        [ -n "$SOHO_WORKSPACE" ] && return 0
    elif [ -n "$SOHO_WORKSPACE" ] ; then            # previous call
        [ "$1" = '-n' -o "$1" = '-q' ] && return 0  # dont change folder
        folder -f -c -- "$SOHO_WORKSPACE" ; return 0
    else
        get_config -s                           # get existing, do not init
    fi
    local updt curr="$SOHO_WORKSPACE:$SOHO_DISTRO:$SOHO_CONFIG"

    [ -n "$CEN_OPT_BASE" ] && SOHO_WORKSPACE="$CEN_OPT_BASE"
    [ -n "$CEN_OPT_CURRENT" ] &&
        splitkeyval "$CEN_OPT_CURRENT" SOHO_DISTRO SOHO_CONFIG ':'
    if [ -z "$SOHO_WORKSPACE" ] ; then
        [ "$1" = '-q' ] && return 1
        quit -e "No known workspace, use option '--base=<fldr>'"
    elif [ ! -d "$SOHO_WORKSPACE/dists" ] ; then
        [ "$1" = '-q' ] && return 1
        quit -e "Not a valid workspace:" "$SOHO_WORKSPACE"
    elif [ -z "$SOHO_DISTRO" -o -z "$SOHO_CONFIG" ] ; then
        [ "$1" = '-q' ] && return 1
        quit -e "No configuration info, use option '--current=<dist>:<inst>'"
    fi

    # find root folder by walking up from workspace
    local root="$SOHO_WORKSPACE" dest="${DAT_SOHO_DEST:-/}"
    while [ "$root" != "$dest" ] ; do
        root="${root%/*}" ; [ -z "$root" ] && break
        [ -d "$root/usr/bin" -a -d "$root/etc/default" ] && break
    done
    [ "${root:-/}" -ef "$dest" ] ||
        quit -e -p "Workspace is not a child of '%s': %s" "$dest" "$SOHO_WORKSPACE"

    # optionally change to workspace folder and check seed
    [ "$1" = '-c' -o "$1" = '-n' -o "$1" = '-q' ] && return 0
    folder -f -c -- "$SOHO_WORKSPACE"

    # workspace changed, update parameter file
    [ "$curr" = "$SOHO_WORKSPACE:$SOHO_DISTRO:$SOHO_CONFIG" ] || updt="   update"
    trace "base=$SOHO_WORKSPACE   current=${curr#*:}$updt"
    [ -n "$updt" ] && cfg_params -w                 # update params

    # check for existing seed file
    [ "$1" = '-f' ] && return 0                     # no seed check
    matchpath -o -e -s DAT_SOHO_SEED -- "$DAT_SEED" ||
        quit -e "No known seed file, use options '--base=<fldr> --current=<dist>:<inst>'"
    trace -a -c "Seed file" "$DAT_SOHO_SEED"
    return 0
}

# ------------------------------------------------------------------------------
# confirm y/n in same format as get_value
# ------------------------------------------------------------------------------
get_yesno() {
    local text yopt="$1" ; shift
    [ $# -gt 1 ] && printf -v text "$@" || text="$1"
    confirm $yopt -f "%-48s" "$text"
}

# ------------------------------------------------------------------------------
# source the install helper: <verb> [<dist>|- [<conf>|-]]
# ------------------------------------------------------------------------------
run_installer() {
    [ -x './installer' ] || quit -e "Install helper not found:" "$PWD/installer"
    local opts=('./installer' "$@")
    DAT_SELF="$CEN_NAME"
#    dryrun -s "source ${opts[@]}" && return
    trace -a -c "Sourcing" "${opts[@]}"
    source "${opts[@]}"
}

# ------------------------------------------------------------------------------
# check for samba, warning if configured: -w|-i [<dest>]
# ------------------------------------------------------------------------------
samba_check() {
    [ -r "$2/etc/samba/smb.conf" ] || return 0
    local role warn mesg
    txtgrep -s role -i - -m -x '^[[:space:]]*server role.*=.*' <"$2/etc/samba/smb.conf"
    role="${role#*=}" ; role="${role// /}"
    case "$role" in
    memberserver*)  mesg='renserver'
                    warn="Samba domain members must re-join the domain after rename" ;;
    activedirect*)  mesg='renclient'
                    warn="AD/DC servers cannot rename domain, samba must be re-provisioned" ;;
    *)              return 0
    esac
    case "$1" in
    -w)     warning "$warn" ;;
    -i)     warn="$2/var/centauri/persistent/issue.d"
            folder -f -m "$warn" ; outputMessage "$mesg" "$warn/$mesg"
    esac
    return 0
}

# ------------------------------------------------------------------------------
# template substitution helpers
# ------------------------------------------------------------------------------
# netindex domain   0: whole IPv4 address range (all subnets)
#          iot      1: non-trusted address range for gadgets
#          trusted  2: trusted address range
#          guest    3: less-trusted address range
#          dynamic  4: addresses assigned by DHCP to unknown MAC addresses
#          repeater 5: used by repeater NAT subnet
#          vpn      6: used by VPN
#          other    7: not used by centauri, user defined
# ------------------------------------------------------------------------------
templ_subst_name() {
    case "$DAT_SOHO_SUB" in
    A)  DAT_SOHO_SUB="$SOHO_NET_APNT" ;;
    B)  DAT_SOHO_SUB="$SOHO_NET_BASE" ;;
    #C
    D)  DAT_SOHO_SUB="$SOHO_DOMAIN" ;;
    E)  DAT_SOHO_SUB="${SOHO_NET_EXTERN:--}" ;;
    #F
    G)  DAT_SOHO_SUB="$SOHO_GENAME" ;;
    H)  DAT_SOHO_SUB="${SOHO_HOST:-$HOSTNAME}" ;;
    I)  DAT_SOHO_SUB="$SOHO_NET_PUBLIC" ;;
    #JKL
    M)  DAT_SOHO_SUB="$SOHO_SONAME" ;;
    #N
    O)  DAT_SOHO_SUB="${CEN_NET_CONFIG:-$SOHO_CONFIG}" ;;
    P)  DAT_SOHO_SUB="$SOHO_SERVER" ;;
    #Q
    R)  DAT_SOHO_SUB="${SOHO_ROUTERS%%[[:space:]]*}" ;;
    S)  DAT_SOHO_SUB="$SOHO_SECOND" ;;
    T)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[1]:--}" ;;             # iot
    U)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[2]:--}" ;;             # trusted
    V)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[6]:--}" ;;             # vpn
    W)  DAT_SOHO_SUB="$SOHO_NET_WLAN" ;;
    X)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[5]:--}" ;;             # repeater
    Y)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[4]:--}" ;;             # dynamic
    Z)  DAT_SOHO_SUB="$SOHO_DISTRO" ;;
    *)  templ_warning ;;
    esac
}

templ_subst_ipv4() {
    case "$DAT_SOHO_SUB" in
    B)  DAT_SOHO_SUB="$CEN_NET_NETWORKS" ;;
    D)  case "$1" in
        0)  DAT_SOHO_SUB="${SOHO_DOMAIN#*.}" ;;         # top level
        1)  DAT_SOHO_SUB="${SOHO_DOMAIN%%.*}" ;;        # short domain
        *)  templ_warning
        esac ; return ;;
    E)  DAT_SOHO_SUB="$SOHO_NET_EXTERN" ;;
    G)  nethost -- "$CEN_NET_SERVER_GEN" ; DAT_SOHO_SUB="$_nethost_ip" ;;
    H)  DAT_SOHO_SUB="$CEN_NET_ADDR_IPLIST" ;;
    P)  nethost -- "${CEN_NET_SERVERS[0]}" ; DAT_SOHO_SUB="$_nethost_ip" ;;
    R)  DAT_SOHO_SUB="$SOHO_NET_ROUTER_IP4" ;;
    S)  nethost -- "${CEN_NET_SERVERS[1]}" ; DAT_SOHO_SUB="$_nethost_ip" ;;
    T)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[1]}" ;;                # iot
    U)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[2]}" ;;                # trusted
    V)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[6]}" ;;                # vpn
    X)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[5]}" ;;                # repeater
    Y)  DAT_SOHO_SUB="${CEN_NET_NETWORKS[4]}" ;;                # dynamic
    *)  templ_warning ; return ;;
    esac

    case "$1" in
    9)  netconv -u "${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${_netconv%[0-9]}"
        DAT_SOHO_SUB="${DAT_SOHO_SUB%[0-9]}" ;;
    8)  netconv -u "${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${_netconv%:*}:" ;;
    7)  DAT_SOHO_SUB="$CEN_NET_NETMASK" ;;
    6)  netconv -u "$DAT_SOHO_SUB" ; DAT_SOHO_SUB="$_netconv" ;;
    5)  netconv -u "${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="$_netconv" ;;
    4)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ;;
    3)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*}" ;;
    2)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*.*}" ;;
    1)  DAT_SOHO_SUB="${DAT_SOHO_SUB%/*}" ; DAT_SOHO_SUB="${DAT_SOHO_SUB%.*.*.*}" ;;
    0)  DAT_SOHO_SUB="${DAT_SOHO_SUB##*/}" ;;
    *)  templ_warning ;;
    esac
}

# ------------------------------------------------------------------------------
# template substitutions (to stdout): <text>
# ------------------------------------------------------------------------------
templ_subst() {
    local text="$1"

    # Have any %... string? If not just print (regexp are slow)
    local lead="${text%%%*}"
    [ "$lead" = "$text" ] && { printf '%s\n' "$text" ; return ; }
    local subs="${text:${#lead}}" tail xkey xsuf xcas xres

    # loop over %...% fragments
    while [[ "${subs}" =~ (.*)%([A-Z])([0-9])?(\^\^|\^)?%(.*) ]] ; do
        subs="${BASH_REMATCH[1]}"       # not yet parsed
        xkey="${BASH_REMATCH[2]}"       # key
        xsuf="${BASH_REMATCH[3]}"       # numeric suffix
        xcas="${BASH_REMATCH[4]}"       # case suffix
        tail="${BASH_REMATCH[5]}$tail"  # already parsed
        DAT_SOHO_SUB="$xkey"            # substitute this now ...
        case "$xsuf-$xcas" in
        -)     templ_subst_name ; tail="${DAT_SOHO_SUB}$tail" ;;
        -^)    templ_subst_name ; tail="${DAT_SOHO_SUB^}$tail" ;;
        -^^)   templ_subst_name ; tail="${DAT_SOHO_SUB^^}$tail" ;;
        ?-^)   templ_subst_ipv4 "$xsuf" ; tail="${DAT_SOHO_SUB^}$tail" ;;
        ?-^^)  templ_subst_ipv4 "$xsuf" ; tail="${DAT_SOHO_SUB^^}$tail" ;;
        *)     templ_subst_ipv4 "$xsuf" ; tail="${DAT_SOHO_SUB}$tail" ;;
        esac
    done
    printf '%s\n' "$lead$subs$tail"
    return 0
}

# ------------------------------------------------------------------------------
# template substitution warning
# ------------------------------------------------------------------------------
templ_warning() {
    trimjoin -- "$text"
    DAT_SOHO_SUB='[ERROR]'
    warning -m "Invalid template substitution: ""%$xkey$xsuf%" \
               "Line: ""$CEN_TRIMJOIN" "File: ""${tmpl##*templates/}"
}

# ------------------------------------------------------------------------------
# update installed templates: <wrks> [<host> [<root>]]
# ------------------------------------------------------------------------------
#   This function updates all installed templates except centaurinetcfg
# ------------------------------------------------------------------------------
templ_update() {
    local dkey item priv tmpl="$1/templates" host="${2:--$HOSTNAME}" root="$3"
    if [ ! -d "$tmpl" ] ; then
        invoke -e $"Cannot locate the 'templates' folder" ; return 1
    fi

    # find templates for all|debian|raspberry ...
    get_architecture
    [ -n "$DAT_RASPI" ] && dkey='[ar]_' || dkey='[ad]_'
    for item in "$tmpl/@shared/"$dkey*.TEMPLATE ; do
        # skip centaurinetcfg ...
        [ "$item" = "$tmpl/$DAT_SOHO_NETREP.TEMPLATE" ] && continue
        priv="${item/@shared/$host}"
        [ -e "$priv" ] && item="$priv"
        templ_expand -x "$item" "$root"
    done
}

# ------------------------------------------------------------------------------
# expand a single template: [-x] <path> [<dest>]
# ------------------------------------------------------------------------------
templ_expand() {
    local fexi
    [ "$1" = '-x' ] && { fexi=1 ; shift ; }
    [ "$2" = '-' ] || allowInstall              # check permission to install
    get_config || return 1                      # get SOHO_xxx vars and netcfg
    while [ "$1" = '-' ] ; do
        CEN_HISTORY='+' confirm -p - -u "Template expression" || return
        templ_subst "$CEN_CONFIRM"
    done

    local dest tmpl="${1%.TEMPLATE}.TEMPLATE"
    if [ -f "$tmpl" ] ; then
        :
    elif [ -f "$SOHO_WORKSPACE/templates/$tmpl" ] ; then
        tmpl="$SOHO_WORKSPACE/templates/$tmpl"
    elif [ -f "$SOHO_WORKSPACE/templates/${SOHO_HOST:-$HOSTNAME}/$tmpl" ] ; then
        tmpl="$SOHO_WORKSPACE/templates/${SOHO_HOST:-$HOSTNAME}/$tmpl"
    elif [ -f "$SOHO_WORKSPACE/templates/@shared/$tmpl" ] ; then
        tmpl="$SOHO_WORKSPACE/templates/@shared/$tmpl"
    elif [ "$CEN_ACTION" = 'template' ] ; then
        error "Not a template: $tmpl" ; return 1
    else
        trace -a -c "Not a template" "$tmpl" ; return 1
    fi

    if [ "$2" = '-' ] ; then                    # to stdout
        trace -a -c "expand template" "$tmpl -> (stdout)"
        inpdata -r -c templ_subst -- "$tmpl" ; return
    elif [ -d "${2:-/}" ] ; then                # into a folder
        repository -u esc dest "${tmpl%.TEMPLATE}"
        dest="${dest//%D%/$SOHO_DNAME}"         # allow domain substitution
        outfile -a -q -- "$2$dest" || return 1
    else                                        # destination is a file
        outfile -a -- "$2" || return
    fi

    if [ -n "$fexi" ] && [ ! -f "$CEN_OUTFILE" ] ; then
        trace -a -c "skip template" "$tmpl -> $CEN_OUTFILE"
        return 0
    fi
    dryrun -s "template $tmpl -> $CEN_OUTFILE" && return
    trace -a -c "expand template" "$tmpl -> $CEN_OUTFILE"
    inpdata -c templ_subst -- "$tmpl" >"$CEN_OUTFILE"
    [ -x "$tmpl" ] && attributes -m 775 -- "$CEN_OUTFILE"
    return 0
}

# ------------------------------------------------------------------------------
# install a file from repository                        CALLED FROM SETUP SCRIPT
# ------------------------------------------------------------------------------
#       (1) copyFromRepo -r                             # symlink repository
#       (2) copyFromRepo -c <host>                      # check host
#       (3) copyFromRepo [-u] <path> [<dest> [<dflt>]]  # extract file
#       (4) copyFromRepo -l [-u] <path> <link>          # also make a symlink
#
#   Uses <dflt> when file is not found in repo
#       ''      (no default) error message
#       -       return 1
#       <file>  copy this file file
# ------------------------------------------------------------------------------
copyFromRepo() {
    allowInstall                                        # check permission to install
    local fupd link
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --) shift ; break ;;
      -c) get_repository || return 1                    # get repo path
          [ -d "$DAT_REPOSITORY/$2" ] && return 0
          confirm -n -f "Host '%s' not found in repository. Continue anyhow" "$2" && return 0
          quit -a -u ;;
      -l) link=' -l' ;;                                 # make symlink
      -r) get_repository -l ; return ;;                 # return status
      -u) fupd=' -u' ;;                                 # update
       *) _cen_abort - "$1"
      esac ; shift
    done
    get_repository || return 1                          # get repo path
    trace -a -c -- "$link$fupd" "$@"

    local dest="${2:--}" dflt="$3" name                 # destination path
    if [ -n "$link" ] ; then
        link="$dest" ; dest="$1";
    elif [ "$dest" = '-' ] ; then
        dest="$1"
    fi
    repository -d escape name "$1"                      # transform to repo name
    local ndom="${name//$SOHO_DNAME/%D%}"               # allow domain substitution
    local ndou="${name//$SOHO_DNAME/%D^%}"              # ... uppercase 1st letter
    local glst=() repo="$DAT_REPOSITORY"
    local host="${SOHO_HOST:-$HOSTNAME}"
    if [ -n "$DAT_RASPI" ] ; then                       # raspiberry pi ...
        glst+=("$repo/$host/r$name"   "templates/$host/r$name.TEMPLATE"
                                      "templates/$host/r$ndom.TEMPLATE"
                                      "templates/$host/r$ndou.TEMPLATE"
               "$repo/@shared/r$name" "templates/@shared/r$name.TEMPLATE"
                                      "templates/@shared/r$ndom.TEMPLATE"
                                      "templates/@shared/r$ndou.TEMPLATE"
               "$repo/$SOHO_SERVER/r$name")
    fi
                                                        # all and debian family
    glst+=("$repo/$host"/[ad]$name   "templates/$host"/[ad]$name.TEMPLATE
                                     "templates/$host"/[ad]$ndom.TEMPLATE
                                     "templates/$host"/[ad]$ndou.TEMPLATE
           "$repo/@shared"/[ad]$name "templates/@shared"/[ad]$name.TEMPLATE
                                     "templates/@shared"/[ad]$ndom.TEMPLATE
                                     "templates/@shared"/[ad]$ndou.TEMPLATE
           "$repo/$SOHO_SERVER"/[ad]$name)
                                                        # get 1st existing file
    if ! matchpath -o -e -s repo -- "${glst[@]}" ; then
        case "$dflt" in
        '') error "File not in repository:" "$1" ; return 1 ;;
        -)  return 1 ;;
        *)  copyFromRepo "$dflt" "$dest" ; return       # return status
        esac
    fi
                                                        # destination, create folder
    case "$dest" in
    */)     dest+="${1:1}" ;;
    ..)     dest="../$1" ;;
    .)      dest="./$1" ;;
    esac
    folder -m -- "${dest%/*}" || return 1

    if [ "${repo%.TEMPLATE}" = "$repo" ] ; then
        copy -a $fupd -s -- "$repo" "$dest" || return 1
    else
        templ_expand "$repo" "$dest" || return 1
    fi
    [ "${link:--}" != '-' ] && symlink -n -- "$dest" "$link"
    return 0
}

# ------------------------------------------------------------------------------
# Print text from message file                          CALLED FROM SETUP SCRIPT
# ------------------------------------------------------------------------------
outputMessage() {
    local text=() pref="$3" subs="$4"
    ___message() {
        if [ -n "$1" ] ; then
            [ "${1::1}" = '#' ] && return
            text+=("$pref${1/\%1\%/$subs}")
        else
            text+=('')
        fi
        return 0
    }
    ___mesgsec() {
        [ "${1::1}" = '[' ] || return 0
        printf -v subs '%s%-14s %3s' "$pref" "$1" "${CEN_CONFIGFILE[2]}"
        text+=("$subs") ; return 0
    }

    if [ "${1:--}" = '-' ] ; then
        configfile -m -l ___mesgsec -n "$SOHO_WORKSPACE/dists/$SOHO_DISTRO/@misc/messages" '*'
    else
        configfile -l ___message -n "$SOHO_WORKSPACE/dists/$SOHO_DISTRO/@misc/messages" -- "$1"
    fi
    create -t -v text -- "${2:--}"
}

# ------------------------------------------------------------------------------
# wait for network connectivity                         CALLED FROM SETUP SCRIPT
# ------------------------------------------------------------------------------
waitForNetwork() {
    netconfig                                       # may fail, don't care
    progress -l $"Wait for network becoming online"
    local atry addr totl ftrp serv="$CEN_NET_SERVERS"
    [ "$HOSTNAME" = "$serv" ] && serv=              # don't wait for myself

    ___waitTrap() { ftrp=1 ; }                      # catch interrupt
    context -t ___waitTrap

    for atry in . - - ; do
        [ "$atry" = '-' ] && timer -w 1
        for addr in eth0 eth1 wlan0 wlan1 ; do
            netiface -k "$addr" || continue
            nettool -q -d "$_netiface" isup || continue
            atry= ; break
        done
    done
    [ "$atry" = '-' ] && warning $"Perhaps no network interface is available"
    timer -i -
    while : ; do
        for addr in $serv 8.8.8.8 debian.org - ; do
            [ "$addr" = '-' -o  -n "$ftrp" ] && break
            sysrun -q -- ping -c1 -W2 "$addr" && break
        done
        if [ "$addr" = '-' -a -z "$ftrp" ] ; then
            timer -s totl -p -
            progress -a -p $"Waiting for network since %s [s]" "$((totl / 1000))"
            timer -w 2
            continue
        fi
        if [ -z "$ftrp" ] && [ -s '/etc/apt/apt.conf' ] ; then
            addr=
            txtgrep -i - -m -s addr -y 'Acquire::http::Proxy*' </etc/apt/apt.conf
            if [ -n "$addr" ] ; then
                addr="${addr#*\"}" ; addr="${addr#http://}" ; addr="${addr%\"*}"
                progress -l $"Check if apt proxy can be reached (use ^C to stop)"
                if ! echo 2>/dev/null >"/dev/tcp/${addr/:/\/}" ; then
                    error $"Cannot connect to apt proxy:" "$addr"
                    return 2
                fi
            fi
        fi
        context -t '-'
        if [ -n "$ftrp" ] ; then
            confirm -n $"Network check interrupted, continue anyhow" || quit -a -u
            ftrp=
        else
            message $"Network is online"
        fi
        return 0
    done
}

# ------------------------------------------------------------------------------
# Backup as disk tar: <host> <boot>|-|+ [<root>|-|+ [<arch>|- [<algo>]]]
# ------------------------------------------------------------------------------
actionBackup() {
    get_workspace -n || return
    local base curr="$PWD" item file auto mptb mptr bdir
    local host="${1:--}" ; [ "$host" = '-' ] && host="$HOSTNAME"
    local aboo="${2:--}" aroo="${3:--}"
    local arch="${4:--}" algo="${5:-xz}"
    [ "$aboo" = '+' ] && aboo="${host}_boot"
    [ "$aroo" = '-' ] && aroo="${host}_root"
    if [ "$aroo" = '+' ] ; then
        aroo="${host}_vol0"
        [ ! -b "/dev/disk/by-label/$aroo" ] &&
            [ -b "/dev/disk/by-label/${host}_root" ] && aroo="${host}_root"
    fi

    # boot root volumes     # btrfs
    # boot root             # ext4 (raspi)
    #      root             # ext4 (debian bootstrap)

    if [ "${2:--}" = '-' ] ; then
        invoke -w "Backup of 'root' only"
    elif [ -d "$aboo" ] ; then
        prettypath -s mptb -- "$aboo"
    else
        automount -o progress -- "$aboo" || return
        mptb="$CEN_MOUNT_DIR" ; auto=1
    fi

    if [ -d "$aroo" ] ; then
        prettypath -s mptr -- "$aroo"
    else
        automount -b -o progress -- "$aroo" || return
        mptr="$CEN_MOUNT_DIR" ; auto=1
    fi

    if [ "$mptr" -ef '/mnt/vol0/Volumes/Root' ] ; then
        mptr='/mnt/vol0'
        warning "Backup of a running system may result in garbage"
    elif [ -d "$mptr/mnt/vol0" -a ! -d "$mptr/Volumes/Root" ] ; then
        confirm -n "Mount option 'subvol=/' might be missing. Continue" || quit -a -u
    fi

    for item in 'boot' 'root' 'usr' 'home' 'export' 'shared' ; do
        printf -v file "%s_%s_%(%Y-%m-%d)T.tar.$algo" "$host" "$item" -1
        system -q sync
        error -t || return
        if [ -s "$curr/$file" ] ; then
            trace -a -c "Skip existing" "$file"
        elif [ "$item" = 'boot' ] ; then
            [ -z "$mptb" ] && continue              # root includes boot
            folder -c -f "$mptb"
            embed -t centauribackup -A0 -H "$host" -B "$mptb" \
                                    -S "$curr" -P "$algo" -T "$item" archive .

        elif [ -d "$mptr/Volumes/Root" ] ; then     # btrfs volumes ...
            if [ "$item" = 'root' ] ; then
                embed -t centauribackup -A0 -H "$host" -B "$mptr/Volumes/Root" \
                                        -S "${curr/_root_/_vol0_}" -P "$algo" 'root'
            elif [ "$item" = 'usr' -o  "$item" = 'home' ] ; then
                embed -t centauribackup -A0 -O "$curr/$file" \
                                        -B "$mptr/Volumes/Root" "$item"
            elif [ -d "$mptr/Volumes/${item^}" ] ; then
                embed -t centauribackup -A0 -O "$curr/$file" \
                                        -B "$mptr/Volumes/${item^}" archive .
            fi

        elif [ "$item" = 'root' -o "$item" = 'usr' -o  "$item" = 'home' ] ; then
            embed -t centauribackup -A0 -O "$curr/$file" -B "$mptr" run "$item"
        elif [ -d "$mptr/$item" ] ; then            # ext4 folders ...
            embed -t centauribackup -A0 -O "$curr/$file" -B "$mptr/$item" archive .

        else
            trace -a -c "No data dir" "$mptr $item"
        fi
    done

    folder -c -f "$curr"
    if error -t ; then
        # check essential files ...
        local list=('root' 'usr' 'home')
        [ -n "$mptb" ] && list+=('boot')
        for item in "${list[@]}"  ; do
            printf -v file "%s_%s_%(%Y-%m-%d)T.tar.$algo" "$host" "$item" -1
            [ -s "$file" ] && continue
            dryrun || error -a "Backup file missing for:" "$item"
        done
    fi

    if error -t ; then
        if [ "$arch" = '-' ] ; then
            bdir="$mptr/Volumes/Root"
            [ -d "$bdir" ] || bdir="$mptr"
            [ -d "$bdir/boot/firmware" ] && arch='rpi' || arch='x86'
        fi
        message -p "Backups are complete, creating dist tar (%s)" "$arch"

        printf -v item "%s_*_%(%Y-%m-%d)T.tar.$algo" "$host" -1
        printf -v file "%s_disk-%s_%(%Y-%m-%d)T.tar" "$host" "$arch" -1
        local vols volf
        if [ -e "$mptr/Volumes/Root" ] ; then
            volf="${host}_volumes"
            folder -c -f "$mptr/Volumes"
            matchpath -d -s vols -- *
            folder -c -f "$curr"
            create -t -v vols -- "$volf"
        else
            remove "$volf"
        fi

        # copy imagetool and create imagetool.xy
        local tool="$SOHO_WORKSPACE/dists/@tools"
        if [ -s "$tool/imagetool" ] ; then
            embed -z -v -i -- "$tool/imagetool" archive "$PWD"
            system -e -p -- cp -a -u -- "$tool/imagetool"* "$tool/grub.minimal" .
        else
            warning "Missing file:" "$tool/imagetool"
        fi

        # volf, item can be void and must not be quoted
        if system -t -e -p -- tar -cf "$file" imagetool* grub.minimal $volf $item ; then
            confirm -a -y "Dist tar created, remove constituent tars" &&
                remove -- $volf $item imagetool* grub.minimal
        fi
    fi

    [ -n "$auto" ] && automount -o progress -q
}

# ------------------------------------------------------------------------------
# update config: <para>                               # configuration from file
#                query    <dest>|- <name>|- <para>|-  # configuration query menu
#                show                                 # show config parameters
#                update                               # update installed templates
# ------------------------------------------------------------------------------
actionConfig() {
    allowInstall                                        # check permission to install
    local orig="$PWD" ccmd="${1:-show}" ; shift
    if [ $# -lt 2 ] ; then
        get_workspace -f || return                      # change dir to base folder
    elif [ "${ccmd::3}" = 'que' ] ; then
        get_workspace -n
    else
        invoke -e "Only 'query' can have a arguments" ; return
    fi

    get_config                                          # initialize config
    case "$ccmd" in
    que*)       cfg_apply "$1" "$2" "${3:-+}" ;;
    sho|show)   cfg_params -w '-' ;;
    upd*)       cfg_apply - - - ;;
    *)          if [ -f "$ccmd" ] ; then
                    cfg_apply - - "$ccmd"
                elif [ -f "$orig/$ccmd" ] ; then
                    cfg_apply - - "$orig/$ccmd"
                else
                    invoke -a 'query|show|update|<file>'
                fi
    esac
}

# ------------------------------------------------------------------------------
# Create distribution tar from workspace: [[<dist>] <conf>]
# ------------------------------------------------------------------------------
actionDistr() {
    get_workspace -f || return
    local dist="$SOHO_DISTRO" conf="$SOHO_CONFIG" seed
    case "$1:$2" in
    :)      ;;
    -:)     conf= ;;
    -:-)    ;;
    *:)     dist="$1" ; conf= ;;
    *:-)    dist="$1" ;;
    -:*)    conf="$2" ;;
    *)      dist="$1" ; conf="$2"
    esac

    if [ ! -d "dists/$dist" ] ; then
        invoke -e $"Not a valid distribution:" "$dist" ; return
    elif [ "${conf:--}" = '-' ] ; then
        seed="$dist"
    elif [ ! -d "dists/$dist/configs/$conf" ] ; then
        if [ -s "dists/$dist/@seed/seed-$dist.tgz" ] ; then
            error $"Must unpack distribution tar, see:" "$CEN_NAME unpack"
        else
            invoke -e $"Not a valid configuration:" "$conf"
        fi
        return
    else
        seed="$dist-$conf"
    fi

    message $"Packing workspace:" "$seed"

    if [ -d "dists/$dist/dynamic" -a -d "dists/$dist/static" ] ; then
        get_update "dists/$dist/dynamic"
        if [ -z "$conf" ] ; then
            run_installer 'pack' "$dist"
        else
            run_installer 'pack' "$dist" "$conf"
        fi
    elif [ -s "dists/$dist/@seed/seed-$seed.tgz" ] ; then
        invoke -w $"Missing dynamic|static but seed tar exists"
    else
        invoke -e $"Missing dynamic|static and missing seed tar" ; return
    fi

    if [ -z "$conf" ] ; then
        run_installer 'dist' "$dist"
    else
        run_installer 'dist' "$dist" "$conf"
    fi
}

# ------------------------------------------------------------------------------
# Run docviewer
# ------------------------------------------------------------------------------
actionDocview() {
    get_workspace -q                                    # try to get base folder
    local docv="$SOHO_WORKSPACE/README/docviewer.dynamic"
    if [ ! -x "$docv" ] ; then                          # try via repository
        get_repository -e || return
        docv="$DAT_REPOSITORY/../@soho/docviewer"
    fi
    embed -x -v -- "$docv" "$@"
}

# ------------------------------------------------------------------------------
# Unpack distributable and seed: [<dist> [<work>]]
#
#   <path>.tgz
#   centaurisoho-master.tgz
#   centaurisoho-<dist>.tgz
#   centaurisoho-<dist>-<conf>.tgz
# ------------------------------------------------------------------------------
actionExpand() {
    get_workspace -q                                    # try to get base folder
    local work curr
    get_disttar "$1" || return
    work="${DAT_SOHO_DTAR##*/}" ; work="${work%.*}"     # filename only
    curr="${work#*-}"
    case "$work" in
    *-*-*)  work="${work%-*}"
            SOHO_DISTRO="${curr%-*}" ; SOHO_CONFIG="${curr#*-}"
            ;;
    *-*)    SOHO_DISTRO="$curr" ; SOHO_CONFIG='-'
            ;;
    *)      if [ -n "$CEN_OPT_CURRENT" ] ; then
                splitkeyval  "$CEN_OPT_CURRENT" SOHO_DISTRO SOHO_CONFIG ':'
            else
                error "Cannot parse file name, use --current=<dist>:<conf>"
                return
            fi
    esac

    [ -n "$CEN_OPT_BASE" ] && work=$CEN_OPT_BASE
    trace -a -c "Expanding"  "$work  $SOHO_DISTRO:$SOHO_CONFIG"

    if [ -z "$CEN_OPT_FORCE" ] && [ -e "$work" ] ; then
        error "Workspace already exists (try '--force'):" "$work" ; return
    fi
    confirm -y "Unpack '${DAT_SOHO_DTAR##*/}' to '$work'" || return
    dryrun -s "Create: $work" || folder -f -m -c "$work"
    dryrun "Unpack $DAT_SOHO_DTAR" || {
        system -e -p -- tar -xaf "$DAT_SOHO_DTAR" --strip-components=1 || return
        [ ! -s "$DAT_SEED" ] && fatal "No '$DAT_SEED' in '$DAT_SOHO_DTAR'"
    }
    dryrun "Unpack $PWD" || {
        SOHO_WORKSPACE="$PWD"
        actionUnpack
    }
}

# ------------------------------------------------------------------------------
# Get workspace info: [<dist>]
# ------------------------------------------------------------------------------
actionInfo() {
    get_workspace -q                                    # try to get base folder
    get_architecture
    message -a -c "HW architecture" "${SOHO_PLATFORM:-<unknown>} ($DAT_SOHO_ARCH)"
    message -a -c "Configuration"   "${CEN_CONFIGFILE:-<unknown>}"

    local work="$SOHO_WORKSPACE" seed="$DAT_SEED"
    [ -e "$work" ] || work="<missing>"
    message -a -c "Workspace" "$work"
    [ -e "$work" ] || return

    get_disttar "$1"
    local dist="$DAT_SOHO_DTAR" curr="$SOHO_DISTRO:$SOHO_CONFIG"
    [ -e "$dist" ] || dist="<missing>"
    [ "$curr" = ':' ] && curr="<missing>"
    if [ -f "$SOHO_WORKSPACE/$seed" ] ; then
        resolve -l -s seed -- "$SOHO_WORKSPACE/$seed"
    else
        seed="<missing>"
    fi
    message -a -c "Distributable" "$dist"
    message -a -c "Seed tar" "$seed"
    message -a -c "current" "$curr"

    local sarr item mesg="Completed"
    matchpath -a sarr -e -- "$SOHO_WORKSPACE/.state/"*-done
    for item in "${sarr[@]}" ; do
        item="${item##*/}"
        message -a -c "$mesg" "${item%-done}"
        mesg='...'
    done
}

# ------------------------------------------------------------------------------
# Run the installer tool
# ------------------------------------------------------------------------------
actionInstall() {
    get_workspace -f || return                      # change dir to base folder
    run_installer "$@"
}

# ------------------------------------------------------------------------------
# Message text: <mesg> [<file>|- [<pref>]]
# ------------------------------------------------------------------------------
actionMessage() {
    get_workspace -n || return                      # get base folder
    outputMessage "$@"
}

# ------------------------------------------------------------------------------
# network configuration: [cache|show|update|wait]
# ------------------------------------------------------------------------------
#   This function expands the centaurinetcfg template into a temp file and:
#
#       cache   - creates/udpdates the configuration cache
#       show    - shows the network Configuration
#       update  - creates/updates cache, copy temp file to centaurinetcfg
#       wait    - waits for a network connection to become ready
# ------------------------------------------------------------------------------
actionNetwork() {
    get_workspace -f || return                      # change dir to base folder
    case "${1:-show}" in
    cac*)   get_netcache - cache ;;
    sho*)   get_netcache - --pager=yes list ;;
    upd*)   get_netcache '/' cache ;;
    wai*)   waitForNetwork ;;
    *)      invoke -e "Argument must be one of: cache update show wait"
    esac
}

# ------------------------------------------------------------------------------
# Save or restore file ownerships: save|restore
# ------------------------------------------------------------------------------
actionOwners() {
    get_workspace -f || return                      # change dir to base folder
    local osav item file
    case "$1" in
    sav|save)   osav=1 ;;
    res*)       ;;
    *)          invoke -e "Argument must be one of:" 'save restore' ; return
    esac

    for item in 'dists'/[!@]* ; do
        [ -d "$item" ] || continue
        if ! [ -d "$item/dynamic" -a -d "$item/static" ] ; then
            invoke -e "Missing dynamic|static (run unpack):" "$dist" ; continue
        fi
        file="$item/OWNERS"
        if [ -n "$osav" ] ; then
            embed centauriowner --base="$item" --all --yes save "$file" || break
        elif [ -s "$file" ] ; then
            system -e -p -- chown -R 'root:root' "$item" || break
            embed centauriowner --base="$item" --all restore "$file" || break
        else
            invoke -e "Missing OWNERS file:" "$file" ; continue
        fi
    done
}

# ------------------------------------------------------------------------------
# Create seed tars and remove static and dynamic folders
# ------------------------------------------------------------------------------
actionPack() {
    get_workspace -f || return                      # change dir to base folder

    confirm -n "Create distribution tars and delete the tar sources" || quit -a -u

    local ysav="$CEN_YESNO" ; CEN_YESNO='y'
    local dirs=() dist item seed fldr noex
    for item in 'dists'/[!@]* ; do
        [ -d "$item" ] || continue
        dist="${item##*/}"

        if [ -d "$item/dynamic" -a -d "$item/static" ] ; then
            get_update "$item/dynamic"
            run_installer 'pack' "$dist"
        elif [ -s "$item/@seed/seed-$dist.tgz" ] ; then
            trace "Missing dynamic|static but seed tar exists:" "$dist"
        else
            invoke -e "Missing dynamic|static and missing seed tar:" "$dist"
            continue
        fi
        if [ -s "$item/@seed/seed-$dist.tgz" ] ; then
            for fldr in "$item/static" "$item/dynamic" "$item/configs" ; do
                [ -d "$fldr" ] && dirs+=("$fldr")
            done
        else
            invoke -e "Got no valid seed tar:" "$dist"
        fi
    done
    CEN_YESNO="$ysav"
    error -t || return
    if [ -n "$dirs" ] ; then
        confirm -y -f "Remove %s static|dynamic|configs folders" "${#dirs[@]}" &&
            remove -d -- "${dirs[@]}" 'static' 'dynamic'
    fi
    remove 'dists'/*/@seed/seed-*-*.tgz
    matchpath -a noex -n -- * ; remove -- "${noex[@]}"
}

# ------------------------------------------------------------------------------
# rename a system (no workspace needed): <cnam> <nnam>
# ------------------------------------------------------------------------------
actionRename() {
    local curr="$HOSTNAME" name="${2,,}" dorg dnew
    [ $# -gt 1 ] && curr="${1,,}" || name="${1,,}"
    [ "$curr" = "$name" ] && { invoke -e "Same hostname specified:" "$name" ; return ; }
    matchpath -o -e -s dnew -- "/dev/disk/by-label/${name}_"* \
                          && { invoke -e "New hostname is already in use:" "$name" ; return ; }
    matchpath -o -e -s dcur -- "/dev/disk/by-label/${curr}_"* \
                          || { invoke -e "Current hostname not valid:" "$curr" ; return ; }
    local item indx=0 parr=() args=() disk lblr
    for item in 'boot' 'swap' 'vol0' 'root' ; do
        findmount -d -l "${curr}_$item" && parr[indx]="$CEN_MOUNT_DEV"
        ((indx += 1))
    done

    if [ -z "${parr[2]}" ] ; then           # root partition: root or vol0
        parr[2]="${parr[3]}" ; lblr="${name}_root"
    else
        lblr="${name}_vol0"
    fi
    case "${parr[2]}" in
    *nvme*) disk="${parr[2]%p?}" ;;
    *mmcb*) disk="${parr[2]%p?}" ;;
    *)      disk="${parr[2]%[0-9]}" ;;
    esac
    [ -n "${parr[0]}" ] && args+=(label "${parr[0]##*[a-z]}" "${name}_boot" --)

    [ -z "${parr[0]}" ] && invoke -w "Found no boot/EFI partition"
    [ -z "${parr[1]}" ] && invoke -w "Found no swap partition"
    [ -z "${parr[2]}" ] && { invoke -e "Found no root partition" ; return ; }

    system -c udisksctl || quit -e "Please install the 'udisks2' package"

    samba_check "${parr[2]}"
    [ -n "${parr[1]}" ] && args+=(label "${parr[1]##*[a-z]}" "${name}_swap" --)
    args+=(label "${parr[2]##*[a-z]}" "$lblr")

    local dirb dirr
    findmount /
    if [ "$CEN_MOUNT_DEV" = "${parr[2]}" ] ; then
        get_workspace -q && outputMessage 'inplace' - "${CEN_NAME//?/ }  "
    else
        trace -a -c "mounting" "$disk ($lblr)"
        if [ -n "${parr[0]}" ] ; then
            automount -o progress -- "${parr[0]}" || quit -e ; dirb="$CEN_MOUNT_DIR"
        fi
        automount -o progress -b -- "${parr[2]}" || quit -e ; dirr="$CEN_MOUNT_DIR"
    fi

    ___rename_x86() {
        local args=()
        [ -n "$1" ] && args+=('-B' "$1")
        [ -n "$2" ] && args+=('-R' "$2")
        confirm -q -y "Update '/etc/fstab' and 'grub.cfg'" &&
            embed -i -v -z centaurirestore -y "${args[@]}" -C "$name" -C + -C + -C +
        [ -n "$1" ] && error -t && confirm -y "Update systemd boot and splash" &&
            embed -i -v -z centauriefilinux -y "${args[@]}" create
    }
    ___rename_rpi() {
        local args=() ntxt=0
        [ -n "$2" ] && args+=('-R' "$2")
        confirm -y "Update '/etc/fstab'" &&
            embed -i -v -z centaurirestore -y "${args[@]}" -C "$name" -C + -C + -C -
        [ -z "$2" ] && [ ! -d '/boot/firmware' ] && return
        confirm -y "Update boot firmware config" || return
        local item args=('--nocheck')                       # don't check part. labels
        [ -n "$2" ] && args+=('--root' "$2")
        [ -n "$1" ] && args+=('--boot' "$1")
        args+=('root' '.' "$3" '--')
        for item in "${1:-/boot/firmware}"/cmdline-*.txt ; do
            [ -f "$item" ] || continue
            item="${item#*cmdline-}" ; ((ntxt += 1))
            args+=('root' "${item%.txt}" "$3" '--')
        done
        if [ "$ntxt" = 0 ] ; then
            warning "Found no files matching 'cmdline-*.txt'"
        else
            embed -i -t -v -z centauriraspi --zombie --yes --host="$name" "${args[@]}"
        fi
    }

    get_workspace -q && outputMessage 'renaming' - "${CEN_NAME//?/ }  "
    if [ -d "$dirr/boot/firmware" ] ; then
        ___rename_rpi "$dirb" "$dirr" "LABEL=$lblr"
    else
        ___rename_x86 "$dirb" "$dirr" "LABEL=$lblr"
    fi
                                                    # unconfigure swap ...
    embed -i -t -v -z centauriswap void --base "${dirr:-/}"

    # re-configure wlan if network is configured ...
    if [ -s "$dirr/var/centauri/persistent/centaurinetcfg" ] ; then
        cfg_params -r "$dirr$DAT_SOHO_PARAMS"       # try to get wlan password
        if [ -z "$dirr" ] ; then
            cfg_wlan "$name"                        # update wlan passwd
        else
            folder -c -f -- "$dirr" ; cfg_wlan "$name" --out=.
        fi
    fi

    message -a "Unmount and change partition labels"
    folder -c '/' ; automount -o progress -q        # allow umount
    system -q -- umount -a --types vfat,ext4,btrfs

    confirm -y -f "Change partition labels of '%s'" "$disk" || return
    embed -i -v -z centaurimedia --yes --device="$disk" ${args[*]} -- probe || return

    if [ -n "$dirr" ] ; then
        message "Completed"
    else
        message -a "Reload systemd and mount"
        system -e systemctl daemon-reload || return
        system -q -- mount -a --types vfat,ext4,btrfs
        message "Completed, please reboot soon"
    fi
}

# ------------------------------------------------------------------------------
# show repository info, copy from repository: [[-u] <path> [<dest> [<dflt>]]]
#
#   <path>      path in root file system
#   <dest>      destination, overrides <path> unless '-'
#   <dflt>      alternate for missing <path>, no error if '-'
# ------------------------------------------------------------------------------
actionRepository() {
    # get base folder and repository path
    get_workspace -n || return
    get_repository || return

    # no args: print repository information
    local host="${SOHO_HOST:-$HOSTNAME}"
    local tmpl="$SOHO_WORKSPACE/templates"
    if [ $# = 0 ] ; then
        message -a -c "Repository" "$DAT_REPOSITORY"
        if [ -d "$DAT_REPOSITORY/@shared" ] ; then
            set -- "$DAT_REPOSITORY/@shared"/?_*
            trace -a -c "... shared" "$DAT_REPOSITORY/@shared ($# items)"
        else
            message -d 12 -a -c "... shared" "--- missing ---"
        fi
        if [ -d "$DAT_REPOSITORY/$host" ] ; then
            set -- "$DAT_REPOSITORY/$host"/?_*
            trace -a -c "... private" "$DAT_REPOSITORY/$host ($# items)"
        else
            message -d 12 -a -c "... private" "--- missing ---"
        fi
        if [ -d "$tmpl" ] ; then
            message -a -c "Templates" "$tmpl"
        else
            message -d 12 -a -c "Templates" "--- missing ---"
        fi
        return
    fi

    if [ -z "$SOHO_DNAME" ] ; then
        folder -c -f -p "$DAT_REPOSITORY/@shared/.."
        : ${SOHO_DNAME=${PWD##*/}}
    fi
    folder -c -f "$tmpl/.."
    copyFromRepo "$@"
}

# ------------------------------------------------------------------------------
# Restore a disk tar: <imag> <disk> [<name> [ext4|btrs] [<swap>]] [<para>|-]
# ------------------------------------------------------------------------------
actionRestore() {
    local dbug disk dist name curr="$PWD" para fsys swap swad='8'
    while [ $# -gt 0 ] ; do
        case "$1" in
        /dev/*)     disk="$1" ;;
        *.tar|+)    imag="$1" ;;
        *.*|*/*|-)  para="$1" ;;
        DEBUG)      dbug=1 ;;       # disable partition/filesystem creation
        ext4|btrfs) fsys="$1" ;;
        [1-9]*M)    swap=1 ;;
        [1-9]*G)    swap="${1%G}"
                    [ -n "${swap//[0-9]}" ] && quit -e "Invalid swap size:" "$1"
                    ;;
        [a-z]*)     [ -z "$name" ] && name="$1" || para="$1";;
        *)          invoke -e "Invalid argument or hostname:" "$1" ; return
        esac ; shift
    done

    # check input
    blkdevice -d -e -x -- "$disk" || return
    inpfile -c -l -- "${imag:-+}" || return
    if [ "${para:--}" != '-' ] ; then
        if ! resolve -e -q -p -- "$para" ; then
            error "Parameter file not found:" "$para" ; return
        else
            para="$CEN_RESOLVE"
            trace -a -c "Param file" "$para"
        fi
    fi

    local base rasp volf item  host appl auto labl
    [ "$para" = '-' ] || appl=1
    case "$CEN_INPFILE" in
    *-rpi_*)    swad='4'; rasp='rpi' ;;
    *-r32_*)    swad='4'; rasp='rpi' ; [ -z "$fsys" ] && fsys='ext4' ;;
    *debian-bookworm*)  item='worm9' ;;
    *debian-trixie*)    item='trix9' ;;
    *debian-*)          item='xxxx9' ;;
    esac


    # create temp folder and extract tar file
    tmpfile -n -t -r -s base
    folder -c -f -m -r -- "$base"
    system -e -p -r -- tar -xaf "$CEN_INPFILE" || return

    # get the host name (from tar content)
    if matchpath -a labl -e -- $host*_boot_* $host*_root_* ; then
        matchpath -a labl -e -f -- *_boot_* *_root_*
        host="${labl%%_*}"
    fi

    if [ -n "$item" ] ; then
        warning "A minimal system must be renamed or will not boot:" "$host"
        name="$item"
    elif [ -z "$name" ] ; then
        name="$host" ; item='-'
    fi
    [ -n "$item" ] && get_value name "$name" - "Set hostname of installed image"
    [ -z "$swap" ] && get_value swap "$swad" - "Size of swap partition in GByte"

    [[ "$name" =~ [a-z][-a-z]*[a-z] ]] || quit -e "Invalid host name:" "$name"
    [ "$name" = "$HOSTNAME" ] && quit -e "Cannot use current host name"
    [ -n "${swap//[0-9]}" ] && quit -e "Invalid swap size:" "$swap"

    local opts=('-y' '-D' "$CEN_BLKDEVICE")
    if [ "${#labl[@]}" = 1 ] ; then                     # bios boot, no gpt ...
        labl=('' "$labl") ; opts+=('-B' '-M')
    elif [ "${#labl[@]}" != 2 ] ; then
        error "Input data unusable ($host):" "$CEN_INPFILE" ; return
    fi

    if [ "$fsys" = 'ext4' ] ; then
        opts+=('-4')
    else                                                # btrfs uses a 'volumes' file
        volf="${host}_volumes"
        if [ ! -e "$volf" ] ; then                      # ext4 mode without volumes file
            opts+=('-4') ; volf= ; fsys='ext4'
        fi
    fi

    if [ "$name" != "$host" ] ; then                    # renaming ...
        opts+=(-N "$name")
        [ -z "$appl" ] && appl=2                        # needs wpa update
    fi

    # create partitions and filesystems
    if [ -z "$dbug" ] ; then
        # restore root, usr, home and boot (if present)
        if [ -n "$rasp" ] ; then
            confirm -a -y -f '%-48s' "Install '$name' in 'raspberry' mode" || return
            embed -z -v centauridisk "${opts[@]}" -M -R 512 -P$swap -- "${labl[1]}"
        else
            confirm -a -y -f '%-48s' "Install '$name' in 'x86/pc' mode" || return
            embed -z -v centauridisk "${opts[@]}" -P$swap -- "${labl[1]}"
        fi
    fi

    # mount destination partition
    system -e -p -r -- partprobe ; sleep 1
    [ "$fsys" = 'ext4' ] && item="${name}_root" || item="${name}_vol0"
    if automount -b -o progress -- "$item" ; then
        auto=1

        [ "$name" != "$host" ] && samba_check "$CEN_MOUNT_DIR"

        if [ -h "$CEN_MOUNT_DIR/boot/efi" ] || [ -d "$CEN_MOUNT_DIR/boot/efi" ] ; then
            message "This system is configured to boot via EFI"
        fi
    fi

    # replace grub.cfg, disable update-grub
    while [ "$fsys" = 'ext4' ] && error -t ; do
        # needed for ext4 mode only and only if update-grub is not diverted. For
        # all btrfs systems update-grub should already be diverted by cloning

        [ -d "$CEN_MOUNT_DIR/boot/grub" ] || break
        message -a "Replacing 'grub.cfg' with 'grub.minimal'"
        local gcfg stab="s/^set myname=.*/set myname=$name/"
        system -e -p -s gcfg -- sed -e "$stab" 'grub.minimal' || break
        create -t -v gcfg -- "$CEN_MOUNT_DIR/boot/grub/grub.cfg"

        [ -x "$CEN_MOUNT_DIR/usr/sbin/udate-grub.distrib" ] && break
        targ='/usr/sbin/update-grub'
        message -a "Diverting '$targ' to noop"
        system -e -p dpkg-divert --root="$CEN_MOUNT_DIR" --rename --add "$targ" || break
        targ="$CEN_MOUNT_DIR$targ"
        dryrun "<script $targ>" && break
        {   echo "#!/usr/bin/bash"
            echo echo "update-grub: disabled by '$CEN_NAME'"
            echo exit 0
        } >"$targ"
        system -e -p -- chmod 775 "$targ"
        break
    done

    # create extra volumes, install tar files
    local tarf volu
    if ! error -t ; then                            # do nothing after error
        appl=
    elif [ -n "$volf" ] ; then                      # btrfs image has a volumes file ...
        while read item ; do
            item="${item##*/}"
            case "$item" in
            Root|Home)
                ;;
            *)
                matchpath -e -o -s tarf -- *_${item,}_*
                message -a -p "Extra volume: %s  Tar file: %s" "$item" "${tarf:--}"
                if [ ! -d "$CEN_MOUNT_DIR/Volumes" ] ; then
                    error "Missing folder:" "$CEN_MOUNT_DIR/Volumes"
                    break
                fi
                volu="$CEN_MOUNT_DIR/Volumes/$item"
                if [ ! -e "$volu" ] ; then
                    system -e -p -- btrfs subvolume create "$volu"
                    create -- "$volu/${name^^}_${item^^}"
                    [ "$item" = 'Backup' ] &&
                        embed centauridata init "$CEN_MOUNT_DIR/Volumes/Backup" - + -
                fi
                [ -n "$tarf" ] &&
                    system -e -p -- tar -C "$volu" -xaf "$tarf"
            esac
        done < "$volf"
    else                                            # ext4 supports only export, shared
        for file in *_export_*.tar* *_shared_*.tar* ; do
            [ -f "$file" ] || continue
            item="${file#*_}" ; item="${item%%_*}"
            message -a -p "Extra folder: %s  Tar file: %s" "$item" "$file"
            item="$CEN_MOUNT_DIR/$item"
            folder -m -- "$item" || break
            system -e -p tar -C "$item" -xaf "$file" || break
        done
    fi

    # appl='' do nothing, appl=1 do query or params, appl=2 network only
    if [ "$appl" = 1 ] ; then
        # 3 args: do parameter-file or query update
        cfg_apply "$CEN_MOUNT_DIR" "$name" "${para:-+}"
    elif [ -n "$appl" ] ; then
        # 2 args: system was renamed
        cfg_apply "$CEN_MOUNT_DIR" "$name"
    fi

    # remove tmp data
    [ -z "$auto" ] || automount -o progress -q
    folder -c -f -- "$curr"
    remove -d -- "$base"
}

# ------------------------------------------------------------------------------
# call setup plugin
# ------------------------------------------------------------------------------
actionSetup() {
    allowInstall                                # check permission to install

    # get_workspace calls get_config -s
    local rest verb="$CEN_ACTION"
    case "$CEN_ACTION" in
    clone)  get_workspace -f || return ; verb= ;;
    seed)   get_workspace ;;
    *)      get_workspace -f || return
    esac
    trace -a -c "Base folder" "$SOHO_WORKSPACE"

    # Updated seed tar, must restart. Ignore this if called by setup
    if [ -z "$CEN_OPT_DISPATCH" ] && [ "$DAT_SEED" -nt '.timestamp' ] ; then
        trace "The seed tar was updated, must restart after unpacking"
        dryrun -s "unpack/restart" && quit -t -a
        run_installer 'install'
        # install replaced our sources, so we must restart now ...
        [ "$DAT_SEED" -nt '.timestamp' ] ||
            embed -x "$CEN_NAME" "${CEN_CMDOPTS[@]}" "${CEN_CMDARGS[@]}"
        quit -t -i                              # quit if not exexuted
    fi

    get_netcache || return                      # get up-to-date cache data

    # source the setup script as plugin
    if [ -z "$CEN_OPT_DISPATCH" ] ; then
        get_setup || return                     # really source the script
    fi

    get_architecture || return                  # used by templ_xxx
    get_repository || return
    get_config || return                        # be sure to have config
    netconfig -e || return                      # get full network config

    dryrun -s 'setup' && return                 # setup does not handle dryrun

    trace -p "Calling '%s' in 'setup' script" "$CEN_OPT_DISPATCH"
    [ -n "${CEN_CMDARGS[CEN_CMDINDX]}" ] && DAT_NOT_LAST=1 || DAT_NOT_LAST=
    isfunction -c -e --  "$CEN_OPT_DISPATCH" $verb "$@"
    trace -p "Returned from '%s'" "$CEN_OPT_DISPATCH"
}

# ------------------------------------------------------------------------------
# Process a template: <tmpl> [<fout>|-]
# ------------------------------------------------------------------------------
actionTemplate() {
    get_workspace -f || return
    if [ "$#" = 0 ] ; then                      # show template info message ...
        syspager                                # check pager
        $CEN_PAGER outputMessage 'template' ; return
    fi
    templ_expand "$1" "$2"
}

# ------------------------------------------------------------------------------
# action unpack distributable tars to workspace: [<dist> [<conf>]]
# ------------------------------------------------------------------------------
actionUnpack() {
    get_workspace -f || return

    local dirs=() dist item star curr
    for item in "$SOHO_WORKSPACE/dists"/[!@]* ; do
        [ -d "$item" ] || continue
        dist="${item##*/}"
        [ "${1:--}" != '-' -a "$1" != "$dist" ] && continue
        if [ "${2:--}" != '-' ] ; then
            curr="$1:$2"
            matchpath -e -o -- "$item/@seed/seed-$dist-$2.tgz"
        else
            curr="$1"
            matchpath -e -o -- "$item/@seed/seed-$dist".tgz "$item/@seed/seed-$dist"-*.tgz
        fi
        star="$CEN_MATCHPATH"
        if [ ! -s "$star" ] ; then
            warning -a -c $"Cannot unpack - no seed tar:" "$curr"
            continue
        elif [ -d "$item/dynamic" -o -d "$item/static" ] ; then
            warning -a -c $"Skipping unpack" "$dist -" $"'dynamic' or 'static' folder already exists"
            continue
        fi
        message -a -c $"Run unpack" "$star"
        system -f -- tar --directory="$item" -xaf "$star"
    done
}

# ------------------------------------------------------------------------------
# zerofill and trim free space: -no args-
# ------------------------------------------------------------------------------
actionVacuum() {
    confirm -y $"This will remove all cache data and log files" || return
    embed centauricleanup --yes --all
    system -q -- fstrim /

    confirm -y $"Zero-fill unused disk space (good for VMs)" || return
    embed centaurimedia --yes copy '/dev/zero' "$CEN_NAME-$$.tmp"
    system -q sync ; remove "$CEN_NAME-$$.tmp"
    system -q -- fstrim /
    if [ -d '/mnt/boot' ] ; then
        if system -q -- systemd-detect-virt -q ; then
            embed centaurimedia --yes copy '/dev/zero' "/mnt/boot/$CEN_NAME-$$.tmp"
            system -q sync ; remove "/mnt/boot/$CEN_NAME-$$.tmp"
        fi
        system -q -- fstrim '/mnt/boot'
    fi
}

# ------------------------------------------------------------------------------
# sync workspace with repository: archive|get|put [<suff>|<work> [<dist>]]
# ------------------------------------------------------------------------------
actionWorkspace() {
    # archive workspace
    if [ "${1::3}" = 'arc' ] ; then
        actionPack ; error -t || return
        run_installer 'archive' "$2"
        return
    fi

    if [ "${2:--}" = '-' ] ; then
        get_workspace -n || return
        set -- "$1" "$SOHO_WORKSPACE" "$3"
    fi

    # workspace folder ...
    if [ "$1" = 'get' ] ; then
        if [ -e "$2" ] ; then
            confirm -n $"Existing workspace, continue anyhow" || return
            folder -c -f -- "$2"
        else
            folder -c -m -f -- "$2"
        fi
    elif [ "$1" = 'put' ] ; then
        if [ ! -d "$2" ] ; then
            invoke -e $"Workspace not found" ; return
        fi
        folder -c -f -- "$2"
    else
        invoke -e $"1st argument must be 'get' or 'put'" ; return
    fi
    message -a -c $"Workspace folder" "$PWD"

    # repository folder ...
    local repo dist
    if [ "${3:--}" = '-' ] ; then
        resolve -e -c -s repo -- "$CEN_ROOT/shared/../.." || return
    else
        folder -s repo -- "$CEN_ROOT/configs/$3" || return
    fi
    message -a -c $"Repository" "$repo"

    if [ "$1" = 'get' ] ; then
        # copy content of master folder
        embed -z centauricopy sync "$repo/@soho/master" . || return
        CEN_OPT_BASE="$PWD" ; actionUnpack
    else
        for dist in dists/[a-z]* ; do
            [ -d "$dist/static" ] || continue
            run_installer pack "${dist#*/}"
        done
        embed -z centauricopy sync -x 'dists/[a-z]*/[a-z]*' -x 'seed-*-*.tgz' \
                              -x '^seed.tgz' -x '^setup.conf' -x '^configs' \
                              -x '^dynamic' -x '^packages' -x '^passwords' \
                              -x '^private' -x '^static' -x '^templates' \
                              "$repo/@soho/master"
    fi
}

# ------------------------------------------------------------------------------
# option parsing: <option> [<argument>]
# ------------------------------------------------------------------------------
options() {
    case "$1" in

    -B|--bas|--base)
        optarg 'base'       -    -d ;;          # existing folder
    -C|--curr*)
        optarg 'current'    -    -t ;;          # text argument
    --dis*)
        optarg 'dispatch'   -    -t ;;          # text argument

    esac
}

# ------------------------------------------------------------------------------
# action parsing: <verb> <argument>...
# ------------------------------------------------------------------------------
actions() {
    case "$1" in

    # admin actions
    con*)
        invoke -s 'config'  -             0 4 ;;   # 0 .. 4 args
    dis*)
        invoke -s 'distr'   -             0 2 ;;   # one optional arg
    doc*|help)
        invoke    'docview' -             0 + ;;   # any number of arguments
    exp*)
        invoke -s 'expand'  -             0 1 ;;   # one optional arg
    inf*)
        invoke -s 'info'    -             0 1 ;;   # one optional arg
    ins*)
        invoke -s 'install' -             0 + ;;   # any number of arguments
    pac|pack)
        invoke -s 'pack'    -               0 ;;   # no args
    unp*)
        invoke -s 'unpack'  -             0 2 ;;   # 0 .. 2 args
    wor*)
        invoke -s 'workspace' -           1 3 ;;   # 1 .. 3 args

    # setup actions
    app*)
        invoke -r 'appli'   actionSetup     0 ;;   # no args
    bac*)
        invoke -r 'backup'  -             2 5 ;;   # 2 ... 5 args
    bas|base)
        invoke -r 'base'    actionSetup     0 ;;   # no args
    cli*)
        invoke -r 'client'  actionSetup     0 ;;   # no args
    clo*)
        invoke -r 'clone'   actionSetup   1 3 ;;   # 1 or 3 args
    mes*)
        invoke    'message' -             1 4 ;;
    net*)
        invoke -r 'network' -             0 1 ;;
    own*)
        invoke -r 'owners'  -             1   ;;
    ren*)
        invoke -r 'rename'  -             1 2 ;;   # 1 or 2 args
    rep*)
        invoke -r 'repository' -          0 3 ;;
    res*)
        invoke -r 'restore' -             2 + ;;
    see|seed)
        invoke -r 'seed'    actionSetup     0 ;;
    ser*)
        invoke -r 'server'  actionSetup     0 ;;   # no args
    tem*)
        invoke    'template' -            0 2 ;;   # 0 ... 2 args
    vac*)
        invoke -r 'vacuum'   -              0 ;;

    # short form aliases for 'clone'
    /dev/*)
        invoke -r 'clone'   actionSetup    1 3 "$@" ;;  # 1 .. 3 args

    # call an exended command of 'setup'
    ??*)
        local item ; get_workspace -q && get_commands
        for item in "${DAT_SOHO_CMDS[@]}" ; do
            item="${item%|*}"
            [ "$1" = "$item" ] && invoke -r "$item" actionSetup - - "${@:2}"
        done
    esac
}

# ------------------------------------------------------------------------------
# usage info
# ------------------------------------------------------------------------------
usage() {

    usageset \
        -o - \
        -o '--dispatch   <func>'  $"internal: used by setup helper to register" \
        -o -                      $"          a dispatch function for commands" \
        -o '-B --base    <fldr>'  $"workspace folder containing the seed tar" \
        -o '-C --current <dist>:<inst>' \
        -o -                      $"select the current distribution and installation" \

    usageset \
        -a $"â¢â¢â¢ setup commands â¢â¢â¢" \
        -a 'seed'                 $"# step 1: unpack seed tar" \
        -a '[clone] /dev/<disk> [<name> [<swap>]]' \
        -a -                      $"# step 2: clone to EFI bootable BTRFS disk" \
        -a 'base'                 $"# step 3: install a base system" \
        -a 'client'               $"# ...     make this a client machine" \
        -a 'appliance'            $"# ...     make this an appliance" \
        -a 'server'               $"# ...     make this a server machine"

    local item ; get_workspace -q && get_commands
    for item in "${DAT_SOHO_CMDS[@]}" ; do
        usageset -a "${item%|*}" "# ${item#*|}"
    done

    usageset \
        -a - \
        -a "â¢â¢â¢ setup tools â¢â¢â¢" \
        -a 'config     show|update' \
        -a -                      $"# update configuration from 'setup.conf'" \
        -a 'config     <para>'    $"# update configuration from parameter file" \
        -a 'config     query [<dest>|- [<name>|- [<para>|-]]]'\
        -a -                      $"# update configuration using a menu" \
        -a 'info'                 $"# print some status information" \
        -a 'network    [cache|show|update|wait]' \
        -a 'repository [<path> [<dest>|- [<dflt>|-]]]' \
        -a -                      $"# install a file from repository" \
        -a 'template   <path> [<file>|-|.]' \
        -a -                      $"# expand a template to stdout or a file" \
        -a - \
        -a "â¢â¢â¢ packaging commands â¢â¢â¢" \
        -a 'distrib    [[<dist>]Â°<conf>]' \
        -a -                      $"# generate distributable tar file from workspace" \
        -a 'expand     [<soho>]'  $"# create workspace from distributable tar file" \
        -a 'owner      save|restore' \
        -a -                      $"# restore file attributes (git clone) or save" \
        -a 'pack'                 $"# generate seed tar file from workspace" \
        -a 'unpack     [[<dist>]Â°<conf>]' \
        -a -                      $"# unpack seed tar file in workspace" \
        -a 'workspace  archive [<suff>]' \
        -a -                      $"# run 'pack' and create 'centaurisoho-master' tar" \
        -a 'workspace  get|put [<work> [<dist>]]' \
        -a -                      $"# syncronize workspace with repository" \

    usageset \
        -a - \
        -a $"â¢â¢â¢ other/helpers â¢â¢â¢" \
        -a 'backup     <host> <boot>|-|+ [<root>|-|+ [<arch> [<algo>]]]' \
        -a -                      $"# offline backup to create a disk tar" \
        -a 'docview    [<key>]'   $"# documentation viewer" \
        -a 'install    <arg>...'  $"# run the 'installer' tool" \
        -a 'message    <mtag> [<file>|- [<pref> [<subs>]]]' \
        -a -                      $"# cat or copy a text from '@misc/messages' file" \
        -a 'rename     [<curr>] <name>' \
        -a -                      $"# change the hostname of a running system" \
        -a 'restore    <dist> <disk> [ext4|btrfs] [<name>] [<swap>] [<para>|-]' \
        -a -                      $"# install an image tar to a block device" \

    usageset \
        -p '<arch>'               $"backup target: architecture" \
        -p '<boot>'               $"... [*] [**]   boot partition or mountpoint" \
        -p '<host>'               $"...            current host name" \
        -p '<root>'               $"... [*] [***]  root partition or mountpoint" \
        -p '[*]'                  $"use '+' to get partition label from host name" \
        -p '[**]'                 $"use '-' to skip" \
        -p '[***]'                $"use '-' for '<host>_root' instead of '<host>_vol0'" \
        -p - \
        -p '<mtag>'               $"message text: section tag inside []" \
        -p '<pref>'               $"...           line prefix like '# '" \
        -p '<subs>'               $"...           substitute for %1%" \
        -p - \
        -p '<dest>'               $"destination unless '-', overrides <path>" \
        -p '<dflt>'               $"alternate for missing <path>, no error if '-'" \
        -p '<disk>'               $"a disk drive name like **sdb** or **mmcblk1**" \
        -p '<file>'               $"file name or path" \
        -p '<key>'                $"a chapter number or a word to search for" \
        -p '<name>'               $"the name that is assigned to the clone" \
        -p '<para>'               $"paramater file (default: $DAT_SOHO_PARAMS)," \
        -p -                      $"use '-' to disable configuration prompts" \
        -p '<path>'               $"full path name, starts with '/'" \
        -p '<seed>'               $"alternate seed tar (gets linked to seed.tar)" \
        -p '<soho>'               $"master tar file (the distributable)" \
        -p '<suff>'               $"append suffix to file name (before extension)" \
        -p '<swap>'               $"swap partition size in <nnn>M or <nn>G notation" \

    usageset \
        -l $"Setup" \
        -t $"In step 1 you unpack a distributable tar and run the extracted 'setup':" \
        -t - \
        -t "Â°   tar -xaf centaurisoho-bookworm-worms.tgz" \
        -t "Â°   centaurisoho-bookworm-worms/setup seed" \
        -t - \
        -t $"This step installs centauri-bash-library and tools. You can continue" \
        -t $"using 'setup' or you can now use the slightly friendlier '$CEN_NAME'."

    usageset \
        -l $"Templates" \
        -t $"The 'repository' and 'template' actions use '*.TEMPLATE' files to generate" \
        -t $"configuration files. Template parameters are from 'setup.conf' (setup step" \
        -t $"1 and 2) or later also from '$DAT_SOHO_NETCFG'."
}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
