#!/usr/bin/bash
# ------------------------------------------------------------------------------
# _centauri_bash_net = centauri-bash-lib: Network information management
#
# Call:     . _centauri_bash_net [-n]
#
# Options:  -n  do not call [[netconfig()]] on load
#
#+General:  This module reads/writes network configuration data, mostly used by
#           the  tools **centaurinetcfg**, **centauriswitch**, **centauriroute** and
#           **centaurisecrets**.
#
#+          The implementation tries to avoid loading other centauri-bash-lib modules,
#           see [[netfile()]], [[netlink()]] and [[nettemp()]]. These functions also
#           handle the settings of CEN_NET_OUTPUT for output redirection.
#
# Storage:  CEN_NET_DIR_LIB="$CEN_ROOT/persistent"      # for cached things
#           CEN_NET_FILE_CONF="$CEN_NET_DIR_LIB/centaurinetcfg"
#           CEN_NET_FILE_FILT="$CEN_NET_DIR_LIB/centaurifilter"
#
#           CEN_NET_DIR_RUN="$CEN_ROOT/transient"       # for temporary things
#           CEN_NET_FILE_STAT="$CEN_NET_DIR_RUN/network_status"
#           CEN_NET_FILE_PROX="$CEN_NET_DIR_RUN/network_proxy"
#
#+Variables: Many functions in this module return results in static variables.
#           These variable names start with prefix '**_net**'. This differs from
#           most other centauri-bash-lib modules which use '**_cen_**' as prefix.
#           Do not expect result variables to stay valid after the next call of
#           a function in this module.
#
# Copyright Dr. J. Pfennig (c) 2013-2024
# ------------------------------------------------------------------------------

CEN_MODULES['_centauri_bash_net']='0.41:4'

# IMPORTED: CEN_NET_OUTPUT                              # see netfile()

CEN_NET_DIR_LIB="$CEN_ROOT/persistent"                  # for cached things
CEN_NET_FILE_CONF="$CEN_NET_DIR_LIB/centaurinetcfg"
CEN_NET_FILE_FILT="$CEN_NET_DIR_LIB/centaurifilter"     # used as prefix

CEN_NET_DIR_RUN="$CEN_ROOT/transient"                   # for temporary things
CEN_NET_FILE_STAT="$CEN_NET_DIR_RUN/network_status"
CEN_NET_FILE_PROX="$CEN_NET_DIR_RUN/network_proxy"

CEN_NET_PREFIX_IP6_DFLT='fc01::/96'

# data for netiface ...

CEN_NET_IFNAMES=                # 0:=no mapping  1:=systemd names
CEN_NET_IFMAP=                  # list of interface mappings
CEN_NET_IFKCMD=                 # flag for net.ifnames
CEN_NET_IFIEN=0                 # ethernet index
CEN_NET_IFIWL=0                 # wlan ...
CEN_NET_IFIUS=0                 # usb ...

# ------------------------------------------------------------------------------
# Interface Naming + About BIOS, systemd and internal interface names
#
#+Kernel:   Names of network interfaces as used by the linux kernel can be:
#
#,          - **bios** (traditional) like 'eth0' or 'wlan0'. These are enabled
#,            with kernel command line parameter 'net.ifnames=0'.
#,          - **systemd** like 'enp1s3' or 'wlp3s0'. These names depend on the
#,            machine's hardware configuration and are not well portable.
#,          - **links** either symlinks or systemd link units can be used to
#,            bridge between bios and systemd names.
#
#+      While **bios** names do not work well with machines that have multiple NICs,
#       **systemd** names are not portable between differen machines. This is why
#       centauri introduces the concept of **internal** names.
#
#+Internal: The centauri tools and library preferrably use an internal naming
#           sheme to improve portablity of system images between different
#           hardware without reconfiguration:
#
#,          **eth0**    primary ethernet   (internal device has priority)
#,          **eth1**    secondary ethernet (internal or via USB etc.)
#,          **wlan0**   primary wlan       (internal device has priority)
#,          **wlan1**   secondary          (internal or via USB etc.)
#
#+          [[netiface()]] translates between name shemes based on built-in
#           heuristics. Additionally the "centaurinetcfg" configuration file can
#           define host name dependent mappings between internal names
#           and systemd names.
#
#+          The system configuration files generated by
#           [[centaurinetcfg]] always use kernel names (bios or systemd).
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# netconfig - Load network configuration from status file
#
# Call:     netconfig [-e|-f] [-r|-u] [<file>]
#
# Options:  -e  error if config file not found
#           -f  fatal error if config file not found
#           -r  re-read even if CEN_NET_HOSTS is set
#           -u  unset configuration variables
#
# Return:   **false** if configuration cannot be read
#
# Storage:  CEN_NET_FILE_CONF="$CEN_NET_DIR_LIB/centaurinetcfg"
#
#+By default the function does nothing if CEN_NET_DOMAIN is set, e.g. the
# configuration is only read once.
# ------------------------------------------------------------------------------
netconfig() {
    local _frea _oerr=:
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -e)   _oerr=error ;;
      -f)   _oerr=fatal ;;
      -r)   _frea=1 ;;
      -u)   _frea=0 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -n "$CEN_NET_HOSTS" -a -z "$_frea" ] && return 0
    local _file="${1:-$CEN_NET_FILE_CONF}"

    CEN_NET_CONFIG=             # configuration name
    CEN_NET_DOMAIN=             # domain name of the network
    CEN_NET_WIRELESS=           # client and AP WLAN ssids
    CEN_NET_PUBLIC=             # our public dns name
    CEN_NET_REJECT_HOST=        # to set reject route for server nick

    CEN_NET_SERVER_GEN=         # generic server name (nick name)

    CEN_NET_ROUTER_GEN=         # generic router name (nick name)
    CEN_NET_ROUTER_DEF=         # generic router real name
    CEN_NET_ROUTER_IP4=         # ip address of default router

    CEN_NET_PREFIX_IP6=         # prefix for locally managed addresses

    CEN_NET_NETMASK=            # network mask in dot notation
    CEN_NET_NETBITS=            # network mask bits

    CEN_NET_ADDR_IPLIST=()      # list of IP addresses for this computer
    CEN_NET_ADDR_METHOD=        # method to configure IFs: nm dhcp static

    CEN_NET_NETWORKS=()         # allowed networks firewall/host.allow
    CEN_NET_EXTERNAL=           # set to CEN_NET_NETWORKS[7] if external

    CEN_NET_FILTERS=()          # ... in samba syntax

    CEN_NET_SERVERS=()          # configured servers
    CEN_NET_ROUTERS=()          # confiugred routers
    CEN_NET_OPTIONS=()          # option strings: <option> <host>...
    CEN_NET_HOME_DNS=()         # homedns strings: <domain> <nsip> <host>
    CEN_NET_HOSTS=()            # host strings: <mac> <ip4> <host>...
    CEN_NET_IFACES=()           # interface strings: <name> <host> <what>
    CEN_NET_FAKES=()            # invalid host names

    CEN_NET_PORT_SECR=          # port for centaurisecrets
    CEN_NET_PORT_ADNS=          # port for dns forwarder
    CEN_NET_PORT_HTTP=          # port for http proxy
    CEN_NET_PORT_HTTPS=         # port for https proxy

    [ "$_frea" = 0 ] && return 0

    if [ "$CEN_NET_OUTPUT" = '.' ] && _cen_source ".$CEN_NET_FILE_CONF" ] ; then
        return 0
    elif _cen_source "$_file" ; then
        return 0
    fi
    $_oerr $"No network config:" "$_file" ; return 1
}

# ------------------------------------------------------------------------------
# netconv - Convert IP4v between dotted and binary, mac-address to IP6v
#
# Call:     (1.1)   netconv -d <binary>             # ip4v only
#           (1.2)   netconv -b <dotted>             # ...
#           (2.1)   netconv -m <mac>                # ip6v only
#           (2.2)   netconv -u <dotted>[/<bits>]    # ...
#
# Options:  -d  convert binary -> dotted
#           -b  convert dotted -> binary
#           -m  convert mac to IP6v address
#           -u  convert dotted -> ULA (prefix length 96)
#
# Arguments:<binary>   a binary IPv4 address
#           <bits>     netmask bits
#           <dotted>   a dotted IPv4 address
#           <mac>      a mac address
#
# Return:   **true** on success or **false** on failure
#
#           **_netconv** is set to the conversion result
#
# IP6v address generation from mac:
#
#, - take the mac address: for example 52:74:f2:b1:a8:7f
#, - throw ff:fe in the middle: 52:74:f2:ff:fe:b1:a8:7f
#, - reformat to IPv6 notation 5274:f2ff:feb1:a87f
#, - convert the first octet from hexadecimal to binary: 52 -> 01010010
#, - invert the bit at index 6 (counting from 0): 01010010 -> 01010000
#, - convert octet back to hexadecimal: 01010000 -> 50
#, - replace first octet with newly calculated one: 5074:f2ff:feb1:a87f
#, - prepend the link-local prefix: fe80::5074:f2ff:feb1:a87f
#
# IP6v from IP4v embedding (ULA) uses 'fc01' as prefix (prefix length 96).
# ------------------------------------------------------------------------------
_netconv=
netconv() {
    local _mode
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -b)   _mode=1 ;;
      -d)   _mode=2 ;;
      -m)   _mode=3 ;;
      -u)   _mode=4 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    case "$_mode" in
    1|4)
        local _bits="${1##*/}" _addr="${1%/*}"
        # dotted to binary
        _netconv=
        eval set -- ${_addr//./ }
        [ "$#" = 4 ] || return 1
        local _val0 _vres=0
        for _val0 in "$@" ; do
            [ -z "${_val0//[0-9]/}" ] || return 1
            [ $_val0 -lt 256 ] || return 1
            _vres=$(((_vres << 8) + _val0))
        done

        # generate ULA
        if [ "$_mode" = 4 ] ; then
            local _vhig=$((_vres >> 16))
            local _vlow=$((_vres & 0xffff))
            local _pre6="${CEN_NET_PREFIX_IP6:-$CEN_NET_PREFIX_IP6_DFLT}"
            printf -v _netconv '%s::%x:%x' "${_pre6%%:*}" "$_vhig" "$_vlow"
            if [ "$_bits" != "$_addr" ] ; then
                _bits=$((96 + _bits))
                _netconv+="/$_bits"
            fi
        else
            _netconv="$_vres"
        fi
        ;;

    2)  # binary to dotted
        local _val1=$(($1 & 255))         _val2=$((($1 >> 8) & 255))
        local _val3=$((($1 >> 16) & 255)) _val4=$((($1 >> 24) & 255))
        printf -v _netconv "%d.%d.%d.%d" "$_val4" "$_val3" "$_val2" "$_val1"
        ;;

    3)  # mac to IP6v
        _netconv=
        local temp="${1//:/}"
        [ "${#temp}" = 12 ] || return 1
        _netconv="${temp:2:2}:${temp:4:2}ff:fe${temp:6:2}:${temp:8}"
        temp="0x${temp::2}" ; ((temp ^= 2))
        printf -v temp "%2x" "$temp"
        _netconv="fe80::${temp// /0}$_netconv"
        ;;

    esac
    return 0
}

# ------------------------------------------------------------------------------
# netgetip - Get all ip addresses of a host or of an interface
#
# Call:    netgetip [-4|-6] [-e|-f] [-s <addr>] [<ifce>|-]
#
# Options:  -4  get IPv4 addresses only
#           -6  get IPv6 addresses only
#           -a  return all addresses (including local or transient)
#           -e  report errors via [[error()]]
#           -f  report errors via [[fatal()]]
#           -s  search an address, return interface name
#
# Arguments:<addr>  ipv4/6 address
#           <ifce>  an interface name like 'eth0'
#
# Variable: **_netgetip**   array of addresses found, or interface
#
# Return:  **true** on success or **false** on failure
#
#+The function uses the 'ip' command to collect data.
#
#.Examples: # get list of addresses
#.          netgetip -4 && message "known ipv4 addresses:" "${_netgetip[*]}"
#
#.          # search an address
#.          netgetip -6 -s 'fc01::a15:250' && message "interface:" "$_netgetip"
# ------------------------------------------------------------------------------
_netgetip=
netgetip() {
    local _opta _opti _opte _opts _line _ifce
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      -)        break ;;
      --)       shift ; break ;;
      -4|-6)    _opti="$1" ;;
      -a)       _opta=1 ;;
      -e|-f)    _opte="$1" ;;
      -s)       shift ; _opts="${1%/*}" ;;
      *)        _cen_abort - "$1"
      esac ; shift
    done
    _netgetip=()
    local _olst=(address list)
    [ -n "$_opta" ] || _olst+=(scope global) # permanent)
    [ "${1:--}" = '-' ] || _olst+=('dev' "$1")
    sysrun $_opte -r -a _outp -- ip $_opti "${_olst[@]}" || return 1
    set -f
    for _line in "${_outp[@]}" ; do
        set -- $_line
        if [ "${1//[0-9]/}" = ':' ] ; then
            [ "${2//[0-9a-z]/}" = ':' ] && _ifce="${2%:}"
        elif [ "$1" = 'inet' ] ; then
            [ "${2//[0-9]/}" = '.../' ] && _netgetip+=("$2")
        elif [ "$1" = 'inet6' ] ; then
            [ "${2//[0-9a-fA-F\:]/}" = '/' ] && _netgetip+=("$2")
        fi
        if [ -n "$_opts" ] && [ -n "$_netgetip" ] ; then
            if [ "$_opts" = "${_netgetip%/*}" ] ; then
                _netgetip="$_ifce" ; break
            else
                _netgetip=()
            fi
        fi
    done
    set +f ; [ -n "$_netgetip" ]                # return status
}

# ------------------------------------------------------------------------------
# nethost - Search a host entry in network host configuration table
#
# Call:    nethost [-e|-f] [-c|-n|-s] [--] <host>|<addr>|<mac>|-
#
# Options:  -c  do not match a configured server
#           -e  report errors
#           -f  make errors fatal
#           -n  check for name syntax only
#           -s  only match a configured server
#
# Arguments:<host>  a host name (optionally fully qualified)
#           <addr>  an IPv4 address like **10.21.2.11**
#           <mac>   a mac address
#
#           All input must be in lowercase
#
# Variables:**_nethost_name**   array of host names/aliases
#           **_nethost_dom**    domain name stripped from <host> arugment
#           **_nethost_mac**    the mac address    (or '-' if unknown)
#           **_nethost_ip**     the ipv4 address   (or '-' if unknown)
#
# Return:  **true** if <host> was found or **false** on failure
#
#+         This routine can either check for a valid name synstax (-n option)
#          or search the CEN_NET_HOSTS configuration table.
#
#+         The **_nethost_mac**, **_nethost_ip**, **_nethost_dom** and **_nethost_name**
#          variables are set on success or cleared on failure. Any domain name
#          is removed from **_nethost_name[0]** and saved in **_nethost_dom**.
#
# ------------------------------------------------------------------------------
_nethost_mac=
_nethost_ip=
_nethost_name=()
_nethost_domain=
nethost() {
    local _only _oerr _onam
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      -)     break ;;
      --)    shift ; break ;;
      -c)    _only='c' ;;
      -e|-f) _oerr="$1" ;;
      -n)    _onam=1 ;;
      -s)    _only='s' ;;
      *)     _cen_abort - "$1"
      esac ; shift
    done

    _nethost_mac= ; _nethost_ip= ; _nethost_name=() ; _nethost_domain=
    netconfig $_oerr || return 1

    local host snam sdom name="${1:--}"

    if [ "${name//[0-9]/}" = '...' ] ; then             # is an ipv4 address...
        _nethost_ip="$name"
    elif [ "${name//[0-9a-f]/}" = ':::::' ] ; then      # is a mac address...
        _nethost_mac="$name"
    else
        snam="${name%%.*}" ; sdom="${name#*.}"
        if [ "${name:--}" = '-' ] ; then
            [ -n "$_oerr" ] && error $_oerr $"Missing hostname" ; return 1
        elif [ -n "${name//[a-z0-9_-]/}" ] ; then
            [ -n "$_oerr" ] && error $_oerr $"Invalid hostname:" "$name" ; return 1
        fi
        _net_host_name="$name"
        if [ "$name" = "$sdom" ] ; then                 # no domain specified
            sdom=
        elif [ "$sdom" = "$CEN_NET_DOMAIN" ] ; then
            sdom= ; name="$snam"                        # no local dom in hosts
        else
            if [ -n "$_onam" ] ; then                   # name check only
                _nethost_domain="$sdom" ; return 0
            fi
            [ -n "$_oerr" ] && error $_oerr $"Domain mismatch:" "$name" ; return 1
        fi
    fi
    [ -n "$_onam" ] && return 0                         # name check only

    # loop over host table

    for host in "${CEN_NET_HOSTS[@]}" '-' ; do
        if [ "$host" = '-' ] ; then                     # nothing found
            [ -n "$_oerr" ] && error $_oerr $"Host not found:" "$name"
            _nethost_mac= ; _nethost_ip= ; _nethost_name=() ; return 1
        fi
        [ "${host/$name/}" = "$host" ] && continue      # quick pre-check
        set -- $host
        _nethost_mac="$1" ; shift
        _nethost_ip="$1"  ; shift
        if [ "$name" = "$_nethost_ip" -o \
             "$name" = "$_nethost_mac" ] ; then         # match by ip/mac address
            _nethost_name=("$@") ; break
        fi
        [ -z "$snam" ] && continue                      # no name to search
        host=" $* "
        [ "${host/ $name /}" = "$host" ] && continue    # check if name in list
        _nethost_name=("$@") ; break
    done

    # handle options -c/-s

    [ -z "$_only" ] && return 0
    if [ "${CEN_NET_SERVERS[0]}" = "$_nethost_name" ] ||
       [ "${CEN_NET_SERVERS[1]}" = "$_nethost_name" ] ; then
        [ "$_only" = 's' ] && return 0                  # is a server
    else
        [ "$_only" = 'c' ] && return 0                  # is a client
    fi
    _nethost_name=() ; _nethost_mac= ; _nethost_ip= ; return 1
}

# ------------------------------------------------------------------------------
# netiface - translate an interface name between internal and kernel naming
#
# Call:    (1) netiface [-s <vnam>] [-c|-d|-i|-k] [-e|-w] [-x] <name>|-
#          (2) netiface -p          # persist mappings
#          (3) netiface [-k]        # initialize, set CEN_NET_IFNAMES
#          (4) netiface -n          # no init, get kernel 'net.ifnames'
#
# Options:  -c  return a class path (like "/sys/class/net/eth0")
#           -d  return a device path (like "/dev/eth0")
#           -e  generate error messages
#           -i  return an internal device name (like "wlan0" or "eth0")
#           -k  return a systemd/kernel device name or check/init mode
#           -n  get kernel 'net.ifnames', no init
#           -p  persist current mappings in a temporary file
#           -s  save to variable (default is _netiface)
#           -w  generate warnings
#           -x  return **false** if interface does not exist
#
# Arguments:<name>  interface name or path (path gets stripped). Use '-' to
#                   check "br0" first and then for "eth0"
#           <vnam>  name of a variable to receive the result
#
# Variable: CEN_NET_IFNAMES     0:=kernel uses BIOS naming  1:=systemd naming
#
# Return:   Form (3) returns **false** with option -k for BIOS naming.
#
#.Examples: # check naming mode
#.          netiface -k && message "Using systemd names"
#
#.          # get kernel 'net.ifnames' status
#.          netiface -n
#.          case $? in
#.          0)  message "Found net.ifnames=0" ;;
#.          1)  message "Found net.ifnames=1" ;;
#.          *)  message "No net.ifnames"
#.          esac
#
#.          # map internal name to kernel name and vice versa
#.          netiface -k "wlan0"  -e && message "Kernel   name:" "$_netiface"
#.          netiface -i "enp1s3" -e && message "Internal name:" "$_netiface"
#
#.          # get a class path
#.          netiface -c "eth0"   -s path && message "Class:" "$path"
#.          netiface -c "enp1s3" -s path || message "Not found"
#
#+Centauri networking does not explicitly use the kernel naming sheme for device
# names. Instead it internally uses traditional BIOS names as these are logical
# names and not glued to a specific hardware. Again: this does not mean that
# traditional names must be used by the kernel. The netiface routine implements a
# mapping layer between internal names and kernel names.
#
#+The centauri network configuration files are generated by the [[centaurinetcfg]]
# tool using the definitons in file **$CEN_ROOT/default/centaurinetcfg**. Of course
# these generated files contain kernel names.
#
#+The **centaurinetcfg** file optionally contains **iface** statements that control
# name mapping (1st match wins). Here some examples:
#
#,  iface   eth0    mybox*      enp1s3  # map by kernel name for all mybox* hosts
#,  iface   eth0    alpha[34]   enp4s0  # map by kernel name for alpha3 and alpha4
#,  iface   wlan0   * 40:74:e0:b2:44:5e # map by mac address
#,  iface   eth0    alpha[34]   -       # stop rule processing here
#,  iface   eth0    *           kabel   # see systemd link units
#,  iface   wlan0   *           funk    # ...
#,  iface   eth0    *           en*     # [*] 1st seen 1st used
#,  iface   eth1    *           enp?s?  # [*] ...
#,  iface   wlan0   *           wl*     # [*] ...
#,  iface   wlan1   *           wl*     # [*] ...
#,
#,  [*] these rules get automatically added
#
#+To speed up name translation **netiface** uses a dictionary that can be written
# to a cache file using the -p option. The 1st mapping call in a process would try
# to initialize the dictionary from this file.
#
# Recommended reading: **https://wiki.debian.org/NetworkInterfaceNames**
#
#+Mapping: Options -k (internal to kernel) and -i (kernel to internal) attempt
# no mapping if netiface finds that BIOS names are enabled. This is the case
# when one of the fallowing is true:
#
#,      (1) The internal name matches a kernel name
#,      (2) "/etc/systemd/network/99-default.link" is a symlink to "/dev/null"
#,      (3) The kernel command line contains the "net.ifnames=0" argument
# ------------------------------------------------------------------------------
_netiface=
netiface() {
    local _bios _path _exst _mapm _ncmd _pers _rslt _oerr=':' _vnam
    local _cen_netiface_name _cen_netiface_kern
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      -)    break ;;
      --)   shift ; break ;;
      -c)   _path='/sys/class/net/' ;;
      -d)   _path='/dev/' ;;
      -e)   _oerr='error' ;;
      -i)   _mapm='i' ;;
      -k)   _mapm='k' ;;
      -n)   _ncmd=1 ;;
      -p)   _pers=1 ;;
      -s)   shift ; _vnam="$1" ;;
      -w)   _oerr='warning' ;;
      -x)   _exst=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    if [ -n "$_ncmd" ] ; then               # get cmdline status only
        _cen_net_getkcmd ; return
    fi
    if [ -z "$CEN_NET_IFNAMES" ] ; then
        _cen_net_mappers -r
        if [ -z "$CEN_NET_IFNAMES" ] ; then
            _cen_net_mapinit ; _pers=1
        fi
    fi
    if [ -n "$_pers" ] ; then               # create mapping file
        _cen_net_mappers -w || return 1
    fi

    # only ethernet and wlan names are mapped
    _cen_netiface_name="${1##*/}"
    case "$_cen_netiface_name" in
    '')         [ "$CEN_NET_IFNAMES" = 1 ] && return 0
                [ "$_mapm" != 'k' ] ; return ;;
    -)          if [ -e '/sys/class/net/br0' ] ; then
                    _cen_netiface_name='br0'
                else
                    _cen_netiface_name='eth0' ; _bios=1
                fi ;;
    eth[0-9])   _bios=1 ;;
    en*)        _bios=0 ;;
    usb[0-9])   _bios=1 ;;
    wlan[0-9])  _bios=1 ;;
    wl*)        _bios=0 ;;
    esac
    _cen_netiface_kern="$_cen_netiface_name"

    case "$CEN_NET_IFNAMES$_bios" in
    00)                                     # bios from systemd name
        if [ -n "$_mapm" ] ; then           # can't do mapping
            [ -z "$_vnam" ] && _netiface= || printf -v "$_vnam" ''
            return 1
        fi
        ;;
    10)                                     # get bios from systemd name
        [ "$_mapm" = 'i' ] && _cen_net_mapping -b
        ;;
    11)                                     # get systemd from bios name
        [ "$_mapm" = 'k' ] && _cen_net_mapping -s
        ;;
    esac

    [ "$_mapm" = 'k' ] && _rslt="$_path$_cen_netiface_kern" || _rslt="$_path$_cen_netiface_name"
    [ -z "$_vnam" ] && _netiface="$_rslt" || printf -v "$_vnam" '%s' "$_rslt"
    [ -z "$_exst" ] && return 0
    [ -n "$_cen_netiface_kern" ] && [ -e "/sys/class/net/$_cen_netiface_kern" ] && return 0
    $_oerr $"No such interface:" "$_cen_netiface_name ($_cen_netiface_kern)"
    return 1
}

# get net.ifnames status from kernel cmd line
_cen_net_getkcmd() {
    [ -n "$CEN_NET_IFKCMD" ] && return "$CEN_NET_IFKCMD"
    local _wrds _item
    read -r -a _wrds < '/proc/cmdline'
    CEN_NET_IFKCMD=2
    for _item in "${_wrds[@]}" ; do
        [ "${_item::13}" = 'net.ifnames=0' ] && CEN_NET_IFKCMD=0
        [ "${_item::13}" = 'net.ifnames=1' ] && CEN_NET_IFKCMD=1
    done
    return "$CEN_NET_IFKCMD"
}

_cen_net_maptest() {
    local _vote=1 _name
    while [ $# -gt 0 ] ; do
        _name="$1" ; shift
        [ -e "$_name" ] || continue
        case "${_name##*/}" in
        en*[su]*)   ((_vote += 1)) ;;
        wl*[su]*)   ((_vote += 1)) ;;
        end?)       ((_vote += 1)) ;;
        eth?)       ((_vote -= 1)) ;;
        wlan?)      ((_vote -= 1)) ;;
        esac
    done
    $CEN_TRACE2 -a -c "interface votes" "$_vote"
    [ "$_vote" -le 0 ]                              # return status
}

# get current map mode, set CEN_NET_IFNAMES, load rules
_cen_net_mapinit()  {
    [ -z "$CEN_NET_DOMAIN" ] && { netconfig || return 1 ; }
    [ -n "$CEN_NET_IFNAMES" ] && return

    # check for kernel net.ifnames, then try some heuristics
    if _cen_net_getkcmd ; then                      # this is mandatory
        CEN_NET_IFNAMES=0
    elif _cen_net_maptest "/sys/class/net/"[ew]* ; then
        CEN_NET_IFNAMES=0
    else
        CEN_NET_IFNAMES=1
    fi
    if [ "$CEN_NET_IFNAMES" = 0 ] ; then
        $CEN_TRACE -a -c "interface names" 'bios'
    else
        [ -n "$CEN_NET_IFACES" ] && _cen_net_maprule    # iface rules
        $CEN_TRACE -a -c "interface names" 'systemd'

        local _item _more=()
        for _item in /sys/class/net/en* ; do
            case "${_item##*/}" in
            en*u*)  [ -e "$_item" ] && _cen_net_mapiadd 'usb' "${_item##*/}" ;;
            end*)   [ -e "$_item" ] && _cen_net_mapiadd 'eth' "${_item##*/}" ;;
            *)      [ -e "$_item" ] && _more+=("$_item")
            esac
        done
        for _item in "${_more[@]}" ; do
            case "${_item##*/}" in
            en*s*) _cen_net_mapiadd 'eth' "${_item##*/}"
            esac
        done
        for _item in /sys/class/net/wlp* /sys/class/net/wl[!p]* ; do
            [ -e "$_item" ] && _cen_net_mapiadd 'wlan' "${_item##*/}"
        done
    fi
}

# handle persistancy: -r|-w
_cen_net_mappers()  {
    if [ "$1" = '-w' ] ; then
        if [ "$EUID" != 0 ] ; then
            $CEN_TRACE2 "ifnames not persisted for non-root user"
            return 0
        fi
        local _imap="${CEN_NET_IFMAP[@]@A}" ; _imap="${_imap#declare -* }"
        nettemp -w 'network_ifnames' <<!EOF
${CEN_NET_IFKCMD@A}
${CEN_NET_IFNAMES@A}
$_imap
${CEN_NET_IFIEN@A}
${CEN_NET_IFIWL@A}
${CEN_NET_IFIUS@A}
!EOF
    else
        _cen_source "$CEN_NET_DIR_RUN/network_ifnames" ; return
    fi
}

# name mapping: -b|-s <vnam> <name>
_cen_net_mapping() {
    local _vnam="$2" _mapn="$3" _item
    if [ "$1" = '-b' ] ; then
        _vnam='_cen_netiface_name' ; _mapn="$_cen_netiface_kern"
    elif [ "$1" = '-s' ] ; then
        _vnam='_cen_netiface_kern' ; _mapn="$_cen_netiface_name"
    fi

    # kernel uses bios names, do nothing
    if [ "$CEN_NET_IFNAMES" = 0 ] ; then
        printf -v "$_vnam" '%s' "$_mapn" ; return 0
    fi

    # check if mapping is cached
    for _item in "${CEN_NET_IFMAP[@]}" ; do
        [ "${_item%=*}" = "$_mapn" ] || continue
        $CEN_TRACE -a -c "mapping cached" -- "$_item"
        printf -v "$_vnam" '%s' "${_item#*=}" ; return 0
    done

    _netiface_mapname=
    if [ "$1" = '-b' ] ; then               # map to bios
        case "$_mapn" in
        enx*)   _cen_net_mapbios "$_mapn" /sys/class/net/enx* ;;
        end*)   _cen_net_mapbios "$_mapn" /sys/class/net/end* ;;
        enp*u?) _cen_net_mapbios "$_mapn" /sys/class/net/enp*u? ;;
        en*)    _cen_net_mapbios "$_mapn" /sys/class/net/enp* /sys/class/net/en[!p]* ;;
        wl*)    _cen_net_mapbios "$_mapn" /sys/class/net/wlp* /sys/class/net/wl[!p]* ;;
        esac
    elif [ "$1" = '-s' ] ; then             # map to systemd
        case "$_mapn" in
        wlan*)  _cen_net_mapsysd "$_mapn" /sys/class/net/wlp* /sys/class/net/wl[!p]* ;;
        usb*)   _cen_net_mapsysd "$_mapn" /sys/class/net/enp*u? ;;
        *)      _cen_net_mapsysd "$_mapn" /sys/class/net/enp*[!u]? /sys/class/net/en[!p]* ;;
        esac
        _cen_net_mapsysd "$_mapn"
    fi
    printf -v "$_vnam" '%s' "$_netiface_mapname" ; return 0
}

# parse CEN_NET_IFACES for mapping rules
_cen_net_maprule() {
    local _item
    CEN_NET_IFMAP=() ; set -f
    for _item in "${CEN_NET_IFACES[@]}" ; do
        set -- $_item
        case "$2" in
            $HOSTNAME)  ;;
            *[?*\[]*)   [[ "$HOSTNAME" == $2 ]] || continue ;;
            *)          continue
        esac
        [ "$3" = '-' ] && break                 # stop rule
        if [ "${3/:/}" != "$3" ] ; then         # mac rule
            warning -c $"not implemented" -- "iface $_item"
            continue
        fi
        _cen_net_mapiadd "$1" "$3"
    done ; set +f
    $CEN_TRACE -a -c "mapping iface" -- "${#CEN_NET_IFMAP[@]} rule(s)"
}

# map to bios name: <sysd> <candidate>...
_netiface_mapname=
_cen_net_mapbios() {
    local _mapn="$1" _item _bios _indx=0 _kern _kind='eth'
    [ "${_mapn::2}" = 'wl' ] && _kind='wlan'
    $CEN_TRACE2 -a -c "mapping bios" -- "$*"

    # loop over interfaces and add bios name to cache
    while [ $# -gt 1 ] ; do
        shift
        [ -e "$1" ] || continue
        _kern="${1##*/}"
        _cen_net_mapiadd "$_mapn" "$_kern" _netiface_mapname && return
    done
    _netiface_mapname=
}

# map to systemd name: <bios> <candidate>...
_cen_net_mapsysd() {
    $CEN_TRACE2 -a -c "mapping systemd" -- "$*"
    local _mapn="$1" _item _kern

    while [ $# -gt 1 ] ; do
        shift
        [ -e "$1" ] || continue
        _kern="${1##*/}"
        if _cen_net_mapiadd "$_mapn" "$_kern" ; then
            _netiface_mapname="$_kern" ; return
        fi
    done

    # interface not registered
    [ -e "/sys/class/net/$_mapn" ] && _netiface_mapname="$_mapn" : _netiface_mapname=
}

# Add to list of known interfaces: <bios> <sysd> [<vbio>]
# This function always makes two entries:  <bios>=<sysd>  and  <sysd>=<bios>
_cen_net_mapiadd() {
    local _bios="$1" _sysd="$2" _entr _incr
    case "$_bios" in
    eth)    _bios+="$CEN_NET_IFIEN" ; _incr=1 ;;
    wlan)   _bios+="$CEN_NET_IFIWL" ; _incr=2 ;;
    en*)    _bios="eth$CEN_NET_IFIEN" ; _incr=1 ;;
    wl*)    _bios="wlan$CEN_NET_IFIWL" ; _incr=2 ;;
    us*)    _bios="usb$CEN_NET_IFIUS" ; _incr=3 ;;
    esac
    [ -n "$3" ] && printf -v "$3" '%s' "$_bios"

    for _entr in "${CEN_NET_IFMAP[@]}" ; do
        _entr="${_entr%=*}"
        [ "$_entr" = "$_bios" ] && return 1
        [ "$_entr" = "$_sysd" ] && return 1
    done

    if [ "$_incr" = 1 ] ; then                  # increment next index
        ((CEN_NET_IFIEN += 1))
    elif [ "$_incr" = 2 ] ; then
        ((CEN_NET_IFIWL += 1))
    elif [ "$_incr" = 3 ] ; then
        ((CEN_NET_IFIUSS += 1))
    fi
    $CEN_TRACE -a -c "mappings added" -- "$_bios" "$_sysd"
    CEN_NET_IFMAP+=("$_bios=$_sysd" "$_sysd=$_bios") ; return 0
}

# ------------------------------------------------------------------------------
# netindex - Get index of (sub-)network by network name
#
# Call:    (1) netindex [-e|-f] [-s <vnet>] <name>      # get by name
#          (2) netindex [-e|-f] [-s <vnet>] <indx>      # get by index
#          (3) netindex [-e|-f] [-s <vnet>] <ipv4>      # get index from address
#
# Options:  -e  error if network not found
#           -f  fatal error if network not found
#           -s  save network entry to named variable
#
# Arguments:<name>  network name, see below
#           <indx>  index to CEN_NET_NETWORKS array
#           <vnet>  name of a variable to get CEN_NET_NETWORKS data
#
# Return:  **true** if an entry was found or **false** on failure
#
#          The **_netindex** variable is set on success or cleared on failure.
#          If present <vnet> is set to the corresponding CEN_NET_NETWORKS entry.
#
# Networks: This function handles the domain network and 7 sub-nets. Names and
#          indexes are hard-coded in the function but nowhere else.
#
#          domain   0: whole IPv4 address range (all subnets)
#          iot      1: non-trusted address range for gadgets
#          trusted  2: trusted address range
#          guest    3: less-trusted address range
#          dynamic  4: addresses assigned by DHCP to unknown MAC addresses
#          repeater 5: used by repeater NAT subnet
#          vpn      6: used by VPN
#          other    7: not used by centauri, user defined
#
#+CEN_NET_NETWORKS and so this function use IPv4 addresses. IPv6 addressing is
# handled by dynamically generating local ULA IPv6 addresses, see [[netconv()]].
# ------------------------------------------------------------------------------
_netindex=
netindex() {
    local _ferr=':' _ssav
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)    shift ; break ;;
      -e)    _ferr='error' ;;
      -f)    _ferr='fatal' ;;
      -s)    shift ; _ssav="$1" ;;
      *)     _cen_abort - "$1"
      esac ; shift
    done

    case "$1" in
    dom*)   _netindex=0 ;;
    iot)    _netindex=1 ;;
    tru*)   _netindex=2 ;;
    gue*)   _netindex=3 ;;
    dyn*)   _netindex=4 ;;
    rep*)   _netindex=5 ;;
    vpn)    _netindex=6 ;;
    oth*)   _netindex=7 ;;          # external network

    [0-7])  _netindex="$1" ;;

    [0-9]*.[0-9]*.[0-9]*.[0-9]*)
            _netindex=7
            while ! netmask "${CEN_NET_NETWORKS[_netindex]}" "$1" ; do
                ((_netindex -= 1))
                [ "$_netindex" -ge 0 ] && continue
                _netindex= ; $_ferr $"Address not in a valid sub-net:" "$1" ; return 1
            done
            ;;

    *)      [ -n "$_ssav" ] && printf -v "$_ssav" ''
            _netindex= ; $_ferr $"No corresponding network:" "$1" ; return 1
    esac

    [ -n "$_ssav" ] && printf -v "$_ssav" '%s' "${CEN_NET_NETWORKS[_netindex]}"
    return 0
}

# ------------------------------------------------------------------------------
# netmask - check if address is part of a sub-net
#
# Call:    (1) netmask [-e|-f] [-a] <base>/<bits>        # is base address valid?
#          (2) netmask [-e|-f] [-a] <base>/<bits> <addr> # is <addr> in base net?
#
# Options:  -a  accept invalid netmask
#           -e  report syntax errors
#           -f  make syntax errors fatal
#
# Arguments:<base>  sub-net base address
#           <bits>  mask bits of sub-net
#           <addr>  address to be checked
#
# Return:  **0**   success
#          **1**   general synstax failure
#          **2**   invalid network mask
#
#+This function internally calls [[netparse()]] and [[netconv()]].
# ------------------------------------------------------------------------------
_netmask_addr=                          # current binary address
_netmask_curr=                          # current argument
_netmask_mask=                          # mask high bits
netmask() {
    local _oerr _oain
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)       shift ; break ;;
      -a)       _oain=1 ;;
      -e|-f)    _oerr="$1" ;;
      *)        _cen_abort - "$1"
      esac ; shift
    done
    [ "${1:--}" = '-' ] && return 1

    if [ "$1" != "$_netmask_curr" ] ; then      # update cache
        _netmask_curr="$1" ; _netmask_addr=
        netparse -a -b $_oerr -n "$1" || return 1
        _netmask_mask="$((-1 << (32 - _netparse_bits)))"
        netconv -b "$_netparse_addr" || return 1
        _netmask_addr="$_netconv"
        $CEN_TRACE2 -a -c -p " cache" "%-14s -> %x %x" "$1" "$_netmask_addr" "$_netmask_mask"
    elif [ -z "$_netmask_addr" ] ; then
        return 1                                # not a valid address
    fi

    if [ "${2:--}" = '-' ] ; then               # check for valid subnet
        [ -n "$_oain" ] && return 0
        [ $((_netmask_addr & ~_netmask_mask)) = 0 ] && return 0
        [ -n "$_oerr" ] && error $_oerr $"Invalid sub-net specification:" "$1"
        return 2
    fi

    netparse -a $_oerr -n "$2" || return 1
    netconv -b "$_netparse_addr" || return 1
    $CEN_TRACE2 -a -c -p " check" "%-14s -> %x" "$2" "$_netconv"
    [ $((_netconv & _netmask_mask)) = "$_netmask_addr" ]
    return                                       # return status
}

# ------------------------------------------------------------------------------
# netoption - Search an option network configuration entry
#
# Call:    netoption <option> <host>    # check option for given host
#          netoption <option> [-]       # return hosts with given option
#
# Options:  -n  disable globbing
#           -x  do not match '*' (e.g. the fallback default)
#
# Arguments:<option>   name of the config option to be searched
#           <host>     a local host name (NOT fully qualified), matching supports
#                      bash globbing unless option -n is used
#
# Return:  **true** if an entry was found or **false** on failure
#
#          The **_netoption** array is set on success or cleared on failure.
#
#.Examples:# get list of entries for an option into _netoption
#.         netoption "auto" &&
#.             message "Option 'auto' set for:" "${_netoption[*]}"
#
#.         # single option check
#.         netoption "ipv6" "alpha1" &&
#.             message "Option 'ipv6' applies for 'alpha1'"
#
#.         # find multiple options for host, using a default
#.         local nopt nmod="tracking"
#.         for nopt in "tracking" "simple" "nofirewall" ; do
#.             netoption "$nopt" "$HOSTNAME" || continue
#.             nmod="$nopt"
#.             [ "$_netoption" = "*" ] || break
#.         done
#.         message "Option '$nmod' applies for '$HOSTNAME'"
# ------------------------------------------------------------------------------
_netoption=()
netoption() {
    local _dflt _glob='[\*\?\]]'                    # trigger for globbing
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -n)   _glob= ;;
      -x)   _dflt='*' ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    netconfig || return 1

    local _opts _name="${2:--}"
    for _opts in "${CEN_NET_OPTIONS[@]}" ; do       # loop over options
        [ "${_opts%% *}" = "$1" ] || continue
        set -f ; set -- $_opts ; set +f ; shift     # set list of hosts
        _netoption=("$@") ; [ "$_name" = '-' ] && return 0
        for _opts in "$@" ; do                      # loop over hosts list
            [ "$_opts" = "$_dflt" ] && continue
            [ "$_opts" = "$_name" ] && return 0     # literal match
            [ "${_opts/$_glob/}" = "$_opts" ] && continue
            [[ "$_name" == $_opts ]] && return 0    # glob match
        done ; break
    done
    _netoption=() ;  return 1
}

# ------------------------------------------------------------------------------
# netparse - Parse an IPv4 address and/or netmask
#
# Call:     netparse [-a] [-b] [-e|-f] [-n] [-r] [<ipaddr>][/<maskbits>]
#           netparse [-b] [-e|-f] [-n] [-r] <maskbits>
#
# Options:  -a  address must be present
#           -b  netmask bits must be present
#           -e  report errors
#           -f  make errors fatal
#           -n  do not fill _netparse_mask, just clear it
#           -r  check min/max of mask bits (minimum is 16, maximum is 21)
#               also check network address class if <ipaddr> is passed
#
# Arguments:<ipaddr>   a dotted 4-part IPv4 address -or- a network reference
#           <maskbits> number of maskbit as decimal number
#
# Return:   **true** if an entry was found or **false** on failure
#
#           **_netparse_addr** is set to the IPv4 address
#           **_netparse_bits** is set to the number of netmask bits
#           **_netparse_mask** is set to the dotted netmask
#
#.Reference:An <ipaddr> can be a network reference with a one or two byte
#           offset: **<**<n>**>**<high>**.**<low> -or- **<**<n>**>**<low>
#
#           <n>         index to CEN_NET_NETWORKS array or a sub-network name
#                       see: [[netindex()]]
#           <high>      get added to the 3rd reference address byte
#           <low>       get added to the 4th reference address byte
#
#.Examples. # Parsng IP adresses
#.          netparse 10.21.2.0/22
#.          message "Addr: $_netparse_addr $_netparse_mask"
#
#.          # Network references
#.          netparse <2>1.100/22        # add to sub-network #2
#.          netparse <vpn>10/22         # add to sub-network 'vpn'
#
#.          # Get a netmask
#           netparse 22
#.          message "Mask: $_netparse_mask"
# ------------------------------------------------------------------------------
_netparse_addr=
_netparse_bits=
_netparse_mask=
netparse() {
    local _oadr _obit _aadd _oerr=':' _onom
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _oadr=1 ;;
      -b)   _obit=1 ;;
      -e)   _oerr='error' ;;
      -f)   _oerr='fatal' ;;
      -n)   _onom=1 ;;
      -r)   _orng=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # replace network name (pre-check with glob for speed)
    if [[ "$1" == *\<[a-z]* ]] ; then
        if [[ "$1" =~ (.*<)([a-z].*)(>.*) ]] ; then
            if ! netindex "${BASH_REMATCH[2]}" ; then
                $_oerr $"Invalid network name:" "$1"
                _netparse_addr= ; _netparse_bits= ; return 2
            fi
            set -- "${BASH_REMATCH[1]}$_netindex${BASH_REMATCH[3]}"
        fi
    fi

    # syntax check for bad characters
    _aadd="${1#<[0-9]>}"
    if [ -n "${_aadd//[0-9.\/]/}" ] ; then
        $_oerr $"Address contains invalid characters:" "$1"
        _netparse_addr= ; _netparse_bits= ; return 3
    fi

    # argument variants ...
    if [ -n "$_obit" -a "${1%/*}" = "$1" ] ; then
        $_oerr $"Address needs netmask bits:" "$1" ; return 4
    elif ! _cen_net_addrget "$1" ; then
        $_oerr $"Address has invalid syntax:" "$1" ; return 5
    fi

    # check bitmask limits and network class
    if [ -n "$_orng" -a -n "$_netparse_bits" ] ; then
        local _mmin=0
        case "$1" in
        192.168.*)  _mmin=16 ;;
        172.16.[0-9].*|172.16.1[0-5].*)
                    _mmin=20 ;;
        10.*)       _mmin=16
        esac
        if [ "$_mmin" = 0 ] ; then
            warning -p $"Address '%s' is in a public IPv4 range"
        elif [ "$_netparse_bits" -gt 21 ] ; then
            $_oerr -p $"Netmask is too long (max %s): %s" 21 "$1" ; return 6
        elif [ "$_netparse_bits" -lt "$_mmin" ] ; then
            $_oerr -p $"Netmask is too short (min %s): %s" "$_mmin" "$1" ; return 7
        fi
    fi

    # make netmask
    if [ -n "$_onom" ] ; then
        _netparse_mask=
    elif netconv -d $((((1 << 32) - 1) & ~((1 << (32 - _netparse_bits)) - 1))) ; then
        _netparse_mask="$_netconv"
    else
        _netparse_mask='0.0.0.0' ; return 8
    fi
    return 0
}

# add ip addr fields (no overflow): <bhig> <blow>
_cen_net_addradd() {
    [ "${_netparse_addr:-/}" = '/' ] && return 1
    local bhig="${1:-0}" blow="${2:-0}"
    set -- ${_netparse_addr//[.\/]/ }
    ((bhig += $3)) ; [ "$bhig" -gt 255 ] && return 1
    ((blow += $4)) ; [ "$blow" -gt 255 ] && return 1
    _netparse_addr="$1.$2.$bhig.$blow"
    [ -n "$5" ] && _netparse_bits="$5"
    return 0
}

# parse address variants
_cen_net_addrget() {
    _netparse_mask= ; _netparse_bits=
    case "$1" in
    [0-9]*.[0-9]*.[0-9]*.[0-9]*/[0-9]*)
                _netparse_addr="${1%%/*}" ; _netparse_bits="${1##*/}" ;;
    [0-9]*.[0-9]*.[0-9]*.[0-9]*)
                _netparse_addr="$1"
                [ -z "$_obit" ] ; return ;;                 # return status
    /[0-9]|/[0-9][0-9]|[0-9]|[0-9][0-9])
                _netparse_addr=     ; _netparse_bits="${1##*/}"
                [ -z "$_oadr" ] || return 1 ;;
    \<[0-9]\>[0-9]*.[0-9]*)
                _netparse_addr="${CEN_NET_NETWORKS[${1:1:1}]}"
                _aadd="${1:3}" ; _aadd="${_aadd%/*}"
                _cen_net_addradd "${_aadd%.*}" "${_aadd#*.}" || return 1
                _aadd="${1##*/}"
                [ "$_aadd" != "$1" ] && _netparse_bits="$_aadd" ;;
    \<[0-9]\>[0-9]*)
                _netparse_addr="${CEN_NET_NETWORKS[${1:1:1}]}"
                _aadd="${1:3}" ; _aadd="${_aadd%/*}"
                _cen_net_addradd 0 "$_aadd" || return 1
                _aadd="${1##*/}"
                [ "$_aadd" != "$1" ] && _netparse_bits="$_aadd" ;;
    \<[0-9]\>)
                _aadd="${CEN_NET_NETWORKS[${1:1:1}]}"
                _netparse_addr="${_aadd%%/*}" ; _netparse_bits="${_aadd##*/}"
                [ -z "$_obit" ] || return 1
                [ -n "$_netparse_addr" ] ; return ;;        # return status
    \<[0-9]\>/[0-9]*)
                _aadd="${CEN_NET_NETWORKS[${1:1:1}]}"
                _netparse_addr="${_aadd%%/*}" ; _netparse_bits="${1##*/}"
                [ -n "$_netparse_addr" ] || return 1 ;;
    *)
                _netparse_addr= ; return 1 ;;
    esac
    return 0
}

# ------------------------------------------------------------------------------
# nettemp - Temporary file operations in transient data folder
#
# Call:     nettemp [-r|-s|-w]  [<file>|-]
#           nettemp [-c|--]     [<file>|-]
#           nettemp -l <target> [<file>|-]
#
# Options:  -c  create a file (default name is $CEN_NAME)
#           -l  create and link a temp file to <target>
#           -r  remove temp file
#           -s  source the file
#           -w  create and write temp file (see netfile -h)
#           --  (default) check if temp file exists
#
# Arguments:<file>   a local file name (NOT containing **/**)
#           <target> link target (<file> is the link-name)
#
# Return:   **true** if an entry was found or **false** on failure
#
#           The **_nettemp** variable is set on success or cleared on failure.
#
# Storage:  CEN_NET_DIR_RUN contains the base path for all operations.
#
# The function tries to create a missing transient data folder.
# ------------------------------------------------------------------------------
_nettemp=
nettemp() {
    # create/check temp dir
    _nettemp="$CEN_NET_DIR_RUN"
    if [ ! -d "$_nettemp" ] ; then
        [ -h "$_nettemp" ] && system -f -p -b -s _nettemp realpath "$_nettemp"
        folder -m -f "$_nettemp"
    fi

    # option and arguments
    local _lopt
    if [ "${1::1}" = '-' -a "$1" != '-' ] ; then
        _lopt=$1 ; shift
    fi
    local _arg1="${1:--}" _arg2="${2:--}" _argp="$_nettemp"
    [ "$_arg1" = '-' ] && _arg1="${CEN_NAME:-$0}"
    [ "$_arg1" != '.' ] && _argp+="/$_arg1"

    case "$_lopt" in
    ''|--)                                      # make name, return status
                _nettemp="$_argp" ; [ -e "$_argp" ] ;;
    -c)                                         # create file, warn on failure
                _nettemp="$_argp" ; create -w "$_argp" 664 ;;
    -l)                                         # create link
                [ "$_arg2" = '-' ] && _arg2="${CEN_NAME:-$0}"
                _cen_net_symlink "$_arg1" "$_nettemp/$_arg2"
                ;;
    -r)                                         # remove file
                _cen_net_remove "$_argp" ;;
    -s)                                         # source file
                _nettemp="$_argp" ; _cen_source "$_argp" ;;
    -w)                                         # write file
                _nettemp="$_argp" ; netfile -h "$_argp" ;;
    *)                                          # error
                _cen_abort - "$_lopt" ;;
    esac
}

# ------------------------------------------------------------------------------
# helpers that use builtins if they can be loaded
# ------------------------------------------------------------------------------
_cen_net_symlink() {
    system -e -p -b -- ln -s -f -- "$1" "$2"
}

_cen_net_remove() {
    if [ $# -gt 1 ] || [ -e "$1" ] ; then
        system -e -p -b -- rm -f -- "$@"
    fi
}

# ------------------------------------------------------------------------------
# netlink - Make a symlink to a config file or folder
#
# Call:     netlink [-k|-m|-n|-s]... <link> <sepa> <suff>...
#
# Options:  -k  keep current link if no destination found
#           -m  if link is a file move it to <link>.$CEN_NAME
#           -n  no operation, just get matching suffix
#           -s  do not generate messages
#
# Arguments:<link>  link destination, use <link><sepa><suff> as target
#           <sepa>  separator in target name
#           <suff>  a target suffix to use
#
# Return:   0 := OK   1 := no target   2 := link is a file
#           _netlink       set only if link is updated
#           _netlink_suff  set if suffix was found
#
#.Example:  netlink -k -m /etc/hosts _ local alpha1 alpha2
#
# The function tries several suffixes to find an existing link target.
# ------------------------------------------------------------------------------
_netlink=                       # set only if link is updated
_netlink_suff=                  # set if suffix was found
netlink() {
    local keep move noop slnt
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -k)   keep=1 ;;
      -m)   move=1 ;;
      -n)   noop=1 ;;
      -s)   slnt=1 ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done
    [ -n "$CEN_NET_OUTPUT" ] && fatal $"Alternate output not supported:" 'netlink'

    local suff dest link="$1" sepa="${2:-.}"
    shift ; shift
    _netlink= ; _netlink_suff=

    # <link> exists and is not a link
    if [ -e "$link" -a ! -h "$link" -a -z "$noop" ] ; then
        if [ -z "$move" ] ; then
            [ -z "$slnt" ] && error $"Not a symlink:" "$link"
            return 2
        fi
        dest="$link$sepa$CEN_NAME"
        system -e -p -- mv -f "$link" "$dest"
        [ -n "$keep" ] && _cen_net_symlink "$dest" "$link"
        [ -z "$slnt" ] && warning -a $"Renamed file:" "$link => $dest"
    fi
    [ $# = 0 ] && return 0              # moveaway or check only

    # search suffix and link
    for suff in "$@" ; do
        [ -n "$suff" ] || continue
        _netlink_suff="$suff" ; dest="$link$sepa$suff"
        [ -e "$dest" ] || continue
        [ -n "$noop" ] && return 0
        if [ "$link" -ef "$dest" ] ; then
            [ -z "$slnt" ] && $CEN_TRACE -a -c $"Link current" "$link => $dest"
            return 0
        fi
        [ -z "$slnt" ] && $CEN_TRACE -a -c $"Link updated" "$link => $dest"
        _netlink="$dest"
        if [ -d "$dest" ] && [ -h "$link" ] ; then      # linking a folder
            _cen_net_remove "$link"                     # ... no symlink!
        fi
        _cen_net_symlink "${dest##*/}" "$link" ; return 0
    done

    [ -n "$noop" ] && return 1
    [ -z "$slnt" ] && $CEN_TRACE -a -c $"Found no target" "$link"
    [ -n "$keep" ] || _cen_net_remove "$link"
    return 1
}

# ------------------------------------------------------------------------------
# netfile - Write a config file (respecting CEN_NET_OUTPUT rules)
#
# Call:     netfile [-h] [-v <vari>] [--] <path> [<mode>]
#
#           The function uses [[netpath()]] internally, see CEN_NET_OUTPUT.
#
# Options:  -h       write a header
#           -v       input from variable (or array) instead of stdin
#
# Arguments:<path>    (relative) file path, see below
#           <mode>    file mode, default is 664
#
# Return:   **true** on success or **false** on failure
#
#.Example:  netfile <<!EOF -h xxx     # option -h: write header/footer
#.          blabla
#.          !EOF
#
# The variable CEN_NET_OUTPUT overrides/modifies the <path> argument:
#
#           CEN_NET_OUTPUT='-'        # write to stdout
#           CEN_NET_OUTPUT="."        # use ./<path>
#           CEN_NET_OUTPUT=<folder>   # (debug) create files in <folder>
# ------------------------------------------------------------------------------
netfile() {
    local _opts= _cflg=' -c'
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)    shift ; break ;;
      -h)    _opts+=' -h -' ; _cflg= ;;
      -v)    shift ; _opts+=" -v $1" ; _cflg= ;;
      *)     _cen_abort - "$1"
      esac ; shift
    done
    _opts+="$_cflg"

    if ! netpath "$1" ; then                    # write to /dev/stdout
        create $_opts -o -w -- "$1" ; return
    fi

    # we must have a valid base folder to create a file
    local _hout="$_netpath" _hmod="${2:-664}"
    if [ "${_hout/\//}" != "$_hout" ] && [ ! -d "${_hout%/*}" ] ; then
        $CEN_TRACE -c $"No base folder" -- "$_hout"
        return 1
    fi

    create $_opts -t -w -- "$_hout" "$_hmod"    # create, warning on failure
}

# ------------------------------------------------------------------------------
# netpath - Get a path (respecting CEN_NET_OUTPUT rules)
#
# Call:     (1) netpath [--] <path>                 # get file path
#           (2) netpath -d [--] <base> [<suffix>]   # get folder path
#
# Options:  -d       check if <base> exists
#
# Arguments:<path>   (relative) file path, see below
#           <base>   (relative) folder path, see below
#           <suffix> optional folder suffix (only used if folder exists)
#
# Return:   **true** for file output or **false** for output to /dev/stdout
#
#          The **_netpath** variable is set to the generated path.
#
# The variable CEN_NET_OUTPUT overrides/modifies the <path> argument:
#
#           CEN_NET_OUTPUT='-'        # write to stdout
#           CEN_NET_OUTPUT="."        # use ./<path>
#           CEN_NET_OUTPUT=<folder>   # (debug) create files in <folder>
# ------------------------------------------------------------------------------
_netpath=
netpath() {
    local _optd
    if [ "$1" = '-d' ] ; then
        _optd=1 ; shift
    fi
    [ "$1" = '--' ] && shift

    if [ -z "$CEN_NET_OUTPUT" ] ; then
        _netpath="$1"
    elif [ "$CEN_NET_OUTPUT" = '-' ] ; then
        _netpath=
        [ -n "$_optd" ] && return 0 ; return 1
    elif [ "$CEN_NET_OUTPUT" = '.' ] ; then
        _netpath="./${1#/}" ; _netpath="${_netpath//\/.\//\/}"  # /./ => /
    else
        _netpath="${CEN_NET_OUTPUT%/}/${1##*/}"
        [ -n "$_optd" ] && return 0
    fi
    [ -z "$_optd" ] && return 0                 # no folder check

    [ -d "$_netpath" ] || return 1              # folder not found
    [ -z "$2" ] && return 0                     # no suffix
    [ -d "$_netpath$2" ] || return 0            # no suffixed folder
    _netpath+="$2" ; return 0
}

# ------------------------------------------------------------------------------
# netproxy - Save/load proxy status (http_proxy and no_proxy variables)
#
# Call:     (1) netproxy                        # load proxy config
#           (2) netproxy -t                     # test proxy connection
#           (3) netproxy [-w <server> [-p <http>[:<https>]] ] [-s <wpad>]
#
# Options:  -a  always assume that "option proxy" is set in centaurinetcfg
#           -p  ports to use (overrides defaults)
#           -s  create "wpad.dat" PAC script
#           -t  test if upstream proxy can be reached
#           -w  save proxy file (default is to load)
#
# Arguments:<server> hostname of server, "-" for none, "+" for auto-detect
#           <http>   port for http proxy  (default: $CEN_NET_PORT_HTTP)
#           <https>  port for https proxy (not used internally)
#           <wpad>   script path, "-" for "/var/www/html/wpad.dat"
#
# Return:   **true** on success or **false** on failure
#
#+Tinyproxy:From an existing "/etc/tinyproxy/tinyproxy.conf.template" file a
#           configuration for tinyproxy will be generated. This includes the
#           current 'upstream' definitions for the active server.
#
# Storage:  CEN_NET_FILE_PROX="$CEN_NET_DIR_RUN/network_proxy"
#
#+          This file contains variables describing the current proxy and should
#           be sourced by login-shells:
#
#,          - **http_proxy**        upstream proxy or local tinyproxy
#,          - **https_proxy**       ... for https
#,          - **no_proxy**          patterns for proxy bypass
#,          - **http_upstream**     upstream proxy (if any)
#,          - **https_upstream**    ... for https
#
#+This function is called by [[netserver()]] when the actual server is set or
# changed. This will update the "network_proxy" file and the "tinyproxy" config.
# The actual server must have "option proxy" set to be used as proxy, use call
# option -a to override this check.
#
#+The tool "tinyproxy" is a minimalistic proxy implementation that a client
# computer may use as an intermediate abstraction layer. All software that
# uses a proxy can be statically configured to use "tinyproxy".
#
#+If a local "tinyproxy" is running, an upstream proxy is added to its config
# and the "network_proxy" variables "http_proxy" and "https_proxy" refer to the
# local "tinyproxy" instance.
#
#+The "tinyproxy.conf.template" file is a standard configuration where a line
# containing just the word "@UPSTREAM" gets replaced with upstream proxy info.
# ------------------------------------------------------------------------------
netproxy() {
    local _oall _owrt _opad _oprt _otes
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)   shift ; break ;;
      -a)   _oall=1 ;;
      -p)   shift ; _oprt="$1" ;;
      -s)   shift ; _opad="$1" ;;
      -t)   _otes=1 ;;
      -w)   shift ; _owrt="$1" ;;
      *)    _cen_abort - "$1"
      esac ; shift
    done

    # read the file
    if [ -z "$_owrt$_otes" ] ; then
        _cen_source "$CEN_NET_FILE_PROX" || return 1
        [ -z "$_opad" ] && return
    fi

### TODO http_upstream

    # test if proxy can be reached
    if [ -n "$_otes" ] ; then
        #if echo 2>/dev/null >"/dev/tcp/$qual/$port" ; then
        if [ -z "$http_proxy" ] ; then
            _cen_source "$CEN_NET_FILE_PROX" || return 1
        fi
         [ -z "$http_proxy" ] && return 1
        _otes="${http_proxy#http:/}" ; _otes="${_otes//:/\/}"
        echo 2>/dev/null >"/dev/tcp$_otes" ; return     # return status
    fi

    # read configuration, get ports
    netconfig
    [ -n "$_oprt" ] && splitkeyval "$_oprt" CEN_NET_PORT_HTTP CEN_NET_PORT_HTTPS ':'
    : ${CEN_NET_PORT_HTTPS:=$CEN_NET_PORT_HTTP}

    # get 'option proxy' of '$serv'
    _cen_net_proxy() {
        local nsrv
        for nsrv in "${CEN_NET_OPTIONS[@]}" ; do
            [ "${nsrv%% *}" = 'proxy' ] || continue
            for nsrv in ${nsrv#* } ; do
                [[ "$serv" == $nsrv ]] || continue
                _oall=1 ; return
            done
            return
        done
    }

    if [ "$_owrt" = '+' ] ; then                        # auto config
        _owrt="$HOSTNAME.$CEN_NET_DOMAIN" ; _oall=1
        if ! echo 2>/dev/null >"/dev/tcp/$_owrt/$CEN_NET_PORT_HTTPS" ; then
            _owrt="$CEN_NET_SERVER_GEN.$CEN_NET_DOMAIN"
            if ! echo 2>/dev/null >"/dev/tcp/$_owrt/$CEN_NET_PORT_HTTPS" ; then
                _oall= ; _owrt=
            fi
        fi
    elif [ "$_owrt" = '-' ] ; then                      # disable upstream proxy
        _owrt=
    fi
    local serv="${_owrt%%.*}" nprx

    # does master name match an "option proxy ..." argument?
    [ -n "$serv" -a -z "$_oall" ] && _cen_net_proxy
    if [ -z "$_oall" ] ; then
        netfile -h <<!EOF "$CEN_NET_FILE_PROX"
# no proxy server
!EOF
    else
        # generate proxy variables
        nprx="$CEN_NET_DOMAIN,*.$CEN_NET_DOMAIN,.$CEN_NET_DOMAIN"
        for nnam in "${CEN_NET_SERVERS[@]}" ; do
            nprx+=",$nnam"
        done

        # write a new proxy file
        netfile -h <<!EOF "$CEN_NET_FILE_PROX"
http_proxy="http://$serv.${CEN_NET_DOMAIN}:$CEN_NET_PORT_HTTP"
https_proxy="http://$serv.${CEN_NET_DOMAIN}:$CEN_NET_PORT_HTTPS"
no_proxy="$nprx"
export http_proxy
export https_proxy
export no_proxy
!EOF
    fi

    # configure tinyproxy
    local tiny='/etc/tinyproxy/tinyproxy.conf'
    local tdef="$tiny.template"
    if [ -d "${tiny%/*}" ] && [ -f "$tdef" ] ; then
        local tcfg tgen=()
        if mapfile -t tcfg 2>/dev/null <"$tdef" ; then
            for line in "${tcfg[@]}" ; do
                case "$line" in
                '')     ;;
                \#*)    ;;
                @PORT)  tgen+=("Port $CEN_NET_PORT_HTTP")
                        ;;
                @UPSTREAM)
                        [ -n "$nprx" ] && tgen+=(
                            "Upstream http $serv.$CEN_NET_DOMAIN:$CEN_NET_PORT_HTTP"
                            "Upstream none \".$CEN_NET_DOMAIN\""
                            "Upstream none \"$CEN_NET_NETWORKS\""
                            "Upstream none \"$CEN_NET_PREFIX_IP6\""
                            "Upstream none \".\""
                        )
                        ;;
                *)      tgen+=("$line")
                esac
            done
            netfile -h -v tgen "$tiny"
        fi
    fi

    # write PAC script
    [ "$_opad" = '-' ] && _opad='/var/www/html/wpad.dat'
    if [ -n "$_opad" ] && [ -d "${_opad%/*}" ] ; then
        [ -z "$serv" ] && serv="$HOSTNAME"
        $CEN_TRACE -c "PAC Script" "$_opad" "$serv"
        local _wpad=(
            'function FindProxyForURL(url, host) {'
            '    if ( url.substring(0, 5) != "http:" )'
            '        return "DIRECT";'
            '    if ( isPlainHostName(host) ||'
            "         dnsDomainIs(host, \".$CEN_NET_DOMAIN\") ||"
            "         isInNet(host, \"$CEN_NET_NETWORKS\", \"$CEN_NET_NETMASK\") )"
            '           return "DIRECT";'
            '    }'
            '    else {'
            "        return \"PROXY $serv.$CEN_NET_DOMAIN:$CEN_NET_PORT_HTTP; DIRECT\";"
            '    }'
            '}'
        )
        netfile -v _wpad "$_opad"
    fi
    return 0
}

# ------------------------------------------------------------------------------
# get trusted dns server: <vnam>
# ------------------------------------------------------------------------------
_cen_net_homedns() {
    # are we server?
    if [ "$HOSTNAME" = "${CEN_NET_SERVERS[0]}" ] ; then
        printf -v "$1" '%s' "${CEN_NET_SERVERS[0]}" ; return 0
    elif [ "$HOSTNAME" = "${CEN_NET_SERVERS[1]}" ] ; then
        printf -v "$1" '%s' "${CEN_NET_SERVERS[1]}" ; return 0
    fi

    netresolv -r                        # read resolv.conf into netresolv
    if [ -z "$_netresolv" -o -z "${_netresolv[1]}" ] ; then
        printf -v "$1" 'localhost' ; return 0
    fi

    # loop over homedns entries in config
    local _item _hkey _vnam="$1"
    for _item in "${CEN_NET_HOMEDNS[@]}" ; do
        set -- $_item ; set +f
        [ "$1" != '-' -a "$1" != "$_netresolv" ] && continue        # filter by domain
        [ "$2" != '-' -a "$2" != "${_netresolv[1]}" ] && continue   # filter by ip
        printf -v "$_vnam" '%s' "$3" ; return 0
    done
    return 1
}

# ------------------------------------------------------------------------------
# netquery - Get selected network information
#
# Call:     (1) netquery [-e|-f] [-q] [-r] [-s <vnam>] <keyword>
#           (2) netquery [-e|-f] [-q] [-r] [-s <vnam>] <keyword> [<host>]
#
# Options:  -e  error if config file not found
#           -f  fatal error if config file not found
#           -q  return qualifed names (or nm|simple for 'connect')
#           -r  discard cache, reload data
#           -s  save result to named variable
#
# Arguments:<keyword>     select information to be returned, see below
#           <vnam>        save a hostname to this variable
#
# Keywords: PRIMARY       get PRIMARY server name, return true if on PRIMARY
#           SECONDARY     get SECONDARY ...
#           WORKSTATION   get MASTER's name, return true if role is WORKSTATION
#
#           MASTER        get current MASTER's name, return true if on MASTER
#           SLAVE         get current SLAVE's name, return true if on SLAVE
#           CLIENT        get MASTER's name, return true if mode is CLIENT
#           GUEST         get MASTER's name, return true if mode is GUEST
#           SINGLE        return true if mode is SINGLE
#           UNKNOWN       return true if mode is UNKNOWN
#
#           domain        get domain name, return true if CLIENT|MASTER|SLAVE (not GUEST)
#           router        get generic router name
#           primary       get primary server name
#           secondary     get secondary server name
#           current       get current server name
#           homedns       get trusted dns server name
#
#           nm            get NetworkManager config folder, return true if installed
#
#           connect       [*] get connection management mechanics
#           class         [*] get device class
#           server        [*] get generic server name, return true if on a server
#
#           [*] Form (2) calls can have a <host> argement. If missing HOSTNAME is used.
#
#+The result for uppercase keywords is based on the dynamic CEN_NET_ROLE, and
# **NOT** the static configuration data. Lowercase keywords return static data.
#
#+The function calls [[netserver()]] if CEN_NET_ROLE is not yet set. To refresh
# the loaded information, [[netserver()]] must be called explicitly. It always
# calls [[netconfig()]]. So after a call to [[netquery()]] all CEN_NET_XXX state
# and configuration variables are set.
#
#+connect:  depending on centaurinetcfg option settings one of the following is returned:
#
#           auto          uses 'smart' if nm is installed or 'simple' otherwise
#           manual        not managed by centaurinetcfg/centauriswitch
#           nm            uses NetworkManager
#           simple        uses DHCP
#           static        uses neither NetworkManager, nor DHCP
#
#           without option -s the CEN_NET_ADDR_METHOD variable is set:
#
#           dhcp          for 'simple' -or- for 'auto'|'nm' without nm installed
#           manual        for 'manual'
#           nm            for 'auto'|'nm' with nm installed
#           static        for 'static'
#
#+class:    depending on centaurinet option settings one of the following is returned.
#           Option checks are made in the listed order, 1st match winns:
#
#           server        host is a server
#           mobile        has 'option mobile'
#           phone         has 'option phone' (used also for tablets)
#           generic       has 'option generic' or is not a configured host
#           client        is a configured host
#
#.Examples: # set all state and config variables ...
#.          netquery
#
#.          # query specific state info ...
#.          local snam
#.          if netquery -s snam MASTER ; then
#.              message "I am the MASTER server:" "$snam"
#.          elif [ -z "$snam" ] ; then
#.              message "No server available"
#.          else
#.              message "Current MASTER server:" "$snam"
#.          fi
#
#.          # get current server
#.          local snam
#.          if netquery -s snam current ; then
#.              message "Known active server:" "$snam"
#.          else
#.              message "Stand alone, server:" "${snam:-<none>}"
#.          fi
# ------------------------------------------------------------------------------
netquery() {
    local _ferr _ssav _valu _stat=1 _qual
    while [ "${1::1}" = '-' ] ; do
      case "$1" in
      --)    shift ; break ;;
      -e|-f) _ferr="$1" ;;
      -q)    _qual='.' ;;
      -r)    CEN_NET_HOSTS= ; CEN_NET_ROLE= ;;
      -s)    shift ; _ssav="$1" ; printf -v "$_ssav" '' ;;
      *)     _cen_abort - "$1"
      esac ; shift
    done

    [ -z "$CEN_NET_HOSTS" ] && { netconfig $_ferr || return 1 ; }
    if [ -z "$CEN_NET_ROLE" ] ; then
        netserver || _qual=
    fi
    [ -n "$_qual" ] && _qual+="$CEN_NET_DOMAIN"

    case "$1" in
    '')             return 0
                    ;;
    PRIMARY|SECONDARY|WORKSTATION)
                    _valu="$CEN_NET_MASTER"
                    [ "$CEN_NET_ROLE" = "$1" ] && _stat=0
                    ;;
    SLAVE)          [ "$CEN_NET_MASTER" = "$CEN_NET_SERVERS" ] &&
                        _valu="${CEN_NET_SERVERS[1]}" || _valu="$CEN_NET_SERVERS"
                    [ "$CEN_NET_MODE" = 'SLAVE' ] && _stat=0
                    ;;
    MASTER|CLIENT|GUEST|SINGLE|UNKNOWN)
                    _valu="$CEN_NET_MASTER"
                    [ "${CEN_NET_MODE:-UNKNOWN}" = "$1" ] && _stat=0
                    ;;

    domain)         _valu="$CEN_NET_DOMAIN" ; _qual=
                    [ "$CEN_NET_MODE" = 'MASTER' -o "$CEN_NET_MODE" = 'SLAVE' -o \
                      "$CEN_NET_MODE" = 'CLIENT' ] && _stat=0
                    ;;
    router)         _valu="$CEN_NET_ROUTER_DEF" ; [ -n "$_valu" ] && _stat=0 ;;
    server)         _valu="$CEN_NET_SERVER_GEN"
                    [ "${2:-$HOSTNAME}" = "${CEN_NET_SERVERS[0]}" -o \
                      "${2:-$HOSTNAME}" = "${CEN_NET_SERVERS[1]}" ] && _stat=0
                    ;;

    primary)        _valu="${CEN_NET_SERVERS[0]}" ; [ -n "$_valu" ] && _stat=0 ;;
    second*)        _valu="${CEN_NET_SERVERS[1]}" ; [ -n "$_valu" ] && _stat=0 ;;
    current)        if [ '/etc/hosts' -ef '/etc/hosts_local' ] ; then
                        _valu="${CEN_NET_SERVERS[0]}"
                    elif [ '/etc/hosts' -ef "/etc/hosts_${CEN_NET_SERVERS[0]}" ] ; then
                        _valu="${CEN_NET_SERVERS[0]}" ; _stat=0
                    elif [ '/etc/hosts' -ef "/etc/hosts_${CEN_NET_SERVERS[1]}" ] ; then
                        _valu="${CEN_NET_SERVERS[1]}" ; _stat=0
                    fi ;;

    homedns)        if _cen_net_homedns _valu ; then
                        _stat=0
                        # (1) remove our own domain name (2) never qualify localhost
                        [ "${_valu#*.}" = "$CEN_NET_DOMAIN" ] && _valu="${_valu%%.*}"
                        [ "$_valu" = 'localhost' ] && _qual=
                    fi ;;

    nm)             _stat=1 ; _valu='/etc/NetworkManager'
                    [ "$CEN_NET_OUTPUT" = '.' ] && _valu=".$_valu"
                    if [ -d "$_valu" ] ; then
                        _stat='/usr/sbin/NetworkManager'
                        [ "$CEN_NET_OUTPUT" = '.' ] && _stat=".$_stat"
                        if [ -x "$_stat" ] || [ -x "${_stat/sbin/bin}" ] ; then
                            _stat=0
                        fi
                    fi ; _qual= ;;

    connect)        # explicit host given, ignore '*'
                    [ "${2:--}" = '-' ] && set -- "$1" "$HOSTNAME"
                    if   netoption -x 'manual' "$2" ; then  _valu='manual'
                    elif netoption -x 'static' "$2" ; then  _valu='static'
                    elif netoption -x 'nm'     "$2" ; then  _valu='nm'
                    elif netoption -x 'auto'   "$2" ; then  _valu='auto'
                    # use the fallback default (e.g. *)
                    elif netoption    'static' "$2" ; then  _valu='static'
                    elif netoption    'nm'     "$2" ; then  _valu='nm'
                    elif netoption    'auto'   "$2" ; then  _valu='auto'
                    # nothing at all, same as 'manual'
                    else                                    _valu='manual'
                    fi
                    if [ -z "$_ssav" ] ; then
                        if [ "$_valu" = 'nm' -o "$_valu" = 'auto' ] ; then
                            netquery 'nm' && _valu='nm' || _valu='dhcp'
                        fi
                        _ssav='CEN_NET_ADDR_METHOD'
                    fi
                    _qual= ; _stat=0
                    ;;
    class)          [ "${2:--}" = '-' ] && set -- "$1" "$HOSTNAME"
                    if [ "$2" = "${CEN_NET_SERVERS[0]}" -o \
                         "$2" = "${CEN_NET_SERVERS[1]}" -o \
                         "$2" = "$CEN_NET_SERVER_GEN" ]
                    then                                    _valu='server'
                    elif netoption 'mobile'  "$2" ; then    _valu='mobile'
                    elif netoption 'phone'   "$2" ; then    _valu='phone'
                    elif netoption 'generic' "$2" ; then    _valu='generic'
                    elif nethost "$2" ; then                _valu='client'
                    else                                    _valu='generic'
                    fi
                    _qual= ; _stat=0
                    ;;
    config)         _valu="${CEN_NET_CONFIG:-${CEN_NET_DOMAIN%%.*}}"
                    _qual= ; _stat=0
                    ;;
    *)              _cen_abort - "$*"
    esac

    [ -n "$_valu" ] && _valu+="$_qual"
    [ -n "$_ssav" ] && printf -v "$_ssav" "%s" "$_valu"
    return $_stat
}

# ------------------------------------------------------------------------------
# netresolv - Read or write an /etc/resolv.conf file
#
# Call:     (1) netresolv -r [<what>]
#           (2) netresolv [-d <host>] [<domain>|- [<server>|-...]]
#
# Options:  -d  specify the 1st nameserver
#           -r  read into _netresolv array (<domain>, <dns>...)
#
# Arguments:<host>     a fully qualified host name
#           <domain>   the DNS domain name
#           <server>   a fully qualifed DNS server name
#           <what>     read filter: search|domain|nameserver
#
#.Examples: netresolv              # write configured defaults to resolv.conf
#.          netresolv -d alpha     # put alpha at 1st place
#.          netresolv - -          # empty resolv.conf
#.          netresolv - srv - rtr  # no "dns" option check after -
# ------------------------------------------------------------------------------
_netresolv=
netresolv() {
    local conf="${CEN_PATHS[2]:-/etc}/resolv.conf"

    # read resolv.conf
    if [ "$1" = '-r' ] ; then
        _netresolv=()
        if [ ! -r "$conf" ] ; then
            error $"Cannot read file:" "$conf" ; return 1
        fi
        local keyw valu xxxx
        while read -r keyw valu xxxx ; do
            [ -n "$2" ] && [ "$keyw" != "$2" ] && continue
            case "$keyw" in
            domain)                             # must preceed nameserver
                _netresolv=("${valu:--}") ;;
            search)                             # fallback only ...
                [ -z "$_netresolv" ] && _netresolv+=("${valu:--}") ;;
            nameserver)
                _netresolv+=("${valu:--}")
            esac
        done < "$conf"
        [ -n "$_netresolv" ] && return 0 ; return 1 # failure if no data
    fi

    # default host
    local ssvr dflt
    if [ "$1" = '-d' ] ; then
        shift ; dflt="$1" ; shift
    fi

    netconfig || return 1
    local nl=$'\n' serv copt="dns" maxs=3

    # handle the domain
    local sdom rdom="${1:-$CEN_NET_DOMAIN}" ; shift
    [ "${rdom:--}" = '-' ] || sdom="domain $rdom${nl}search $rdom"

    # loop over arguments -or- servers/routers
    [ -z "$1" ] && set -- ${CEN_NET_SERVERS[@]} - ${CEN_NET_ROUTERS[@]}
    if [ "$*" = '-' ] ; then
        ssvr="# no known nameserver" ; sdom=
    else
        for serv in "$dflt" "$@" ; do
            [ $maxs -gt 0 ] || break
            if [ "${serv:--}" = '-' ] ; then            # no check for routers
                copt= ; continue
            fi
            if [ -n "$copt" ] ; then
                netoption "$copt" "$serv" || continue   # check for dns
            fi
            [ "$serv" = "$dflt" -a -n "$ssvr" ] && continue
            nethost "$serv" && serv="$_nethost_ip"
            ssvr+="${nl}nameserver $serv" ; maxs=$((maxs - 1))
        done
    fi

    # write the file
    netfile -h <<!EOF "$conf"
$sdom$ssvr
!EOF
}

# ------------------------------------------------------------------------------
# netserver - Save/load server status
#
# Call:     netserver [-w <role> <mode> <master>]
#
# Options:  -w  save status file (default is to load)
#
# Arguments:<role>    **PRIMARY** | **SECONDARY** | **WORKSTATION** | **UNKNOWN**
#           <mode>    **MASTER** | **SLAVE** | **CLIENT** | **GUEST** | **SINGLE** | **UNKNOWN**
#           <master>  server name
#
# Return:   **true** if an entry was found or **false** on failure
#
# Storage:  CEN_NET_FILE_STAT="$CEN_NET_DIR_RUN/network_status"
#
# Variables:The functions reads or stores the current values:
#
#               CEN_NET_ROLE        # see <role>
#               CEN_NET_MODE        # see <mode>
#               CEN_NET_SERVER      # generic server name
#               CEN_NET_MASTER      # see <master>
# ------------------------------------------------------------------------------
netserver() {
    # read the file
    if [ "$1" != '-w' ] ; then
        _cen_source "$CEN_NET_FILE_STAT"
        return                      # return status
    fi

    # remove the status files
    shift
    if [ "$1" = '-' -a "$#" = 1 ] ; then
        _cen_net_remove "$CEN_NET_FILE_STAT" "$CEN_NET_FILE_PROX"
        return
    fi

    # role (imply WORKSTATION for CLIENT)
    local role="$1"
    if [ "${1:--}" = '-' ] ; then
        role='UNKNOWN' ; [ "$2" = 'CLIENT' ] && role="WORKSTATION"
    fi

    # find name of server
    local sgen smas
    if [ "$2" = 'GUEST' ] ; then
        sgen="$3"
    else
        netconfig
        smas="${3%%.*}"
        [ -n "$smas" ] && sgen="$CEN_NET_SERVER_GEN"
    fi

    # write a new proxy file
    netproxy -w "${smas:-$sgen}"

    # write a new status file
    CEN_NET_ROLE="$role"
    CEN_NET_MODE="${2:-UNKNOWN}"
    CEN_NET_SERVER="$sgen"
    CEN_NET_MASTER="$smas"

    netfile -h <<!EOF "${CEN_NET_FILE_STAT}"
# The computer's role (PRIMARY, SECONDARY, WORKSTATION, UNKNOWN):
CEN_NET_ROLE='$CEN_NET_ROLE'

# The current mode (MASTER, SLAVE, CLIENT, GUEST, SINGLE, UNKNOWN):
CEN_NET_MODE='$CEN_NET_MODE'

# The domain server (empty if not connected to server):
CEN_NET_SERVER='$CEN_NET_SERVER'
CEN_NET_MASTER='$CEN_NET_MASTER'
!EOF
}

# ------------------------------------------------------------------------------
# nettool - ip configuration helper via ip|ifup|ifdown or other tool
#
# Call:     (1) nettool [-f|-q|-w] -d <dev> [-r] [--] up|down|isup|exists
#
#           (2) nettool [-f|-q|-w] [-4|-6] [-r] [-d <dev>] -a [--] <cmd> <arg>...
#           (3) nettool [-f|-q|-w] [-4|-6] [-r] [-d <dev>] -o [--] <cmd> <arg>...
#           (4) nettool [-f|-q|-w] [-4|-6] [-r] [-d <dev>] -i <what> [--] <cmd> <arg>...
#
#           (5) nettool [-f|-q|-w] [-4|-6] [-r] [-d <dev>] -t [--] <tool> <arg>...
#
#           (6) nettool [-f|-q|-w] [-4|-6] [-r] [-d <dev>|all] [--] on|off|status
#
#+          Form (1) checks or changes the interface status. It runs **ifup**/**ifdown**
#           for interfaces managed by **ifup**. The 'down' action uses **ip link down**
#           for interfaces that are not managed by **ifup**.
#
#+          Form (2) or (3) run **ipaddr** or **iproute** optionally checking for
#           an interface to exist. Form (4) runs **ip**<what> and can insert <dev>
#           after <cmd>. Any tool can be run using form (5).
#
#+          Form (6) sets or checks "/proc/sys/net/ipv?/conf/.../disable_ipv?" to enable
#           or disable the IPv6 protocol stack.
#
# Options:  -4  [*] use ipv4 (adds option -4 when running a tool)
#           -6  use ipv6 (adds option -6 when running a tool)
#           -c  also check for carrier with 'isup' and 'exists'
#           -d  [*] interface to be used
#           -f  call [[fatal()]] on error
#           -a  run 'ip ... address ...'  (optionally adds 'dev ...')
#           -i  run 'ip ... <what> ...'   (optionally adds 'dev ...')
#           -o  run 'ip ... route ...'    (optionally adds 'dev ...')
#           -q  no error messages
#           -r  ignore option --dryrun
#           -t  run a tool
#           -w  call [[warning()]] on error
#
#           [*] ifup/ifdown style suffixes (see 'eth0:0') are ignored when checking
#               interface existence and up/down state. Whenn adding or deleting an
#               ipv4 addresse a 'label' option is generated for **ip**.
#
# Arguments:<dev>       a kernel interface name (optionally with label)
#
#.Examples: # run: ip -6 address list dev wlan0
#.          nettool -d wlan0 -6 -a list
#
#.          # run: ip address add dev wlan0 label wlan0:0 10.21.2.80/22
#.          nettool -d wlan0:0 -a add 10.21.2.80/22
#
#.          # run: ip link dev eth0 set mtu 1200
#.          nettool -d eth0 -i link set mtu 1200
#
#.          # run a tool (unlike for 'ip' no 'dev ...' is added automatically)
#.          nettool -d wlan0 -w -t iw dev wlan0 set 4addr on
# ------------------------------------------------------------------------------
nettool() {
    local _ifce _fipv _ferr='-e -p' _oerr='error' _orun _labl _tool _carr _cmnd _mode _temp _what _stat
    while [ "${1::1}" = '-' ] ; do
        case "$1" in
        --)     shift ; break ;;
        -4|-6)  _fipv="$1" ;;
        -a)     _tool='ip' ; _what='address' ;;
        -c)     _carr=1 ;;
        -d)     shift ; _ifce="$1" ;;
        -f)     _ferr='-f -p' ; _oerr='fatal' ;;
        -i)     shift ; _tool='ip' ; _what="$1" ;;
        -o)     _tool='ip' ; _what='route' ;;
        -q)     _ferr='-q' ; _oerr=: ;;
        -r)     _orun='-r' ;;
        -t)     shift ; _tool="$1" ;;
        -w)     _ferr='-w -p' ; _oerr='warning' ;;
        *)      _cen_abort - "$1"
        esac ; shift
    done

    # do we need a device label (ifconfig compatibility)
    if [ "$_ifce" != "${_ifce%:*}" ] ; then
        _labl="${_ifce##*:}" ; _ifce="${_ifce%:*}"
    fi

    # no tool specified - check command argument
    if [ -z "$_tool" ] ; then
        _cmnd="${1::3}"
        case "$_cmnd" in
            '')         _cen_abort 'missing <cmd>' ;;
            up|dow)     _mode=1 ;;
            isu|exi)    _mode=1 ;;
            on|off|sta) _mode=2 ;;
            *)          _cen_abort '?' "$1"
        esac
    fi

    # ipv4/6 status set/check
    if [ "$_mode" = 2 ] ; then
        [ -z "$_fipv" ] && _cen_abort = '-4|-6'
        # check disable_ipvX file
        _temp="ipv${_fipv:1}"
        _temp="/proc/sys/net/$_temp/conf/${_ifce:-all}/disable_$_temp"
        if [ ! -r "$_temp" ] ; then
            # currently ipv4 is always on
            [ "$_fipv" = '-4' -a  "$_cmnd" != 'off' ] && return 0
            $_oerr $"No such file:" "$_temp" ; return 2
        elif [ "$_cmnd" = 'sta' ] ; then
            read -r _stat < "$_temp"
            [ "$_stat" = 0 ] ; return               # return status
        elif [ ! -w "$_temp" ] ; then
            $_oerr $"Cannot write to:" "$_temp" ; return 2
        fi
        [ "$_cmnd" = 'on' ] && _stat=0 || _stat=1
        dryrun -- "echo $_stat >$_temp" && return 1
        echo "$_stat" >"$_temp" ; return            # return status
    fi

    # does interface exist? Get status
    if [ -n "$_ifce" ] ; then
        # check interface existence, get up/down status
        if [ ! -r "/sys/class/net/$_ifce/flags" ] ; then
            [ "$_cmnd" = 'exi' ] && return 1
            [ "$_cmnd" = 'dow' ] && return 0        # don't worry
            if [ "${_ifce::2}" = 'br' -a "$_cmnd" = 'up' ] ; then
                # bridge needs not to exist before 'up'
                _tool='ifup' ; set -- '--force' "$_ifce"
            else
                $_oerr $"No such interface:" "$_ifce" ; return 1
            fi
        elif [ "$_mode" = 1 ] ; then
            [ "$_cmnd" = 'exi' -a -z "$_carr" ] && return 0

            # get interface status via IF_UP, see: include/uapi/linux/if.h (bit 1 is IF_UP)
            read _stat <"/sys/class/net/$_ifce/flags"
            [ $((_stat &= 1)) = 1 ] && _stat='up'               # interface is up

            if [ "$_stat" = 'up' ] ; then
                if [ -n "$_carr" ] ; then
                    read _stat <"/sys/class/net/$_ifce/carrier" 2>/dev/null
                    [ "${_stat:--0}" = 0 ] && return 1          # no carrier
                    [ "$_cmnd" = 'exi' ] && return 0
                fi
                [ "$_cmnd" = 'isu' -o "$_cmnd" = 'up' ] && return 0
                if [ -e "/run/network/ifstate.$_ifce" ] ; then  # managed by ifup ...
                    _tool='ifdown' ; set -- '--force' "$_ifce"
                else                                            # link level only ...
                    _tool='ip' ; set -- link set down "$_ifce"
                fi
            else
                [ "$_cmnd" = 'isu' ] && return 1
                [ "$_cmnd" = 'dow' ] && return 0
                [ "$_cmnd" = 'exi' ] && return 0
                if sysrun -q ifquery "$_ifce" ; then            # managed by ifup ...
                    _tool='ifup' ; set -- '--force' "$_ifce"
                else
                    _tool='ip' ; set -- link set up "$_ifce"
                fi
            fi
        fi
    fi

    # does a given tool exist?
    [ -z "$_tool" ] && return 1
    sysfind ${_ferr/-p/} -c -s _tool -- "$_tool" || return 1

    # add 'dev' and 'label' for ip command
    local _acmd=("$_tool" $_fipv)
    if [ -n "$_what" ] ; then
        _acmd+=("$_what" "$1") ; shift
        [ -n "$_ifce" ] && _acmd+=('dev' "$_ifce")
        [ -n "$_labl" ] && _acmd+=('label' "$_ifce:$_labl")
    fi
    _acmd+=("$@")

    # run the tool
    dryrun $_orun -s -- "${_acmd[@]}" && return 0
    if [ "$_ferr" = '-q' ] ; then
        $CEN_TRACE2 -a -c ' run' "${_acmd[*]}"
        "${_acmd[@]}" &>/dev/null || return $?
    else
        sysrun $_orun $_ferr -v -- "${_acmd[@]}" || return $?
    fi
    return 0
}

# ------------------------------------------------------------------------------
# Startup - read config unless '-n' is used: [-n]
# ------------------------------------------------------------------------------

[ "$1" = '-n' -o "$1" = '-A' ] || netconfig
:

# end
