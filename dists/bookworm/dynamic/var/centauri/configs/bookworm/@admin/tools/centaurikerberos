#!/usr/bin/bash
# ------------------------------------------------------------------------------
CEN_LEGAL="Copyright Dr. J. Pfennig (c) 2019-2025; "$"BSD License"
CEN_TITLE=$"Samba-AD/Kerberos/NFS management tool"

# Import the bash library, set name and version
PATH+=":${0%/*}" . _centauri_bash_lib -a -d -f -s -t -y - '0.34:6' || exit 2

# Data
DAT_KEYTAB='/etc/krb5.keytab'
DAT_RUN_INIT=           # for action init/fallback
DAT_DIR_SECRETS="$CEN_ROOT/secrets"
DAT_SEED_LIST=          # see get_seed
DAT_SERVER=()           # see server_info()

DAT_VERB=               # current command verb, see check_verb
DAT_ARGS=               # argument array of current verb

# data for extra options
CEN_OPT_SEED=           # see --seed
CEN_OPT_KERBEROS=       # see --kerberos
CEN_OPT_OUTPUT=         # see --output
CEN_OPT_PASSWORD=       # see --password
CEN_OPT_SERVER=         # see --server

# ------------------------------------------------------------------------------
# helpers
# ------------------------------------------------------------------------------

# check if there is an --output file: -no args-
check_output() {
    if [ "${CEN_OPT_OUTPUT:--}" = '-' ] ; then
        invoke -e $"Needs an output file, use '--output'" ; return 1
    fi

    if [ "${CEN_OPT_OUTPUT/ /}" != "$CEN_OPT_OUTPUT" ] ; then
        error $"Cannot use spaces in output file name" ; return 1
    fi

    if [ -e "$CEN_OPT_OUTPUT" ] ; then
        confirm -a -q $"Replace existing output file" "'$CEN_OPT_OUTPUT'" || return 1
        remove -f -- "$CEN_OPT_OUTPUT"
    fi
    return 0
}

# check argument for verb (create|delete|list), set DAT_VERB and DAT_ARGS
check_verb() {
    local nerr
    [ "$1" = '-q' ] && { nerr=1 ; shift; }
    case "$1" in
    cre*|add)   DAT_VERB='create' ; shift ;;
    del*)       DAT_VERB='delete' ; shift ;;
    lis|list)   DAT_VERB='list'   ; shift ;;
    *)          [ -z "$nerr" ] && invoke -e $"Invalid verb '%s'" "$1"
                return 1 ;;
    esac
    DAT_ARGS=("$@") ; return 0
}

# verify user: <princ>
check_user() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        local list line
        system -a list -q -r -- kadmin.local -q "listprincs $1"
        for line in "${list[@]}" ; do
            line="${line%%@*}"
            [ "$line" = "$1" ] && return 0
        done
    else
        system -q -r -- samba-tool user setexpiry --noexpiry "$1" && return 0
    fi
    $CEN_TRACE2 -a -c $"No such account" "$1"
    return 1
}

# check access to kadmin.local: <tool>...
check_tools() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        system -c -e kadmin.local "$@"
    else
        system -c -e samba-tool net "$@"
    fi
}

# check if runnung at MASTER
check_master() {
    dryrun && return
    netquery MASTER && return 0
    invoke -e $"Must be run at the MASTER server"; return 1
}

# check if kerberos is installed, get ticket cache path
get_krb5cc() {
    # check kerberos config
    if ! system -c kinit klist kdestroy ; then
        message -a $"Missing kerberos tools - do nothing" ; return 1
    fi
    if [ ! -e '/etc/krb5.conf' ] ; then
        message -a $"Missing kerberos configuration - do nothing" ; return 1
    fi

    # fix ticket cache path, see actionTicket for explanation
    case "$KRB5CCNAME" in
    '')     export KRB5CCNAME="FILE:${XDG_RUNTIME_DIR:-/tmp}/krb5cc_$EUID"
            ;;
    FILE:*) local mesg='trace' file="${KRB5CCNAME#*:}"
            if [ ! -r "$file" ] ; then
                [ -z "$SUDO_USER" ] && mesg='warning'
                $mesg -a $"Ignoring non-readable cache:" "$KRB5CCNAME"
                export KRB5CCNAME="FILE:${XDG_RUNTIME_DIR:-/tmp}/krb5cc_$EUID"
            fi
            ;;
    *)      warning -a $"Unknown cache type:" "$KRB5CCNAME"
    esac
    trace -a $"Ticket cache path:" "$KRB5CCNAME"
    return 0
}

# get a password: [-c] <vnam>|- <user> (-c ignores smb* passwd files), set USER
#
#   Default for <user>  empty   ->  smbadmin
#                       -       ->  Administrator
#
#   Option --password ovrrides the passed user parameter
#   User 'root' will not be prompted for a password
#   Environment var USER will be set to <user>[%<paswd] (samba)
#
get_paswd() {
    local _copt _upwd
    if [ "$1" = '-c' ] ; then
        _copt=1 ; shift
    fi
    local _snam="$1" _pasw _user="${2:-smbadmin}"   # default user
    [ "$_user" = '-' ] && _user='Administrator'
    [ "${_snam:--}" != '-' ] && { local -n _vnam="$1" ;  _vnam= ; }
    export USER=

    ___set_vnam() {
        if [ -z "$CEN_OPT_KERBEROS" ] ; then        # samba password syntax
            [ -z "$2" ] && USER="$1" || USER="$1%$2"
        else                                        # no user for kerberos
            USER="$2"
        fi
        [ "${_snam:--}" != '-' ] && _vnam="$USER"
    }

    case "$CEN_OPT_PASSWORD" in
    '')   ;;
    -)      ___set_vnam 'root' ; return 0 ;;
    *%*)    ___set_vnam "${CEN_OPT_PASSWORD%\%*}" \
                        "${CEN_OPT_PASSWORD#*%}" ; return 0 ;;
    *)      ___set_vnam "$_user" "$CEN_OPT_PASSWORD" ; return 0
    esac

    if [ -z "$_copt" ] ; then                       # no pwd change, use secrets file
        case "$_user" in
            smbadmin)   get_secret _upwd _pasw 'samba_admin' || _user='Administrator' ;;
            smbtrust)   get_secret _upwd _pasw 'samba_trusted' ;;
            smbworld)   get_secret _upwd _pasw 'smaba_public' ;;
            root)       ___set_vnam 'root' ; return 0
        esac
        if [ -n "$_upwd" ] ; then
            ___set_vnam "$_upwd" "$_pasw" ; return 0
        fi
    fi

    if [ -z "$_copt" ] && get_seed _pasw "$_user" ; then
        ___set_vnam "$_user" "$_pasw" ; return 0
    fi

    CEN_CONFIRM=
    confirm -a -f -p + -u $"Enter password for '%s'  " "$_user"
    if [ -z "$_copt" ] ; then                       # no pwd change ...
        [ -n "$CEN_CONFIRM" ] || return 1;
        ___set_vnam "$_user" "$CEN_CONFIRM" ; CEN_CONFIRM=
        return 0
    fi

    [ -n "$CEN_CONFIRM" ] &&
        confirm -a -f -p + -u -s _pasw $"Confirm password for '%s'" "$_user"
    if [ -z "$CEN_CONFIRM" ] ; then
        warning -a $"Password not changed" ; return 1
    elif [ "$_pasw" != "$CEN_CONFIRM" ] ; then
        warning -a $"Passwords are different" ; return 1
    fi
    [ "${_snam:--}" != '-' ] && _vnam="$CEN_CONFIRM" ; CEN_CONFIRM= ; return 0
}

# get password from cifs style secrets file: <vnam> <vpwd> <file>
get_secret() {
    [ "${1:--}" = '-' ] || printf -v "$1" ''
    [ "${2:--}" = '-' ] || printf -v "$2" ''
    [ -r "$DAT_DIR_SECRETS/$3" ] || return 1
    local _line _snam _spas
    while read _line ; do
        [ "${_line::9}" = 'username=' ] && _snam="${_line:9}"
        [ "${_line::9}" = 'password=' ] && _spas="${_line:9}"
    done <"$DAT_DIR_SECRETS/$3"
    [ "${1:--}" = '-' ] || printf -v "$1" '%s' "$_snam"
    [ "${2:--}" = '-' ] || printf -v "$2" '%s' "$_spas"
    [ -n "$_spas" ]                                 # return status
}

# get a password from seed file: <vsec> <user>
get_seed() {
    local -n _vsec="$1" ; _vsec=
    [ -z "$CEN_OPT_SEED" ] && return 1
    if [ -z "$DAT_SEED_LIST" ] ; then
        configfile -v -r DAT_SEED_LIST -n "$CEN_OPT_SEED" || quitOnError
    fi
    local _item
    for _item in "${DAT_SEED_LIST[@]}"  ; do
        if [[ "$_item" == $2=* ]] ; then
            _vsec="${_item#*=}" ; return 0
        fi
    done
    trace -a -p $"Name '%s' is not in seed file" "$2" ; return 1
}

# warning unless --silent is set
invoke_warn() {
    [ -z "$CEN_OPT_SILENT" ] && invoke -w "$@"
}

# list hosts (USER env provides password): [-s] [<glob>]
list_hosts() {
    local fsta
    if [ "$1" = '-s' ] ; then
        fsta=1 ; shift
    fi
    local rslt item name glob="${1,,}" ; [ "$glob" = '-' ] && glob=

    run_samba_tool -r rslt dns query - "${DAT_SERVER[@]}" @ ALL
    for item in "${rslt[@]}" ; do
        trimjoin -l -s item -- "$item"
        case "$item" in
        Name=*) item="${item:5}" ; name="${item%%,*}" ; name="${name,,}"
                [ -n "$glob" ] && [ "${name/$glob/}" = "$name" ] && name=
                ;;
        A:*)    [ -z "$name" ] && continue
                item="${item#* }" ; item="${item%% *}"
                [ -n "$fsta" ] && return 0
                printf "%-12s %s\n" "$name" "$item"
                ;;
        AAAA:*) [ -z "$name" ] && continue
                item="${item#* }" ; item="${item%% *}"
                [ -n "$fsta" ] && return 0
                printf "%-12s %s\n" "$name" "$item"
                ;;
        esac
    done
    [ -n "$fsta" ] && return 1 || return 0
}

# list users: [-m] [<glob>]
list_users() {
    local mach
    if [ "$1" = '-m' ] ; then
        shift ; mach=1
    fi
    local glob="$1" ; [ "$glob" = '-' ] && glob=

    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        local list line
        system -a list -q -r -- kadmin.local -q "listprincs $glob"
        for line in "${list[@]}" ; do
            [ "${line/\//}" = "$line" ] || continue     # nor a user
            line="${line%%@*}"
            [ "${line:${#line}-1}" = "$" ] && continue  # ignore machine
            echo "$line"
        done
    else
        #system -r -z samba-tool user list
        local ulst uout=() item
        run_samba_tool -r ulst user list
        for item in "${ulst[@]}" ; do
            if [ -n "$mach" ] ; then
                if [ "${item/./}" = "$item" ] ; then        # not a machine
                    [ "${item::5}" = 'root/' ] || continue  # older samba-tools
                fi
            else
                [ "${item::5}" = 'root/' ] && continue      # older samba-tools
                [ "${item/./}" = "$item" ] || continue      # machine ignored
            fi
            [ -n "$glob" ] && [ "${item/$glob/}" = "$item" ] && continue
            uout+=("$item")
        done
        txtsort -a ulst -i uout
        splitjoin -s - -l -i ulst
    fi
    return 0
}

# password retry iterator: <vpwd> <vusr>  (also exports USER for samba tools)
run_retry_iter() {
    USER= ; CEN_CONFIRM=
    local -n _rtrp="$1" _rtru="$2"
    if [ -n "$_rtrp" ] ; then
        _rtru='Administrator'
        message -a $"Something went wrong, enter a non-empty password to try again..."
        confirm -a -f -p + -s "$1" -u $"Enter password for '%s'  " "$_rtru" || return 1
        error -c
        [ -z "$CEN_OPT_KERBEROS" ] && _rtrp="$_rtru${_rtrp:+%}$_rtrp"
    else
        get_paswd _rtrp "$_rtru" || return 1
    fi
    export USER="$_rtrp" ; CEN_CONFIRM=
    return 0
}

# [-m|-r|-t|-q|-w] <vnam>|- <what> <verb> [<pasw>|-|'' <arg>...]
#
#   samba tools have option -U (--user) which overrides the current user and
#   have a password (<user>%<pasw>). This may cause security warnings, so we
#   provide the password using the 'USER' environment variable. If the fourth
#   call argument is empty/missing no -U option is passed to samba tools.
#
run_samba_tool() {
    local _args=() _oerr='-e' _info _stat
    while [ "${1::1}" = '-' ] ; do
        case "$1" in
        -)  break ;;
        --) shift ; break ;;
        -m|-r|-t)
            _args+=("$1") ;;
        -q|-w)
            _oerr="$1" ;;
        *)  _cen_abort - "$1"
        esac ; shift
    done

    case "$1" in
    '') _args+=('-a' '_info') ;;
    -)  _args+=('-z') ;;
    *)  _args+=('-a' "$1")
    esac
    _args+=('samba-tool' "$2" "$3")
    if [ -n "$4" ] ; then
        [ "$4" = '-' ] && _args+=('-U' "${USER%\%*}") || _args+=('-U' "$4")
    fi
    system -g 0 $_oerr -p "${_args[@]}" "${@:5}" ; _stat=$?
    [ -n "$_info" ] && trace -a -c 'samba_tool info' -- "$_info"
    [ "$_stat" != 0 ] && trace -a  -c 'run_samba_tool' -- "${_args[*]}"
    return $_stat
}

# write samba name/type file: <host> <mode>
samba_state() {
    if [ $# = 2 ] ; then
        local list=("CEN_SAMBA_NAME='$1'" "CEN_SAMBA_TYPE='$2'")
        create -t -v list -h - -- "$CEN_PERSISTENT/$CEN_NAME" 664
    else
        _cen_source -- "$CEN_PERSISTENT/$CEN_NAME"
    fi
}

# get active server name into DAT_SERVER(master domain)
server_info() {
    if [ -z "$DAT_SERVER" ] ; then
        netquery -s DAT_SERVER    primary
        netquery -s DAT_SERVER[1] domain
        if [ -z "$DAT_SERVER" ] ; then
            DAT_SERVER='-'
            error $"No server found in configuration"
        fi
    fi
    [ "$DAT_SERVER" != '-' ]                        # return status
}

# ------------------------------------------------------------------------------
# Make a computer a secure NFS client: [<admn>]
# ------------------------------------------------------------------------------
# Samba:    This handler is invoke by verb 'client' and 'register'. It uses
#           actionJoin (if invoked via 'client') and actionMachine (indirectly
#           via 'centaurisecrets'). It also exchanges ssh key to allow the
#           server to login at the client without password prompt.
#
#           actionJoin runs locally, to create a machine account at the server.
#           'centaurisecrets register' is used to run actionMachine at the
#           server to create SPNs. It also updates local '/ect/krb5.keytab':
#
#               actionJoin (for action=client only)
#               -> centaurisecrets register
#                   ->  centaurimachines --add ...
#                   ->  centaurikerberos machine create -- keytab
# ------------------------------------------------------------------------------
actionClient() {
    # tool k5start is in debain package kstart ...
    local gssm=('kinit' 'adcli') gpak=('krb5-user' 'adcli')
    local opts ; [ -n "$CEN_OPT_FORCE" ] && opts='--force'

    # -------------------------------- kerberos --------------------------------
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"Kerberos support not implemented"

    # ---------------------------------- samba ---------------------------------
    else
        # use MIT kerberos, adcli wants it, sasl/sssd need gssapi
        if ! PATH+=':/usr/sbin' system -c -q -- "${gssm[@]}" ; then
            confirm -a -q $"Install tools"" (${gssm[*]})" &&
                embed -v -z centauripackage --silent --tool --update=2 --yes "${gpak[@]}"
        fi

        if netquery server &&[ "$HOSTNAME" = "${CEN_NET_SERVERS[0]}" ] ; then
            message -a $"This computer is a server, nothing to join or register"
            return
        fi
        server_info || return

        # add server public key to authorized keys
        [ -h ~/.ssh -a ! -e ~/.ssh/id_rsa ] && embed -r -- centauriencfs -q mount -
        if   [ ! -e '/root/.ssh/authorized_keys' ] ; then
            create -f -- '/root/.ssh/authorized_keys' 600
        elif [ ! -w '/root/.ssh/authorized_keys' ] ; then
            warning $"Cannot access root's authorized_keys"
        fi

        # make sure to have an ssh id key
        [ -e ~/.ssh/id_rsa ] || system -t -e -p ssh-keygen -q -N '' -f ~/.ssh/id_rsa
        trace -a $"Copy ssh id to master"
        if ! system -q ssh-copy-id "${CEN_NET_SERVERS[0]}" ; then
            confirm -n $"Failed to copy ssh id to master. Continue anyhow" || quit -s 1
        fi

        local keys item
        inpdata -r -a keys -- "$HOME/.ssh/authorized_keys"
        for item in '*ssh_server_key' '*_server_root' ; do
            listsearch -n item -o -g -i keys -- "$item" && break
            item=
        done

        if [ -n "$item" ] ; then
            trace -a -c "$item" $"Already authorized"
        elif [ -e "$CEN_ROOT/secrets/ssh_server_key.pub" ] ; then
            embed -v centaurssh authorize "$CEN_ROOT/secrets/ssh_server_key.pub"
        else
            warning $"Missing public SSH key of server, will ask for password"
        fi

        # join domain and register repositiory
        if [ "$CEN_ACTION" = 'client' ] ; then
            if system -c samba-tool ; then
                embed -v centaurisecrets $opts local
                actionJoin "${1:--}"
            else
                warning -c $"samba-tool not found" $"samba is not installed"
            fi
            embed -v centaurisecrets $opts register -- client ; timer -w 2
            embed -v centauriswitch --force auto    # --force to ignore override
        # register for repository only
        elif confirm -n -y $"Register at server (repository)" ; then
            embed -v centaurisecrets $opts register -- client ; timer -w 2
        fi

        # clients don't export data via nfs ...
        system -e -p systemctl mask nfs-server rpc-svcgssd

        if filestat -q -p "$DAT_KEYTAB" size && [ "${CEN_FILESTAT:-0}" -gt 8 ] ; then
            message -a $"Restarting sssd service"
            runservice stop sssd
            remove /var/lib/sss/db/* /var/log/sssd/*
            runservice start sssd
        else
            warning $"Not restarting sssd service (empty keytab)"
        fi
    fi
}

# ------------------------------------------------------------------------------
# Invalidate ticket: -no args-
# ------------------------------------------------------------------------------
actionDestroy() {
    get_krb5cc || return                            # check install, get path
    system -e -p -- kdestroy
}

# ------------------------------------------------------------------------------
# Manage dns records
# ------------------------------------------------------------------------------
actionDns() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"kerberos does not manage DNS records" ; return
    fi

    check_verb -q "$@" || { DAT_VERB="$1" ; shift ; DAT_ARGS=("$@") ; }
    check_master || return
    check_tools || return
    server_info || return

    get_paswd - 'smbadmin' || return

    local data=() dns_name dns_addr=()
    local -A dns_dict dns_host

    # get a list of host (libnsswitch should be configured to use 'files' 1st)
    ___dns_hosts() {
        local list item wrds name
        system -r -a list -- getent ahostsv4 "$@" || return
        for item in "${list[@]}" ; do
            splitjoin -s wrds -d ' \t' -- "$item"
            if [ -n "$1" ] ; then
                [ -n "${wrds[2]}" ] && name="${wrds[2]}"
                dns_host["$wrds"]="${name%%.*}"
            else
                for name in "${wrds[@]:1}" ; do
                    dns_host["$wrds"]="${name%%.*}"
                done
            fi
        done
        message -a -c 'host entries' "${#dns_host[@]}"
    }

    # parse samba-tool query output into dns_name and dns_addr, call ___dns_flush
    ___dns_list() {
        local stat=0 wrds
        while [ $# -gt 0 ] ; do
            splitjoin -s wrds -d ', \t' -- "$1"
            $CEN_TRACE2 -a -c 'dns query' "${wrds[*]}"
            case "$stat$wrds" in
            ?Name=_*)   ___dns_flush
                        stat=0 ;;                   # internal name
            ?Name=*)    ___dns_flush
                        stat=1
                        dns_name="${wrds#*=}"
                        ;;
            1A:)        dns_addr+=("${wrds[1]}")
                        ;;
            1AAAA:)     dns_addr+=("${wrds[1]}")
                        ;;
            *)          ___dns_flush
                        trace -a -c 'dns ignore' "${wrds[*]}"
                        stat=0
            esac
            shift
        done
        ___dns_flush
    }

    # add output of ___dns_list to dns_dict
    ___dns_flush() {
        if [ -n "$dns_addr" ] ; then
            trace -a -c -p 'dns host' '%-12s %s' "$dns_name" "${dns_addr[*]}"
            dns_dict["${dns_name:-@}"]+="${dns_addr[*]} "
        fi
        dns_name= ; dns_addr=()
    }

    # process entries in dns_dict to list or remove ip addresses
    ___dns_process() {
        local item entr iopt addr list=("${!dns_dict[@]}") ndns nnss
        txtsort -i list -a list
        for entr in "${list[@]}" ; do
            splitjoin -s addr -d ' ' -- "${dns_dict["$entr"]}"
            txtsort -i addr -a addr
            iopt=
            for item in "${addr[@]}" ; do
                # if a specific host is set samba-tool expects its name ...
                [ "$entr" = '@' -a "${DAT_ARGS:-@}" != '@' ] && entr="$DAT_ARGS"
                ndns="$entr"                            # the dns name
                if [ "$DAT_VERB" = 'list' ] ; then
                    nnss="${dns_host["$item"]}"         # the libnsswitch name
                    if [ -z "$nnss" ] ; then
                        printf '    %-12s [-]  %-39s\n' "$entr" "$item"
                    elif [ "$ndns" = "$nnss" ] ; then
                        printf '    %-12s      %-39s\n' "$entr" "$item"
                    else
                        printf '    %-12s [*]  %-39s  (%s)\n' "$entr" "$item" "$nnss"
                    fi
                    entr=
                else
                    ___dns_remove "$entr" "$item" $iopt
                    iopt='-i'
                fi
             done
        done
    }

    # <host> <addr> [-i]
    ___dns_remove() {
        if [ "$1" = '@' ] ; then                # delete unnamed entry
            confirm $3 -f -n -q $"Remove '%s'" "$2" || return
        else                                    # delete named entry
            confirm $3 -f -n -q $"Remove '%-12s' '%s'" "$1" "$2" || return
        fi
        local kind dummy
        [ "${2/:/}" = "$2" ] && kind='A' || kind='AAAA'
        run_samba_tool dummy 'dns' 'delete' - "${DAT_SERVER[@]}" "$1" "$kind" "$2"
    }

    # custom commands: create remove list

    case "$DAT_VERB" in
    cre*)   local addr="${DAT_ARGS[1]}" dummy
            case "${addr:--}" in
            *:*:*)      DAT_ARGS=("$DAT_ARGS" 'AAAA' "$addr") ;;
            *.*.*.*)    DAT_ARGS=("$DAT_ARGS" 'A'    "$addr") ;;
            -)          if system -q -r -s addr -- getent hosts "$DAT_ARGS" ; then
                            DAT_ARGS=("$DAT_ARGS" 'A' "${addr%% *}")
                        else
                            invoke -e $"Host name is unknown" ; return
                        fi ;;
            *)          invoke -e $"Expected an IPv4 or IPv6 address as argument" ; return
            esac
            run_samba_tool dummy 'dns' 'add' - "${DAT_SERVER[@]}" "${DAT_ARGS[@]}"
            return ;;
    rem*|list)
            [ -z "$DAT_ARGS" ] && DAT_ARGS='@'
            [ "$DAT_ARGS" = '@' ] && ___dns_hosts || ___dns_hosts "$DAT_ARGS"
            run_samba_tool -r data 'dns' 'query' - "${DAT_SERVER[@]}" "$DAT_ARGS" 'A'
            ___dns_list "${data[@]}"
            run_samba_tool -r data 'dns' 'query' - "${DAT_SERVER[@]}" "$DAT_ARGS" 'AAAA'
            ___dns_list "${data[@]}"
            ___dns_process ; return ;;
    esac

    # native commands: add delete query ...

    invoke -w $"Using native samba-tool command:" "$DAT_VERB"
    run_samba_tool - 'dns' "$DAT_VERB" - "${DAT_SERVER[@]}" "${DAT_ARGS[@]}"
}

# ------------------------------------------------------------------------------
# Manage AD groups
# ------------------------------------------------------------------------------
actionGroup() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"kerberos does not manage groups" ; return
    fi

    check_verb -q "$@" || { DAT_VERB="$1" ; shift ; DAT_ARGS=("$@") ; }
    check_master || return
    check_tools || return

    local flds list
    splitjoin -s flds -d ':' -- "${DAT_ARGS[0]}"
    local fnam="${flds[0]}"
    local fgid="${flds[1]:-}"
    local fgco="${flds[2]:-}"

    # ------------------------------ pre-condition -----------------------------

    if [ "$DAT_VERB" = 'create' ] ; then
        if [ "$fgid" = '-' ] ; then
            invoke -e $"Missing unix gid" "$DAT_VERB ${DAT_ARGS[0]}" ; return
        fi
        server_info || return

        local opts=(--gid-number "$fgid" --nis-domain "${DAT_SERVER[1]}")
        [ "$fgco" != '-' ] && opts+=(--description "$fgco")
        run_samba_tool - group add '' "$fnam" "${opts[@]}"
    elif [ "$DAT_VERB" = 'delete' ] ; then
        run_samba_tool - group delete '' "$fnam"
    elif [ "$DAT_VERB" = 'list' ] ; then
        run_samba_tool -r list group list '' -v || return
        case "$2" in
        -|'')   ;;
        [!^]*)  txtgrep -i list -a list -y "*$2*" ;;
        *)      txtgrep -i list -a list -y "${2:1}"
        esac
        txtsort -i list -a list ; outdata -a -o list
    else
        invoke -w $"Using native samba-tool command:" "$DAT_VERB"
        run_samba_tool - group "$DAT_VERB" '' "${DAT_ARGS[@]}"
    fi

    # ---------------------------------- samba ---------------------------------
    #invoke -e $"samba support not implemented" ; return
}

# ------------------------------------------------------------------------------
# Add IP address to AD/DC dns
# ------------------------------------------------------------------------------
actionHost() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"kerberos does not manage hosts" ; return
    fi
    check_verb "$@" || return
    check_master || return
    check_tools || return

    local host
    splitjoin -s host -d ':' -- "${DAT_ARGS[0]}"
    local add6 addr="${host[1]:--}"
    if [ "$DAT_VERB" != 'list' ] ; then
        if [ "$addr" = '-' ] ; then
            nethost -- "${host,,}"
            if [ -z "$_nethost_ip" ] ; then
                invoke -e $"Verb '%s' can't find an IPv4 address" "$DAT_VERB $host" ; return
            fi
            addr="$_nethost_ip"
        fi
        netoption 'ipv6' "${host,,}" &&                 # get ULA ipv6 address
            netconv -u "$addr" && add6="$_netconv"
    fi

    server_info || return

    if [ "$DAT_VERB" = 'create' ] ; then
        get_paswd - 'smbadmin' || return
        if list_hosts -s "$host" ; then
            invoke_warn $"'%s' - host already existing" "$DAT_VERB $host"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
        run_samba_tool '' dns add - "${DAT_SERVER[@]}" "$host" A "$addr"
        [ -n "$add6" ] &&
            run_samba_tool - dns add - "${DAT_SERVER[@]}" "$host" AAAA "$add6"

    elif [ "$DAT_VERB" = 'delete' ] ; then
        get_paswd - 'smbadmin' || return
        if ! list_hosts -s "$host" ; then
            invoke_warn $"'%s' - host does not exist" "$DAT_VERB $host"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
        run_samba_tool '' dns delete - "${DAT_SERVER[@]}" "$host" A "$addr"
        [ -n "$add6" ] &&
            run_samba_tool - dns delete - "${DAT_SERVER[@]}" "$host" AAAA "$add6"

    elif [ "$DAT_VERB" = 'list' ] ; then
        get_paswd - 'smbtrust' || return
        list_hosts "$host"
    else
        invoke -e $"Verb '%s' not implemented" "$DAT_VERB"
    fi
}

# ------------------------------------------------------------------------------
# Get ticket for user (gui version): [<user>]
# ------------------------------------------------------------------------------
actionInit() {
    [ "$CEN_ACTION" = 'renew' ] && DAT_RUN_INIT=2 || DAT_RUN_INIT=1
    embed -m _centauri_bash_win
    windows -i 2
    actionTicket "${1:-+}"
    embed -i centaurisession roaming auto       # switch documents/roaming
    DAT_RUN_INIT=
}

# ------------------------------------------------------------------------------
# Add join a samba domain: [<admn>]                     (default: Administrator)
# ------------------------------------------------------------------------------
# samba:    This creates the samba machine account and keys. It overrides the
#           /etc/krb5.keytab file. The machine account is insufficient for nfs,
#           we still need SPNs, see actionMachine (to be run at the server).
#
#           After join Samba has created an intermediate keytab which will be
#           replaced when 'centaurisecrets client' loads server secrets. That
#           keytab is persistently stored in the server's staging area, see
#           actionClient for details.
# ------------------------------------------------------------------------------
actionJoin() {

    # ------------------------------ pre-condition -----------------------------
    check_tools || return
    server_info || return
    local serv pasw user="${1:--}"

    if netquery server ; then
        confirm -n -y $"Join samba AD domain as a controller" || quit -s 1
        serv=1
    else
        confirm -n -y $"Join samba AD domain, enable NFS" || quit -s 1
    fi

    # samba needs the server dns to find the domain controller
    [ "$DAT_SERVER" = '-' ] && DAT_SERVER="$CEN_NET_SERVERS"

    while run_retry_iter pasw user ; do
        progress -i -l $"This can take a while ..."

        # ---------------------------- controller ------------------------------
        if [ -n "$serv" ] ; then
            run_samba_tool - domain join - --server "$DAT_SERVER" \
                         "$CEN_NET_DOMAIN" DC && break

        # ---------------------------- kerberos --------------------------------
        elif [ -n "$CEN_OPT_KERBEROS" ] ; then
            system -m -- net rpc join member --user "$user" && break

        # ------------------------------ samba ---------------------------------
        else
            # use 'net ads join' to become a member server (no DNS update)
            system -g 0 -e -z -- net ads join --server "$DAT_SERVER" \
                           --no-dns-updates --user "$user" && break
        fi
    done
}

# ------------------------------------------------------------------------------
# Export a keytab
# ------------------------------------------------------------------------------
actionKeytab() {
    check_master || return
    check_tools  || return
    check_output || return
    get_paswd - 'smbadmin' || return

    local dnam hnam=("${1:--}")
    netquery -f -s dnam domain
    if [ "$hnam" = '+' ] ; then
        hnam=("${CEN_NET_SERVERS[@]}")
    else
        isname -e -h -- "$hnam" || return
    fi

    # -------------------------------- kerberos --------------------------------
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        system -c -e kadmin.local || return
        local qstr="ktadd -k $CEN_OPT_OUTPUT -norandkey local -glob nfs/$hnam*"
        system -q -- kadmin.local -q "$qstr"

    # ---------------------------------- samba ---------------------------------
    else
        local temp serv args=(- domain exportkeytab - "$CEN_OPT_OUTPUT" --principal)
        for serv in "${hnam[@]}" ; do
            # 1st pass to check if we have a machine account
            tmpfile -f -s temp
            run_samba_tool -t -w - domain exportkeytab - "$temp" --principal "${serv^^}\$"
            [ ! -s "$temp" ] &&
                invoke -w $"Server '%s' has no machine account" "$serv"
            # This is for sssd to authenticate a (uppercase for adcli) user...
            run_samba_tool -t "${args[@]}" "${serv^^}\$"
            # This is for nfs old style ...
            run_samba_tool -t "${args[@]}" "root/${serv}.${dnam}"
            # This is for nfs ...
            run_samba_tool -t "${args[@]}" "${serv}.${dnam}"
            run_samba_tool -t "${args[@]}" "nfs/${serv}.${dnam}"
        done
        # ... and finally the user 'local'
        run_samba_tool -t    "${args[@]}" 'local'
    fi

    if [ -n "$CEN_OPT_DRYRUN" -o -s "$CEN_OPT_OUTPUT" ] ; then
        system -e -p -t -- chmod g+r "$CEN_OPT_OUTPUT"
        system -e -p -t -- chgrp staff "$CEN_OPT_OUTPUT"
    else
        invoke -e $"Processing failed, got no output"
    fi
}

# ------------------------------------------------------------------------------
# Leave AD/DC domain: [<admn>]                          (default: Administrator)
# ------------------------------------------------------------------------------
actionLeave() {
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"Must not use --kerberos" ; return
    fi
    netquery PRIMARY && { invoke -e $"Refusing to run at primary server" ; return ; }
    check_tools || return
    server_info || return
    local arem pasw user="${1:--}" verb='leave'

    if netquery server ; then
        confirm -n -y $"Remove DC from samba AD domain" || quit -s 1
        verb='demote'
    else
        confirm -n -y $"Remove host from samba AD domain" || quit -s 1
    fi

    # see https://wiki.samba.org/index.php/Demoting_a_Samba_AD_DC
    while run_retry_iter pasw user ; do
        run_samba_tool - domain "$verb" - && break
    done
    matchpath -a arem -e -- '/var/lib/samba/'secrets.* || return
    confirm -n -y $"Remove samba db secrets.*" || return
    remove -- "${arem[@]}"

    ### TODO slave should not demote
    ### TODO stop service, switch config
}

# ------------------------------------------------------------------------------
# Manage machine account: [-q] <verb> <host>|+
# ------------------------------------------------------------------------------
actionMachine() {
    check_verb "$@" || return
    check_master || return

    # ------------------------------ pre-condition -----------------------------
    check_tools || return
    server_info || return
    [ "${DAT_ARGS[0]}" = '+' ] && DAT_ARGS[0]="$HOSTNAME"
    local hnam="${DAT_ARGS[0]}" pnfs="nfs/${DAT_ARGS[0]}.${DAT_SERVER[1]}" root
    [ -n "$CEN_OPT_KERBEROS" ] && root="$pnfs" || root="${pnfs#nfs/}"

    if [ "$DAT_VERB" = 'create' ] ; then
        check_user "$root"
        if [ "$?" = 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke_warn "'%s' - machine account already existing" "$DAT_VERB $hnam"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
    elif [ "$DAT_VERB" = 'delete' ] ; then
        check_user "$root"
        if [ "$?" != 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke_warn $"'%s' - machine account does not exist" "$DAT_VERB $hnam"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
    fi

    # -------------------------------- kerberos --------------------------------
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        if [ "$DAT_VERB" = 'create' ] ; then
            system -e -p -- kadmin.local -q  "add_principal -randkey $hnam $pnfs"
        else
            invoke -e $"Verb '%s' not implemented" "$DAT_VERB" ; return
        fi

    # ---------------------------------- samba ---------------------------------
    else
        local user pasw rcnt=0
        get_paswd pasw - || return ; user="${pasw%\%*}"

        if [ "$DAT_VERB" = 'create' ] ; then
            # samba heimdal kerberos needs a root user for SPNs
            run_samba_tool    - user create  - --random-password "$root"
            run_samba_tool -t - user setexpiry - --noexpiry "$root"
            if error -t ; then                          # if no error ...
                # set SPN encryption types (via root accout)
                while ! system -q -- net --user "$user" ads enctypes set "$root" 24 ; do
                    # sometimes it fails with status 255, wait and try again
                    trace -a $"Will retry 'net ads enctypes'" ; timer -w 1
                    ((rcnt += 1)) ; [ "$rcnt" -lt 5 ] && continue
                    system -e -p -- net --user "$user" ads enctypes set "$root" 24
                    break
                done
                # create SPN for debian rpc.gssd
                run_samba_tool - spn add - "$pnfs" "$root"
                # another old style SPN
                run_samba_tool - spn add - "${pnfs/nfs/root}" "$root"
            fi

        elif [ "$DAT_VERB" = 'delete' ] ; then
            # delete (1) owner of SPNs (2) machine account
            run_samba_tool -q - user delete - "$root"
            run_samba_tool -q - computer delete - "$hnam"
        else
            list_users -m "$hnam" ; return
        fi
    fi

    # ----------------------------- post-condition -----------------------------
    check_user "$root"
    if [ "$?" = 0 ] ; then
        [ "$DAT_VERB" = 'delete' ] &&
            invoke -e $"'%s' - machine could not be deleted" "$hnam"
    else
        [ -n "$CEN_OPT_DRYRUN" ] && return
        [ "$DAT_VERB" = 'create' ] &&
            invoke -e $"'%s' - machine account not created" "$hnam"
    fi
}

# ------------------------------------------------------------------------------
# change password: <user> [<pasw>]
# ------------------------------------------------------------------------------
actionPasswd() {
    local user="$1" pasw="${2:--}" stat

    # ------------------------------ pre-condition -----------------------------

    check_master || return
    check_tools || return
    check_user "$user"
    if [ "$?" != 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
        invoke -e $"'%s' - user does not exist" "$user"
        return
    fi

    if [ "$pasw" = '-' ] ; then             # get passwd via stdin ...
        get_paswd -c pasw "$user" || return
    fi

    # -------------------------------- kerberos --------------------------------
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        local opts=("$user")
        [ "$pasw" != '-' ] && opts=(-pw '$pasw' "$user")
        system -q -- kadmin.local -q "change_password ${opts[@]}"
        stat=$?

    # ---------------------------------- samba ---------------------------------
    else
        get_paswd - 'root' || return
        local opts=("$user" '--newpassword' "$pasw")
        run_samba_tool - user setpassword - "${opts[@]}"
        stat=$?
    fi

    # ----------------------------- post-condition -----------------------------
    if [ "$stat" != 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
        invoke -e $"'%s' - password change failed" "$user"
        return
    fi
}

# ------------------------------------------------------------------------------
# Samba AD/DC provisioning: <pswd>|-
# ------------------------------------------------------------------------------
actionProvision() {
    local dlis item sdel pasw="$1"
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        invoke -e $"Must not use --kerberos" ; return
    fi

    [ -z "$pasw" ] && get_seed pasw 'Administrator'         # empty -> random pwd
    if [ "$pasw" != '-' -a -z "$CEN_OPT_FORCE" ] ; then
        check_master || return
    fi
    check_tools 'egrep' || return

    # This implements: https://wiki.samba.org/index.php/Setting_up_Samba_as_an_Active_Directory_Domain_Controller

    warning $"This command will reset all Samba AD/DC data!"
    confirm -q -a $"No Samba tool must be running. Continue" || quit -s 1

    # -s don't report invalid service
    runservice -s stop krb5-admin-server.service krb5-kdc.service samba smbd nmbd samba-ad-dc winbind

    system -a dlis -q -r -- pgrep 'samba|smbd|nmbd|winbindd'
    if [ -n "$dlis" ] ; then
        confirm -q -a "'pgrep \"samba|smbd|nmbd|winbindd\"'" \
                      $"shows running tools. Ignore" || quit -s 1
    fi

    system -a dlis -e -p -r -- eval 'smbd -b | egrep "CONFIGFILE|SMB_PASSWD_FILE|LOCKDIR|STATEDIR|CACHEDIR|PRIVATE_DIR"'
    for item in '/etc/krb5.conf' "${dlis[@]}" ; do
        item="${item#*: }"
        [ -e "$item" ] || continue
        if [ -d "$item" ] ; then
            set -- "${item// /\\ }"/*
            [ "${item// /\\ }/*" = "$1" ] && continue
            item+='/*'
        fi
        message -a -c $"To be deleted" -- "$item"
        item="${item// /\\ }"
        sdel+=" $item"
    done
    sdel="${sdel:1}"
    if [ -n "$sdel" ] ; then
        confirm -q -n $"Delete the listed files/folder"
        remove -d $sdel
    fi

    [ -h '/etc/samba/smb.conf' ] && remove '/etc/samba/smb.conf'
    system -e -p -- systemctl unmask samba-ad-dc
    if [ "$pasw" = '-' ] ; then
        message $"Cleared samba config/state" ; return
    fi

    local sdom
    netquery -f -s sdom domain ; sdom="${sdom^^}"   # get domain
    netconv -u "$CEN_NET_ADDR_IPLIST"               # ipv6 generic address

    local opts=(--use-rfc2307 --host-ip="$CEN_NET_ADDR_IPLIST" --host-ip6="$_netconv" \
                --realm="$sdom" --domain="${sdom%%.*}" --quiet)
    [ -n "$pasw" ] && opts+=(--adminpass "$pasw")
    run_samba_tool - domain provision '' "${opts[@]}" || return

    # this file should have been created by samba ...
    copy '/var/lib/samba/private/krb5.conf' '/etc/krb5.conf'

    run_samba_tool - domain passwordsettings '' set --complexity=off --min-pwd-length=4
    run_samba_tool - domain passwordsettings '' set --history-length=0
    run_samba_tool - domain passwordsettings '' set --min-pwd-age=0 --max-pwd-age=0
}

# ------------------------------------------------------------------------------
# Renew ticket: <user>|+
# ------------------------------------------------------------------------------
actionRenew() {
    local user="${1:--}" item list=()
    if [ "$user" = '+' ] ; then                     # renew all tickets via caches
        system -e -c kinit krenew || return
        context -r || return

        for item in /tmp/krb5cc_[1-9]* ; do
            [ -f "$item" ] || continue
            user="${item##*/krb5cc_}" ; user="${user%%_*}"
            [ -n "$user" -a -z "${user//[0-9]/}" ] && list+=("$user $item")
        done
        for item in /run/user/[1-9]*/krb5cc* ; do
            [ -f "$item" ] || continue
            user="${item:10}" ; user="${user%%/*}"
            [ -n "$user" -a -z "${user//[0-9]/}" ] && list+=("$user $item")
        done

        for item in "${list[@]}" ; do
            user="${item%% *}" ; item="${item#* }"
            if system -g 0 -q -- krenew -k "$item" ; then
                message -a $"Renewed via ticket cache:" "$item"
                system -q -- chown $user "$item"
            else
                message -a $"Deleted ticket cache:" "$item"
                remove "$item"
            fi
        done

    elif system -q -- krenew ; then                 # renew current ticket
        message $deco $"Renewed existing kerberos ticket" ; return
    else                                            # init or renew
        actionInit "$user"
    fi
}

# ------------------------------------------------------------------------------
# Restore status fro, tar: <file>
# ------------------------------------------------------------------------------
actionRestore() {
    inpfile -x 'tgz' -- "${1:--}" || return
    check_tools 'tar' || return
    actionProvision -
    error -t || return
    confirm -n -y $"Overwrite existing SAMBA/krb5 configuration" || quit -s 1
    system -e -p -- tar --directory=/ -xaf "$CEN_INPFILE"
}

# ------------------------------------------------------------------------------
# Save status to tar: <file> [<base>]
# ------------------------------------------------------------------------------
actionSave() {
    local base="${2:--}" curr="$PWD" pref
    if [ "$base" = '-' ] ; then
        base='/'
    else
        base="${base%/}" ; curr="$PWD" ; pref="$curr"
        folder -- "$base" || return
    fi
    outfile -c -x 'tgz' -- "${1:--}" || return
    check_tools 'egrep' 'tar' || return

    local dlis item star
    system -a dlis -e -p -r -- eval 'smbd -b | egrep "CONFIGFILE|SMB_PASSWD_FILE|STATEDIR|PRIVATE_DIR"'

    folder -c -f -- "$base"
    for item in '/etc/krb5.conf' "${dlis[@]}" ; do
        item="${item#*: }"
        [ -e "$item" ] || continue
        if [ -d "$item" ] ; then
            set -- "${item// /\\ }"/*
            [ "${item// /\\ }/*" = "$1" ] && continue
            item+='/*'
        elif [ "${item##*/}" = 'smb.conf' ] ; then
            item="${item%/*}/*"
        fi
        message -a -c $"To be saved" -- "$pref$item"
        item="${item// /\\ }"
        star+=" ${item#/}"
    done
    system -e -p -- tar -caf "$CEN_OUTFILE" $star
    folder -c -f -- "$curr"
}

# ------------------------------------------------------------------------------
# Send keytab to client: <host>
# ------------------------------------------------------------------------------
# This is used by additional DCs, as servers do not use the keytab stored in the
# staging folder. Clients load the keytab via centaurisecrets from staging.
# ------------------------------------------------------------------------------
actionSend() {
    local pmsg host="${1:--}"
    [ "$host" = '+' ] && host="$HOSTNAME"
    isname -e -h -- "$host" || return

    if [ -z "$CEN_OPT_OUTPUT" ] ; then
        tmpfile -n -s CEN_OPT_OUTPUT -- "$host.keytab"
    fi

    actionKeytab "$host" ; error -t || return

    if [ "$host" = "$HOSTNAME" ] ; then
        printf -v pmsg $"Install '%s' on local host" "$CEN_OPT_OUTPUT"
        # use quit to keep keytab without sending
        confirm -a -q "$pmsg" && copy -a "$CEN_OPT_OUTPUT" "$DAT_KEYTAB"
    else
        printf -v pmsg $"Send '%s' to host '%s'" "$CEN_OPT_OUTPUT" "$host"
        confirm -a -q "$pmsg" || return
        embed -v -i centaurissh -f -U 'root' copy "$CEN_OPT_OUTPUT" "$host:$DAT_KEYTAB"
    fi
}

# ------------------------------------------------------------------------------
# Server testing: start|stop|restart|master|slave|local
# ------------------------------------------------------------------------------
# Full setup including dns, firewall and nfs:
#       master      switch -> master, set resolv.conf
#       slave       switch -> slave, set resolv.conf
#       local       switch -> local, default resolv.conf
# Just stop/start samba, dnsmasq and wsdd
#       stop        stop samba
#       start       start samba
#       restart     like stop -- start
# ------------------------------------------------------------------------------
actionServer() {
    local pdns psmb strt stop mode='master' serv=('wsdd') deps
    case "$1" in
    mas*)       ;;
    sla*)       mode='slave' ;;
    loc*)       mode='local' ;;

    res*)       stop=1 ; strt=1 ;;
    sta*)       strt=1 ;;
    sto|stop)   stop=1 ; mode='local' ;;
    *)          invoke -e $"Invalid operation: %s" "$1"
    esac

    pdns="/etc/dnsmasq.d.${mode:-local}" ; pdns="${pdns/master/local}"
    psmb="/etc/samba/smb.conf.${mode:-local}"

    if [ -n "$CEN_OPT_FORCE" ] ; then
        :
    elif [ ! -d "$pdns" ] ; then
        invoke -e $"Missing '%s', run 'centaurinetgen dnsmasq'" "$pdns" ; return
    elif [ ! -f "$psmb" ] ; then
        invoke -e $"Missing samba configuration '%s'" "$psmb" ; return
    fi

    if [ -z "$strt$stop" ] ; then
        if [ "$mode" = 'local' ] ; then
            stop=1
            embed -v centaurifilter -f dnsmap
            netresolv - -                               # default (configured router)
        else
            strt=1
            embed -v centaurifilter -f dnsmap - -
            netresolv - - 127.0.0.1                     # dns via dnsmasq/samba
        fi
        symlink -n -- "$pdns" '/etc/dnsmasq.d' || return
        symlink -n -- "$psmb" '/etc/samba/smb.conf' || return
        serv+=('nfsdcld' 'nfs-mountd' 'nfs-server'
               'rpc-gssd' 'rpc-svcgssd' 'rpc-statd' 'rpcbind')
        deps=$"AD/DC and related services"
    else
        check_master || return
        deps=$"AD/DC service"
    fi

    if [ -n "$stop" ] ; then
        message -a -p $"Stopping %s" "$deps"
        runservice stop "${serv[@]}" samba-ad-dc dnsmasq
    fi
    remove '/var/lib/misc/dnsmasq.leases'
    if [ -n "$strt" ] ; then
        message -a -p $"Starting %s" "$deps"
        runservice start dnsmasq samba-ad-dc "${serv[@]}"
    fi
}

# ------------------------------------------------------------------------------
# Seetup config files: <what>...
# ------------------------------------------------------------------------------
actionSetup() {
    local fkrb fsss ferr ftru="${CEN_OPT_FORCE:+-t}"
    while [ $# -gt 0 ] ; do
        case "$1" in
        krb*)   fkrb=1 ;;
        sss*)   fsss=1 ;;
        *)      invoke -e $"Invalid configuration name:" "$1" ; ferr=1 ;;
        esac
        shift
    done
    [ -n "$ferr" ] && return

    local kdom ; netquery -f -s kdom domain
    local knam="${kdom%%.*}"
    local kpri ; netquery -f -q -s kpri primary
    local ksec ; netquery -f -q -s ksec secondary

    # ---------------------------------- krb5 ----------------------------------

    if [ -n "$fkrb" ] ; then
        local skdc='# no secondary server' ; [ -n "$ksec" ] && skdc='kdc ='
        create $ftru -h - -- '/etc/krb5.conf' 644 <<!EOF
# see: https://wiki.archlinux.org/title/Active_Directory_integration#Kerberos_Configuration
# also: samba needs DNS names (not /etc/hosts) to locate a kdc

[libdefaults]
    default_keytab_name = FILE:$DAT_KEYTAB
    default_realm = ${kdom^^}
    dns_lookup_realm = false
    dns_lookup_kdc = true
    rdns = false
    ticket_lifetime = 8d
    renew_lifetime  = 20d
#   default_ccache_name = /tmp/krb5cc_%{uid}

[logging]
    default = SYSLOG:NOTICE:DAEMON
    kdc = FILE:/var/log/kdc.log
    kadmind = FILE:/var/log/kadmind.log

[realms]
    ${kdom^^} = {
        kdc = $kpri
        $skdc $ksec
        admin_server = $kpri
        default_domain = ${kdom^^}
    }
    ${knam^^} = {
        kdc = $kpri
        $skdc $ksec
        admin_server = $kpri
        default_domain = ${kdom^^}
    }

[domain-realm]
    .centauri.home = ${kdom^^}
!EOF
        if [ ! -e "$DAT_KEYTAB" ] && ! dryrun $"Create empty keytab" ; then
            echo -e "\0005\0002\c" >"$DAT_KEYTAB"
        fi
    fi

    # ---------------------------------- sssd ----------------------------------

    if [ -n "$fsss" ] ; then
        folder -f -m '/var/log/sssd' 640
        folder -f -m '/var/lib/sss' 755
        folder -f -m '/etc/sssd' 711
        create $ftru -c -h --- '/etc/sssd/sssd.conf' 600 <<!EOF
[sssd]
#debug_level = 5
config_file_version = 2
reconnection_retries = 3
sbus_timeout = 30
domains = $kdom

[nss]
#debug_level = 5
filter_groups = root
filter_users = root
reconnection_retries = 3

[pam]
#debug_level = 5
reconnection_retries = 3
offline_credentials_expiration = 365
offline_failed_login_attempts = 32
offline_failed_login_delay = 5

[domain/$kdom]
#debug_level = 5
enumerate = true
id_provider = ad
auth_provider = ad
chpass_provider = ad
access_provider = ad
cache_credentials = true
krb5_store_password_if_offline = True
fallback_homedir = /home/%u
default_shell = ${CEN_PATHS[1]}/bash

# use real unix ids as stored in AD
ldap_id_mapping = false

# disable to avoid obscure dns problems
dyndns_update = false

# group policies (could be 'permissive')
ad_gpo_access_control = permissive

#ad_gpo_ignore_unreadable = True
#ad_gpo_map_permit = +imap, +smtp

# disable the automatic Kerberos host keytab renewal
ad_maximum_machine_account_password_age = 0

!EOF
    fi
}

# ------------------------------------------------------------------------------
#
# ------------------------------------------------------------------------------
actionStatus() {
    local data unkn=$"<unknown>"
    if [ ! -s "$DAT_KEYTAB" ] ; then
        warning $"Missing keytab:" "$DAT_KEYTAB"
    else
        if [ "$CEN_VERB" -gt 1 ] ; then
            message $"Kerberos key table:"
            system -a data -- klist -k
            data+=('')
            outdata -o data -i
        fi
        message $"Kerberos ticket:"
        syspipe -x -y -a data -o klist -- expand
        outdata -o data -i
    fi

    if samba_state ; then
        message $"Samba status:"
        message -a $"Installed name:" "${CEN_SAMBA_NAME:-$unkn}"
        message -a $"...       type:" "${CEN_SAMBA_TYPE:-$unkn}"
        if [ -n "$CEN_SAMBA_NAME" -a x"$CEN_SAMBA_NAME" != "$HOSTNAME" ] ; then
            if [ "$CEN_SAMBA_TYPE" = 'addc' ] ; then
                warning -a $"Server renamed, samba-ad-dc must be re-provisioned"
            elif [ -n "$CEN_SAMBA_TYPE" ] ; then
                warning -a $"Client renamed, please run:" "$CEN_NAME client"
            fi
        fi
    elif [ "$EUID" = 0 ] ; then
        message $"Created samba status file"
        samba_state "$HOSTNAME" ''
    fi
}

# ------------------------------------------------------------------------------
# Get (fallback) ticket: [<user>|-|+]
#
# Steps: (1) do we already have a ticket?
#        (2) try via keytab (for <user> or current user)
#        (3) if <user> missing or '-' try smbtrust/smbworld (use $DAT_DIR_SECRETS pwd)
#        (4) if <user> is given or '+' ask for password
#
# The KRB5CCNAME variable (used by klist to find its cache) is set by pam-krb5
# to something like: "File:/<folder>/krb55cc_<uid>_<random>". Unfortunately sudo
# passes this path to childs, which may be unable to read the cache data. This
# code tries to fix the path like "File:/$TMPDIR/krb55cc_<uid>_centauri" and to
# obtain a new ticket. The global bash profile "/etc/bash.local" is aware of this
# and adjusts KRB5CCNAME.
# ------------------------------------------------------------------------------
actionTicket() {
    get_krb5cc || return                            # check install, get path
    local deco='-a' ; [ -n "$DAT_RUN_INIT" ] && windows && deco='-d +3'

    # do we have a valid ticket
    if [ "$DAT_RUN_INIT" = 2 ] && system -q -- krenew ; then
        message $deco $"Renewed existing kerberos ticket" ; return
    elif system -q -- klist -s ; then
        if [ -n "$CEN_OPT_FORCE" ] ; then
            message $deco $"Valid kerberos ticket found - will continue (see --force)"
        else
            message $deco $"Valid kerberos ticket found - do nothing" ; return
        fi
    fi

    # check network mode
    if ! netquery domain ; then
        message -a $"Cannot get a kerberos ticket - no server available"
        return
    fi

    # user might be in keytab
    local kopt='-l 60h -r 8d'                   # options for kinit
    local user="${1:--}"
    [ "$user" = '-' -o  "$user" = '+' ] && user="${USER:-$LOGNAME}"
    [ "$user" = 'root' ] && user='local'
    if system -q -- kinit $kopt -k "$user" ; then
        message $deco -p $"Got kerberos ticket for '%s' via keytab" "$user" ; return
    fi
    local prin="$user" pasw

    # try smbtrust/smbworld via $DAT_DIR_SECRETS data
    if [ "$1" = '-' ] ; then
        if get_secret prin pasw 'samba_trusted' ; then
            :
        elif get_secret prin pasw 'samba_public' ; then
            :
        else
            trace -a $"Cannot get a default kerberos ticket" ; return
        fi
    elif [ "$prin" = 'smbtrust' ] ; then
        get_secret - pasw 'samba_trusted'
    elif [ "$prin" = 'smbworld' ] ; then
        get_secret - pasw 'samba_public'
    else
        prin="$user"
    fi

    # get ticket, ask for password
    trace -a $"No valid kerberos ticket found - trying with principal" "'$prin'"
    if [ -z "$pasw" ] ; then
        confirm -a -f -s pasw -p + -u \
                $"Please enter your kerberos password (user '%s')" "$prin" || return
    fi

    system -q -- kinit $kopt "$prin" <<<"$pasw"
    if [ "$?" = 0 ] ; then
        message $deco -p $"Got kerberos ticket for '%s' via password" "$prin" ; return
    else
        error $"Failed to get kerberos ticket - tried principal" "'$prin'"
    fi
}

# ------------------------------------------------------------------------------
# Unregister (demote) a machine
# ------------------------------------------------------------------------------
#   demote if server
#   centaurisecrets unregister
# ------------------------------------------------------------------------------
actionUnregister() {
    netquery PRIMARY && { invoke -e $"Refusing to unregister primary server" ; return ; }
#    if netquery server ; then
#        demote
#        confirm -n "Delete machine account" || return
#    fi
#    actionMachine delete "$1"
 #   actionUser delete "$1"

    # switch to local mode
    # actionLeave
    # run centaurisecrets unregister
}

# ------------------------------------------------------------------------------
# Add/delete samba AD or kerberos user: <verb> <spec> [<pasw>]
# ------------------------------------------------------------------------------
actionUser() {
    check_verb "$@" || return
    check_master || return
    check_tools || return

    local sget spec="${DAT_ARGS[0]}"
    if [ "${spec/:/}" = "$spec" ] ; then            # got only user name
        system -q -s sget -- getent passwd "$spec"
        [ -n "$sget" ] && spec="$sget"              # use db info
    fi
    local flds sget
    splitjoin -s flds -d ':' -- "$spec"
    local fnam="${flds[0]}"
    local fuid="${flds[2]:-65534}"
    local fgid="${flds[3]:-100}"
    local fgco="${flds[4]}"
    local fdir="${flds[5]:-/home/$fnam}"
    local frun="${flds[6]:-${CEN_PATHS[1]}/bash}"
    [ "${fdir::1}" != '/' ] && fdir='/tmp'
    [ "${frun::1}" != '/' ] && frun='/usr/sbin/nologin'

    # ------------------------------ pre-condition -----------------------------
    if [ "$DAT_VERB" = 'create' ] ; then
        check_user "$fnam"
        if [ "$?" = 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke_warn $"'%s' - user already existing" "$DAT_VERB $fnam"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
    elif [ "$DAT_VERB" = 'delete' ] ; then
        check_user "$fnam"
        if [ "$?" != 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke_warn $"'%s' - user does not exist" "$DAT_VERB $fnam"
            [ -z "$CEN_OPT_FORCE" ] && return
        fi
    elif [ "$DAT_VERB" = 'list' ] ; then
        list_users "$fnam" ; return
    else
        invoke -e $"Verb '%s' not implemented" "$DAT_VERB"
    fi

    # -------------------------------- kerberos --------------------------------
    if [ -n "$CEN_OPT_KERBEROS" ] ; then
        if [ "$DAT_VERB" = 'create' ] ; then
            local popt
            [ "${DAT_ARGS[1]:--}" = '-' ] || popt="-pw '${DAT_ARGS[1]}'"
            system -q -- kadmin.local -q "add_principal $popt $fnam"
        elif [ "$DAT_VERB" = 'delete' ] ; then
            system -q -- kadmin.local -q "delete_principal -force $fnam"
        fi

    # ---------------------------------- samba ---------------------------------
    else
        if [ "$DAT_VERB" = 'create' ] ; then
            local opts pasw
            [ -n "$fgco" ] && opts+="--gecos=$fgco"
            case "${DAT_ARGS[1]}" in
            '') if get_seed pasw "$fnam" ; then
                    opts+=("$fnam" "$pasw")
                else
                    opts+=(--random-password "$fnam")
                fi ;;
            -)  opts+=(--random-password "$fnam") ;;
            *)  opts+=("$fnam" "${DAT_ARGS[1]}")
            esac
            system -e -p -t -- samba-tool user create --uid-number="$fuid" --gid-number="$fgid" \
                                          --unix-home="$fdir" --login-shell="$frun" "${opts[@]}"
            system -e -p -t -- samba-tool user setexpiry --noexpiry "$fnam"
        elif [ "$DAT_VERB" = 'delete' ] ; then
            system -q -- samba-tool user delete "$fnam"
        fi
    fi

    # ----------------------------- post-condition -----------------------------
    if [ "$DAT_VERB" = 'create' ] ; then
        check_user "$fnam"
        if [ "$?" != 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke -e $"'%s' - user not created" "$DAT_VERB $fnam"
        fi

    elif [ "$DAT_VERB" = 'delete' ] ; then
        check_user "$fnam"
        if [ "$?" = 0 -a -z "$CEN_OPT_DRYRUN" ] ; then
            invoke -e $"'%s' - user not deleted" "$DAT_VERB $fnam"
        fi
    fi
}

   # ldapsearch -Y GSSAPI -h buster0  -b "CN=Users,DC=centauri,DC=home" name=hugo -LL
   # ldbsearch -H ldap://buster0 -k yes -b "CN=Users,DC=centauri,DC=home" -s sub name=hugo

   # install: ldap-user libsasl-gss-heimdal (o.ä) sssd-ad (o.ä)

# ------------------------------------------------------------------------------
# option parsing: <option> <argument>
# ------------------------------------------------------------------------------
options() {
    case "$CEN_ACTION" in

    -E|--seed)
        optarg 'seed'       -              -r ;;        # path
    -K|--kerberos)
        optarg 'kerberos'   -                 ;;        # flag
    -O|--out*)
        optarg 'output'     -              -t ;;        # any text
    -P|--pas*)
        optarg 'password'   -              -t ;;        # any text
    -S|--ser*)
        optarg 'server'     -                 ;;        # flag
    esac
}

# ------------------------------------------------------------------------------
# implement action parsing: <argument>...
# ------------------------------------------------------------------------------
actions() {
    case "$CEN_ACTION" in

    # before 1st action: execute at master ...
    '') if [ -n "$CEN_OPT_SERVER" ] && ! netquery MASTER ; then
            local opts=() item
            for item in "${CEN_CMDOPTS[@]}" ; do
                case "$item" in
                    --pager*)   ;;
                    --server)   ;;
                    *)          opts+=("$item")
                esac
            done
            opts+=("${CEN_CMDARGS[@]}")
            embed -r -x centaurissh -f -C -S0 exec --- "$CEN_NAME" "${opts[@]}"
        fi
        ;;

    cli*)
        invoke -r 'client'    -        0 1 ;;
    des*)
        invoke    'destroy'   -        0   ;;
    dns*)
        invoke    -           -        1 + ;;
    fal*|tic*)
        invoke    'ticket'    -        0 1 ;;
    gro*)
        invoke -r 'group'     -        2   ;;
    hos*)
        invoke    'host'      -        2   ;;
    ini|init)
        invoke    'init'      -        0 1 ;;
    joi|join)
        invoke -r 'join'      -        0 1 ;;
    key*)
        invoke -r 'keytab'    -        1   ;;
    lea*)
        invoke -r 'leave'     -        0 1 ;;
    mac*)
        invoke -r 'machine'   -        2 2 ;;
    pas*)
        invoke -r 'passwd'    -        1 2 ;;
    pro*)
        invoke -r 'provision' -        0 1 ;;
    reg*)
        invoke -r 'register'  actionClient 0 ;;
    unr*)
        invoke -r 'unregister'         1   ;;
    ren*)
        invoke    'renew'     -        0 1 ;;
    res*)
        invoke -r 'restore'   -        1   ;;
    sav|save)
        invoke -r 'save'      -        1 2 ;;
    sen|send)
        invoke -r 'send'      -        1   ;;
    ser*)
        invoke -r 'server'    -        1   ;;
    set*)
        invoke -r 'setup'     -        1 + ;;
    sta*)
        invoke    'status'    -        0   ;;
    use|user)
        invoke -r 'user'      -        2 3 ;;
#    test)
#        invoke    - -
    esac
}

# ------------------------------------------------------------------------------
# print usage info
# ------------------------------------------------------------------------------
usage() {
    usageset \
        -o - \
        -o '-E --seed    <file>' $"get passwords from seed file" \
        -o '-K --kerberos'       $"use native Kerberos (default: Samba AD/DC)" \
        -o '-O --output  <file>' $"output file" \
        -o '-P --passwd  <auth>' $"user/password for system/AD authorization" \
        -o '-S --server'         $"run at MASTER server"

    usageset \
        -p '<admn>'         $"samba domain admin or '-' (default: Administrator)" \
        -p '<auth>'         $"use '-' for user 'root', <admn>%<pasw> or <pasw>" \
        -p '<conf>'         $"config files to generate: krb5 sssd" \
        -p '<gid>'          $"unix group id" \
        -p '<gnam>'         $"group name" \
        -p '<host>'         $"computer name" \
        -p '<pasw>'         $"password                  (will prompt if missing)" \
        -p '<user>'         $"user name                 (default: smbworld/smbtrust)" \
        -p '<spec>'         $"user specification in /etc/passwd format" \
        -p '<verb>'         $"sub-action: create|delete|list" \

    usagecat << !EOF
$CEN_USE_HEADER

$CEN_USE_OPTIONS

actions:
       ••• ticket actions •••
       destroy              destroy ticket cache
       init     [<user>]    get Kerberos ticket   (GUI version of 'ticket')
       keytab   <host>|+    export a keytab for a host or the local machine
       send     <host>|+    send default keytab to host or local machine
       ticket   [<user>]    get Kerberos ticket   (smbtrust/smbworld fallback)
       renew    [<user>|+]  renew Kerberos ticket (runs 'init' if needed)
       status               show Kerberos/Samba status information

       ••• directory actions •••
       client    [<admn>]   join Samba-AD domain and enable repository access
       join      [<admn>]   join this computer into a Samba-AD domain
       leave     [<admn>]   let this computer leave a Samba-AD domain
       provision <pasw>|-   (un-)provisioning an AD/DC server, <pasw> sets the
                            'Administrator' password. Use '-' to unprovision
       register             enable repository access for this computer
       restore   <file>     restore saved samba state from tar file
       save      <file> [<base>]
                            save samba state to a tar file
       server    start|stop|restart
                            server stop/start samba, dnsmasq, wsdd only
       server    master|slave|local
                            server stop/start including dns, firewall and nfs

       ••• database actions •••
       dns      list|remove [@|<host>]
                            [#] list or remove (interactive) dns entries
       dns      create|remove @|<host> <addr>
                            [#] add or remove (batch) dns entries
       dns      <arg>...    [#] run 'samba-tool dns' with server/zone/user preset
       group    <verb> <gnam>[:<gid>[:<info>]]
                            create/list/delete a Samba-AD group
       host     <verb> <host>[:<ipv4>]
                            [#] manage a machine DNS entry
       machine  <verb> <host>
                            manage a machine Kerberos/Samba-AD account
       passwd   <user> [<pasw>]
                            change password for Kerberos/Samba-AD user
       setup    <conf>...   seed config files (krb5.conf, dummy keytab)
       user     <verb> <spec> [<pasw>]
                            create/list/delete a Kerberos/Samba-AD user

       [*] these actions try 'smbadmin' to authenticate, other actions default
           to 'Administrator'

$CEN_USE_PARAMS
!EOF

}

# ------------------------------------------------------------------------------
# Finally call the library to execute the script
# ------------------------------------------------------------------------------
main "$@" ; quit

# the end
